<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <meta name="theme-color" content="#0a0a14" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta
      name="description"
      content="DAG Dasher - anti-cheat runner on Kaspa's DAG"
    />

    <title>DAG Dasher</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        /* iOS Safari needs position: fixed for proper fullscreen */
        position: fixed;
        top: 0;
        left: 0;
        overflow: hidden;
        background: #0a0a14;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        /* Prevent pull-to-refresh and overscroll */
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
      }

      #game-container {
        width: 100%;
        height: 100%;
        position: fixed;
        top: 0;
        left: 0;
        /* Use manipulation instead of none to allow button clicks */
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* Ensure canvas renders properly on mobile */
      #game-container canvas {
        position: absolute !important;
        top: 0 !important;
        left: 0 !important;
        z-index: 1 !important;
        display: block !important;
      }

      /* Ensure buttons and interactive elements receive touch events */
      button,
      a,
      input,
      select,
      [role="button"],
      .ks-button,
      .ks-clickable {
        touch-action: manipulation;
        cursor: pointer;
        -webkit-tap-highlight-color: rgba(0, 217, 255, 0.2);
      }

      /* Loading screen */
      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: linear-gradient(180deg, #0a0a14 0%, #14081e 100%);
        z-index: 1000;
        transition: opacity 0.5s ease;
      }

      #loading-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loading-logo {
        font-size: 2.5rem;
        font-weight: bold;
        background: linear-gradient(135deg, #00d9ff 0%, #9945ff 100%);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        color: transparent;
        margin-bottom: 2rem;
      }

      .loading-bar-container {
        width: 200px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }

      .loading-bar {
        width: 0%;
        height: 100%;
        background: linear-gradient(90deg, #00d9ff, #9945ff);
        border-radius: 2px;
        transition: width 0.3s ease;
      }

      .loading-text {
        margin-top: 1rem;
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.875rem;
      }

      .loading-spinner {
        margin-top: 0.9rem;
        width: 22px;
        height: 22px;
        border: 3px solid rgba(255, 255, 255, 0.18);
        border-top-color: rgba(0, 217, 255, 0.9);
        border-radius: 50%;
        animation: spin 0.9s linear infinite;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.2s ease, transform 0.2s ease;
        pointer-events: none;
      }

      .loading-spinner.visible {
        opacity: 1;
        transform: translateY(0);
      }

      .loading-hint {
        margin-top: 1.5rem;
        max-width: 380px;
        padding: 0 1rem;
        color: rgba(255, 255, 255, 0.45);
        font-size: 0.78rem;
        line-height: 1.6;
        text-align: center;
        display: none;
      }

      .loading-hint.visible {
        display: block;
      }

      /* Error screen */
      #error-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #0a0a14;
        color: #ff4466;
        z-index: 1001;
        padding: 2rem;
        text-align: center;
      }

      #error-screen.visible {
        display: flex;
      }

      .error-title {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }

      .error-message {
        color: rgba(255, 255, 255, 0.7);
        margin-bottom: 2rem;
        max-width: 400px;
      }

      .error-node {
        color: rgba(255, 255, 255, 0.55);
        margin-bottom: 1.5rem;
        max-width: 420px;
        font-size: 0.85rem;
        line-height: 1.5;
        word-break: break-word;
      }

      .error-node-editor {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1.5rem;
        width: min(90vw, 420px);
      }

      .error-node-input {
        width: 100%;
        padding: 0.6rem 0.8rem;
        background: rgba(12, 16, 32, 0.95);
        color: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 6px;
        font-size: 0.9rem;
        outline: none;
        box-sizing: border-box;
      }

      .error-node-input:focus {
        border-color: #00d9ff;
      }

      .error-node-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .error-button {
        padding: 0.75rem 2rem;
        background: transparent;
        border: 2px solid #00d9ff;
        color: white;
        font-size: 1rem;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(0, 217, 255, 0.3);
        -webkit-appearance: none;
        appearance: none;
      }

      .error-button:hover,
      .error-button:active {
        background: rgba(0, 217, 255, 0.1);
      }

      .error-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        justify-content: center;
      }

      .error-button.secondary {
        border-color: rgba(255, 255, 255, 0.35);
        color: rgba(255, 255, 255, 0.8);
      }

      /* Game start loading screen */
      #start-loading-screen {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1002;
        background: radial-gradient(circle at top, rgba(0, 217, 255, 0.12), rgba(10, 10, 20, 0.95));
        backdrop-filter: blur(6px);
      }

      #start-loading-screen.visible {
        display: flex;
      }

      .start-loading-panel {
        width: min(90%, 420px);
        padding: 28px;
        border-radius: 16px;
        background: linear-gradient(160deg, rgba(12, 16, 32, 0.96), rgba(8, 10, 20, 0.98));
        border: 1px solid rgba(0, 217, 255, 0.25);
        box-shadow: 0 25px 60px rgba(0, 0, 0, 0.55);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        color: #ffffff;
      }

      .start-loading-title {
        font-size: 1rem;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        color: #00d9ff;
      }

      .start-loading-spinner {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 3px solid rgba(0, 217, 255, 0.15);
        border-top-color: #00d9ff;
        animation: spin 1s linear infinite;
      }

      .start-loading-text {
        font-size: 0.95rem;
        color: rgba(255, 255, 255, 0.8);
        text-align: center;
      }

      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
    </style>
  </head>
  <body>
    <!-- Loading screen -->
    <div id="loading-screen">
      <div class="loading-logo">DAG Dasher</div>
      <div class="loading-bar-container">
        <div class="loading-bar" id="loading-bar"></div>
      </div>
      <div class="loading-text" id="loading-text">Initializing...</div>
      <div class="loading-spinner" id="loading-spinner" aria-hidden="true"></div>
      <div class="loading-hint" id="loading-hint"></div>
    </div>

    <!-- Error screen -->
    <div id="error-screen">
      <div class="error-title">Something went wrong</div>
      <div class="error-message" id="error-message"></div>
      <div class="error-node" id="error-node"></div>
      <div class="error-node-editor">
        <input
          class="error-node-input"
          id="error-node-input"
          type="text"
          placeholder="Custom node ip:port (leave blank for public)"
        />
        <div class="error-node-actions">
          <button class="error-button" id="error-node-save">Save Node</button>
          <button class="error-button secondary" id="error-node-clear">Use Public</button>
        </div>
      </div>
      <div class="error-actions">
        <button class="error-button" id="error-retry">Retry</button>
        <button class="error-button secondary" id="error-main-menu">Return to Main Menu</button>
      </div>
    </div>

    <!-- Game start loading screen -->
    <div id="start-loading-screen">
      <div class="start-loading-panel">
        <div class="start-loading-title">Preparing Run</div>
        <div class="start-loading-spinner"></div>
        <div class="start-loading-text" id="start-loading-text">
          Syncing entropy from the chain...
        </div>
      </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>

    <!-- Import map for module resolution -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import { Logger, LogLevel } from "./core/Logger.js";
      import { GameFacade } from "./GameFacade.js";
      import { WalletPasswordModal } from "./ui/WalletPasswordModal.js";
      import { KKGameEngine } from "../kkGameEngine.js";

      // Configure logging
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has("debug")) {
        Logger.setLevel(LogLevel.DEBUG);
      }
      if (urlParams.has("verbose")) {
        Logger.setVerbose(true);
      }
      if (urlParams.has("trace")) {
        Logger.setupHighFidelity();
      }

      const log = Logger.create("Main");

      // UI elements
      const loadingScreen = document.getElementById("loading-screen");
      const loadingBar = document.getElementById("loading-bar");
      const loadingText = document.getElementById("loading-text");
      const loadingSpinner = document.getElementById("loading-spinner");
      const errorScreen = document.getElementById("error-screen");
      const errorMessage = document.getElementById("error-message");
      const errorNode = document.getElementById("error-node");
      const errorNodeInput = document.getElementById("error-node-input");
      const errorNodeSave = document.getElementById("error-node-save");
      const errorNodeClear = document.getElementById("error-node-clear");
      const errorRetry = document.getElementById("error-retry");
      const errorMainMenu = document.getElementById("error-main-menu");
      const gameContainer = document.getElementById("game-container");
      const startLoadingScreen = document.getElementById("start-loading-screen");
      const startLoadingText = document.getElementById("start-loading-text");
      const loadingHint = document.getElementById("loading-hint");

      // Update loading progress
      function setLoadingProgress(percent, text) {
        loadingBar.style.width = `${percent}%`;
        if (text) {
          loadingText.textContent = text;
        }

        // Show a spinner during the \"connecting\" phase so it doesn't
        // feel like the app is frozen (especially on public nodes).
        const t = (loadingText.textContent || "").toLowerCase();
        const showSpinner =
          (loadingHint?.classList?.contains("visible") ?? false) ||
          t.includes("connecting") ||
          t.includes("unlocking") ||
          t.includes("creating wallet") ||
          t.includes("checking existing wallets");

        if (loadingSpinner) {
          loadingSpinner.classList.toggle("visible", showSpinner);
        }
      }

      // Show error
      let errorRetryHandler = null;
      let errorMenuHandler = null;

      function showError(message, options = {}) {
        loadingScreen.classList.add("hidden");
        errorMessage.textContent = message;
        if (errorNode) {
          const nodeLabel = getSavedNodeLabel();
          errorNode.textContent = `Current node: ${nodeLabel}`;
        }
        if (errorNodeInput) {
          const settings = getSavedNodeSettings();
          errorNodeInput.value = settings.rpcUrl || "";
        }
        errorScreen.classList.add("visible");

        errorRetryHandler = options.onRetry || (() => location.reload());
        errorMenuHandler = options.onMainMenu || null;
        errorMainMenu.style.display = errorMenuHandler ? "inline-flex" : "none";
      }

      function getSavedNodeSettings() {
        try {
          return JSON.parse(localStorage.getItem("ks-node-settings") || "{}");
        } catch (e) {
          log.warn("Failed to read saved node settings", e?.message);
          return {};
        }
      }

      function saveNodeSettings(nextRpcUrl) {
        const settings = getSavedNodeSettings();
        if (nextRpcUrl && nextRpcUrl.trim()) {
          settings.rpcUrl = nextRpcUrl.trim();
        } else {
          delete settings.rpcUrl;
        }
        localStorage.setItem("ks-node-settings", JSON.stringify(settings));
      }

      function getSavedNodeLabel() {
        try {
          const settings = JSON.parse(localStorage.getItem("ks-node-settings") || "{}");
          if (settings && typeof settings.rpcUrl === "string" && settings.rpcUrl.trim()) {
            return settings.rpcUrl.trim();
          }
        } catch (e) {
          log.warn("Failed to read saved node settings", e?.message);
        }
        return "Public resolver (auto)";
      }

      function hideError() {
        errorScreen.classList.remove("visible");
      }

      function showStartLoading(text) {
        if (text) {
          startLoadingText.textContent = text;
        }
        startLoadingScreen.classList.add("visible");
      }

      function hideStartLoading() {
        startLoadingScreen.classList.remove("visible");
      }

      errorRetry.addEventListener("click", () => {
        hideError();
        errorRetryHandler?.();
      });

      errorMainMenu.addEventListener("click", () => {
        hideError();
        errorMenuHandler?.();
      });

      if (errorNodeSave) {
        errorNodeSave.addEventListener("click", () => {
          const value = errorNodeInput?.value ?? "";
          saveNodeSettings(value);
          location.reload();
        });
      }

      if (errorNodeClear) {
        errorNodeClear.addEventListener("click", () => {
          saveNodeSettings("");
          if (errorNodeInput) errorNodeInput.value = "";
          location.reload();
        });
      }

      function loadWalletNames() {
        try {
          const raw = localStorage.getItem('ks-wallets');
          const list = raw ? JSON.parse(raw) : [];
          return Array.isArray(list) ? list.filter(Boolean) : [];
        } catch (err) {
          return [];
        }
      }

      function saveWalletNames(names) {
        const unique = Array.from(new Set(names.filter(Boolean)));
        localStorage.setItem('ks-wallets', JSON.stringify(unique));
        return unique;
      }

      // Main initialization
      async function init() {
        try {
          log.info("Starting DAG Dasher...");

          setLoadingProgress(10, "Checking existing wallets...");

          // Check locally known wallets (no static KKGameEngine dependency)
          const storedFilename = localStorage.getItem('ks-wallet-filename');
          let walletNames = saveWalletNames([
            ...loadWalletNames(),
            ...(storedFilename ? [storedFilename] : []),
          ]);
          const hasExistingWallet = walletNames.length > 0;
          const preferredWallet = (storedFilename && walletNames.includes(storedFilename))
            ? storedFilename
            : (walletNames[0] || null);

          log.info("Wallet check", { 
            walletNames, 
            storedFilename, 
            hasExistingWallet 
          });

          // Show password modal for wallet creation or unlock
          const passwordModal = new WalletPasswordModal(document.body);
          let walletResult;

          /**
           * Attempt to unlock/create wallet with retry on wrong password
           */
          function suggestWalletName(base) {
            let name = base;
            let i = 1;
            while (walletNames.includes(name)) {
              name = `${base}_${i}`;
              i += 1;
            }
            return name;
          }

          async function attemptWalletUnlock(isRetry = false, errorMessage = null) {
            try {
              let walletSelection;

              if (isRetry) {
                walletSelection = await passwordModal.showErrorAndRetry(errorMessage);
              } else if (hasExistingWallet) {
                setLoadingProgress(22, "Select wallet and enter password...");
                walletSelection = await passwordModal.showForUnlock({
                  wallets: walletNames,
                  selected: preferredWallet,
                });
              } else {
                setLoadingProgress(22, "Create wallet password...");
                walletSelection = await passwordModal.showForCreate({
                  defaultName: suggestWalletName('default_wallet'),
                  wallets: walletNames,
                });
              }

              const { password, filename, mode } = walletSelection;

              log.info("Wallet password received");
              setLoadingProgress(25, mode === 'createWallet' ? "Creating wallet..." : "Unlocking wallet...");

              // Hide the password modal before showing the loading screen.
              passwordModal.hide();

              // Read persisted node settings
              const savedNodeSettings = JSON.parse(localStorage.getItem('ks-node-settings') || '{}');
              const customRpcUrl = savedNodeSettings.rpcUrl || '';
              const networkId = savedNodeSettings.networkId || 'testnet-10';

              // Show connecting tip on loading screen
              loadingScreen.classList.remove("hidden");
              const usingCustom = !!customRpcUrl;
              setLoadingProgress(28, "Connecting to Kaspa network...");
              if (!usingCustom) {
                loadingHint.innerHTML = 'Connecting can take longer than desired when using public Kaspa nodes. Host your own Kaspa node and connect directly to it for the best experience. Add your node\'s <strong style="color:rgba(0,217,255,0.8);">ip:port</strong> in the <strong style="color:rgba(0,217,255,0.8);">Settings</strong> menu.';
                loadingHint.classList.add("visible");
              } else {
                loadingHint.innerHTML = `Connecting to custom node <strong style="color:rgba(0,217,255,0.8);">${customRpcUrl}</strong>...`;
                loadingHint.classList.add("visible");
              }

              // Create and initialize kkGameEngine with wallet credentials + node settings
              const kkGameEngine = new KKGameEngine();
              const result = await kkGameEngine.init({
                password,
                walletName: filename,
                network: networkId,
                rpcUrl: customRpcUrl || undefined,
              });

              loadingHint.classList.remove("visible");
              localStorage.setItem('ks-wallet-filename', filename);
              walletNames = saveWalletNames([...walletNames, filename]);

              return { result, password, kkGameEngine };
            } catch (err) {
              const errMsg = err?.message || String(err);

              if (errMsg === 'Cancelled') {
                log.warn("Wallet setup cancelled, using temporary session");
                const tempFilename = 'temp_' + Date.now();
                const kkGameEngine = new KKGameEngine();
                const result = await kkGameEngine.init({
                  password: "temp_session",
                  walletName: tempFilename,
                });
                passwordModal.hide();
                return { result, password: "temp_session", kkGameEngine };
              }

              log.error("Wallet unlock failed", err);

              if (hasExistingWallet && (
                  errMsg.includes("decrypt") || 
                  errMsg.includes("Decryption") || 
                  errMsg.includes("password") ||
                  errMsg.includes("secret") ||
                  errMsg.includes("invalid") ||
                  errMsg.includes("authentication") ||
                  errMsg.includes("MAC") ||
                  errMsg.includes("tag"))) {
                return attemptWalletUnlock(true, "Incorrect password. Please try again.");
              }

              passwordModal.hide();
              throw err;
            }
          }

          // Attempt wallet unlock/create
          const walletData = await attemptWalletUnlock();
          walletResult = walletData.result;
          const walletPassword = walletData.password;
          const kkGameEngine = walletData.kkGameEngine;

          const walletAddress =
            walletResult?.address?.toString?.() ??
            String(walletResult?.address ?? "");
          log.info("Wallet ready", {
            address: walletAddress.slice(0, 20) + "...",
          });

          setLoadingProgress(30, "Checking WebGL...");

          // Check for WebGL support
          const canvas = document.createElement("canvas");
          const gl = canvas.getContext("webgl2") || canvas.getContext("webgl");
          if (!gl) {
            throw new Error(
              "WebGL is not supported. Please use a modern browser.",
            );
          }

          setLoadingProgress(40, "Initializing renderer...");

          // Create game facade with kkGameEngine reference
          let game = new GameFacade(gameContainer, {
            kkGameEngine: kkGameEngine,
          });

          // Store wallet password for mnemonic retrieval
          game.setWalletPassword(walletPassword);

          // Listen for initialization
          game.on("initialized", async () => {
            // Initialize wallet display with current balance
            await game.initWalletDisplay();

            setLoadingProgress(100, "Ready!");

            setTimeout(() => {
              loadingScreen.classList.add("hidden");
            }, 500);

            log.info("Game ready");
          });

          let lastStartMode = "singlePlayer";

          game.on("gameStarting", (data) => {
            lastStartMode = data?.mode || lastStartMode;
            const attempt = data?.attempt || 1;
            const maxAttempts = data?.maxAttempts || 3;
            showStartLoading(`Preparing game... (${attempt}/${maxAttempts})`);
          });

          game.on("gameStartRetry", (data) => {
            const attempt = data?.attempt || 1;
            const maxAttempts = data?.maxAttempts || 3;
            showStartLoading(`Retrying connection... (${attempt}/${maxAttempts})`);
          });

          game.on("gameStartReady", () => {
            hideStartLoading();
          });

          game.on("gameStartFailed", (data) => {
            hideStartLoading();
            const message = data?.message || "Failed to start the game";
            showError(message, {
              onRetry: () => {
                if (lastStartMode === "singlePlayer") {
                  game.startSinglePlayer();
                } else {
                  // Retry multiplayer game start (re-enter lobby flow)
                  game.retryMultiplayerStart?.() || game.showMainMenu();
                }
              },
              onMainMenu: () => game.showMainMenu(),
            });
          });

          game.on("error", (data) => {
            log.error("Game error", data);
            if (data?.phase === "start") {
              return;
            }
            showError(data.message || "An error occurred", {
              onRetry: () => location.reload(),
            });
          });

          setLoadingProgress(60, "Loading assets...");

          // Initialize
          await game.init();

          // Make available globally for debugging
          window.kaspaSurfer = game;
          window.kkGameEngine = kkGameEngine;

          log.info("Game initialized with kkGameEngine");
        } catch (e) {
          log.error("Initialization failed", e);
          showError(e.message || "Failed to initialize game");
        }
      }

      // Handle orientation changes
      function handleOrientation() {
        // Force redraw on orientation change
        setTimeout(() => {
          window.dispatchEvent(new Event("resize"));
        }, 100);
      }

      window.addEventListener("orientationchange", handleOrientation);

      // Track touch start for pull-to-refresh prevention
      let touchStartY = 0;
      document.addEventListener(
        "touchstart",
        (e) => {
          touchStartY = e.touches[0].clientY;
        },
        { passive: true },
      );

      // Prevent pull-to-refresh but allow button interactions
      document.addEventListener(
        "touchmove",
        (e) => {
          // Don't interfere with buttons, inputs, or scrollable elements
          if (e.target.closest('button, a, input, select, .ks-audit-view, .ks-modal, [role="button"]')) {
            return;
          }
          
          // Only prevent default for pull-to-refresh (scrolling down from top)
          const touchY = e.touches[0].clientY;
          const scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
          
          if (scrollTop === 0 && touchY > touchStartY) {
            // Trying to pull down from top - prevent refresh
            e.preventDefault();
          } else if (e.target.closest("#game-container canvas")) {
            // Prevent scrolling on game canvas
            e.preventDefault();
          }
        },
        { passive: false },
      );

      // Prevent context menu
      document.addEventListener("contextmenu", (e) => {
        e.preventDefault();
      });

      // Start
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", init);
      } else {
        init();
      }
    </script>
  </body>
</html>
