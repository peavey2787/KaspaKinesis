'use client'

import { useState } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { ChevronDown, HelpCircle } from 'lucide-react'
import { ScrollReveal } from '../animations'
import { cn } from '@/lib/utils'

const KKMark = () => (
  <span className="font-semibold">
    <span className="text-primary">ê“˜</span>
    <span className="text-secondary">K</span>
  </span>
)

const faqs = [
  {
    question: 'Is this a full game engine?',
    answer: (
      <>
        No, <KKMark /> is not a full-featured game engine like Unity or Unreal. It's a specialized
        infrastructure layer that provides provable randomness and decentralized networking for
        multiplayer games. You would use <KKMark /> alongside your existing game framework to handle
        entropy, state synchronization, and peer connectivity. Think of it as the "fair play" backbone
        for your game.
      </>
    ),
  },
  {
    question: 'Do I need to run servers?',
    answer: (
      <>
        No! That's one of the key innovations. <KKMark /> uses the Kaspa BlockDAG as both a source of
        randomness and a relay layer for peer discovery. Players communicate with eachother with
        End-to-End encryption on Kaspa. There are no game servers to maintain, scale, or pay for. The
        only infrastructure you need is already running: the Kaspa network itself. Run a node yourself
        and allow your players to connect to your node to ensure the best performance and reliability
        or use public nodes.
      </>
    ),
  },
  {
    question: 'How is randomness provable?',
    answer: (
      <>
        Every random number generated by <KKMark /> can be traced back to specific Kaspa and Bitcoin
        blocks. The Recursive Folding algorithm takes these block hashes and combines them with 
        Quantum Random Number Generation (QRNG) data to produce uniform random values.
        While blockchain data is inherently public, <KKMark /> ensures the entire process is 
        transparent by providing a VRF Proof for every result. This proof includes the specific block
        hashes, QRNG seeds, and the exact number of hashing iterations used. Since these inputs are
        documented in our audit logs, any third party can re-run the algorithm to verify that the 
        randomness was not manipulated. Furthermore, we utilize QRNG sources that undergo NIST 
        SP 800-22 statistical testing to ensure the entropy meets the highest cryptographic standards
        for quality.
      </>
    ),
  },
  {
    question: 'Can this work beyond games?',
    answer: `Absolutely! While games are the primary use case for the hackathon demo, the primitives are general-purpose. Any application needing provable fairness could benefit: lotteries, random selection systems, dispute resolution, prediction markets, or any interactive system where participants need to trust that outcomes aren't rigged. The deterministic state engine is useful anywhere you need auditable, reproducible computation.`,
  },
  {
    question: 'What happens if a player disconnects?',
    answer: `The deterministic state engine handles this gracefully. Since all state can be reconstructed from anchored checkpoints plus the action log, a reconnecting player can catch up to the current state. Other players continue playing, and the disconnected player's state is preserved. For time-sensitive games, you can implement timeout rules at the game logic layer.`,
  },
  {
    question: 'How does this compare to other blockchain gaming solutions?',
    answer: (
      <>
        Most blockchain games put game logic on-chain, which is slow and expensive. <KKMark /> takes a
        different approach: the blockchain provides entropy and relay services, but game logic runs
        locally on each player's device. This gives you blockchain-grade fairness with traditional game
        performance. You get the best of both worlds without the gas fees or latency of on-chain
        execution.
      </>
    ),
  },
  {
    question: 'Is this production-ready?',
    answer: `The current build is a hackathon prototype demonstrating the core concepts. While the primitives work and have been tested, there's more work needed for production deployment: security audits, performance optimization, better error handling, and more comprehensive documentation. The foundation is solid, but consider this an alpha/proof-of-concept for now.`,
  },
]

function FAQItem({ faq, index }: { faq: typeof faqs[0]; index: number }) {
  const [isOpen, setIsOpen] = useState(false)

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      whileInView={{ opacity: 1, y: 0 }}
      viewport={{ once: true }}
      transition={{ delay: index * 0.05 }}
      className="border-b border-border/50 last:border-0"
    >
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="w-full py-6 flex items-start justify-between gap-4 text-left group"
      >
        <span className="text-lg font-medium text-foreground group-hover:text-primary transition-colors">
          {faq.question}
        </span>
        <motion.div
          animate={{ rotate: isOpen ? 180 : 0 }}
          transition={{ duration: 0.2 }}
          className="flex-shrink-0 mt-1"
        >
          <ChevronDown className={cn(
            'w-5 h-5 transition-colors',
            isOpen ? 'text-primary' : 'text-muted-foreground'
          )} />
        </motion.div>
      </button>

      <AnimatePresence initial={false}>
        {isOpen && (
          <motion.div
            initial={{ height: 0, opacity: 0 }}
            animate={{ height: 'auto', opacity: 1 }}
            exit={{ height: 0, opacity: 0 }}
            transition={{ duration: 0.3 }}
            className="overflow-hidden"
          >
            <p className="pb-6 text-muted-foreground leading-relaxed">
              {faq.answer}
            </p>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  )
}

export function FAQSection() {
  return (
    <section id="faq" className="section relative overflow-hidden">
      {/* Background */}
      <div className="absolute inset-0 bg-gradient-to-b from-background via-card/20 to-background" />

      <div className="relative z-10 container mx-auto px-4 sm:px-6 lg:px-8">
        <ScrollReveal className="text-center mb-12">
          <div className="inline-flex items-center justify-center w-16 h-16 rounded-2xl bg-primary/10 border border-primary/30 mb-6">
            <HelpCircle className="w-8 h-8 text-primary" />
          </div>
          <h2 className="section-title mb-4">
            Frequently Asked <span className="gradient-text">Questions</span>
          </h2>
          <p className="section-subtitle mx-auto">
            Common questions about <KKMark />, how it works, and what you can build with it.
          </p>
        </ScrollReveal>

        <div className="max-w-3xl mx-auto">
          <div className="glass rounded-2xl p-6 lg:p-8 border border-border/50">
            {faqs.map((faq, index) => (
              <FAQItem key={index} faq={faq} index={index} />
            ))}
          </div>
        </div>

        {/* Still have questions? */}
        <ScrollReveal delay={0.2} className="mt-12 text-center">
          <p className="text-muted-foreground">
            Still have questions?{' '}
            <a href="mailto:peavey2787@yahoo.com" className="text-primary hover:underline">
              Reach out directly
            </a>{' '}
            or{' '}
            <a href="/docs" className="text-primary hover:underline">
              check the docs
            </a>
            .
          </p>
        </ScrollReveal>
      </div>
    </section>
  )
}
