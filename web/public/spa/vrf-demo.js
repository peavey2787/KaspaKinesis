var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "node_modules/react/cjs/react.production.js"(exports) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    __name(getIteratorFn, "getIteratorFn");
    var ReactNoopUpdateQueue = {
      isMounted: /* @__PURE__ */ __name(function() {
        return false;
      }, "isMounted"),
      enqueueForceUpdate: /* @__PURE__ */ __name(function() {
      }, "enqueueForceUpdate"),
      enqueueReplaceState: /* @__PURE__ */ __name(function() {
      }, "enqueueReplaceState"),
      enqueueSetState: /* @__PURE__ */ __name(function() {
      }, "enqueueSetState")
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component3(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    __name(Component3, "Component");
    Component3.prototype.isReactComponent = {};
    Component3.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component3.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    __name(ComponentDummy, "ComponentDummy");
    ComponentDummy.prototype = Component3.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    __name(PureComponent, "PureComponent");
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component3.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop2() {
    }
    __name(noop2, "noop");
    var ReactSharedInternals = { H: null, A: null, T: null, S: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    __name(ReactElement, "ReactElement");
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    __name(cloneAndReplaceKey, "cloneAndReplaceKey");
    function isValidElement2(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    __name(isValidElement2, "isValidElement");
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    __name(escape, "escape");
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    __name(getElementKey, "getElementKey");
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    __name(resolveThenable, "resolveThenable");
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement2(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    __name(mapIntoArray, "mapIntoArray");
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    __name(mapChildren, "mapChildren");
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    __name(lazyInitializer, "lazyInitializer");
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    var Children2 = {
      map: mapChildren,
      forEach: /* @__PURE__ */ __name(function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      }, "forEach"),
      count: /* @__PURE__ */ __name(function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      }, "count"),
      toArray: /* @__PURE__ */ __name(function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }, "toArray"),
      only: /* @__PURE__ */ __name(function(children) {
        if (!isValidElement2(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }, "only")
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = Children2;
    exports.Component = Component3;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = {
      __proto__: null,
      c: /* @__PURE__ */ __name(function(size) {
        return ReactSharedInternals.H.useMemoCache(size);
      }, "c")
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, props);
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports.isValidElement = isValidElement2;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop2, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    exports.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init2) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init2);
    };
    exports.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_production();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/scheduler/cjs/scheduler.production.js
var require_scheduler_production = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
    "use strict";
    function push(heap2, node) {
      var index = heap2.length;
      heap2.push(node);
      a: for (; 0 < index; ) {
        var parentIndex = index - 1 >>> 1, parent = heap2[parentIndex];
        if (0 < compare(parent, node))
          heap2[parentIndex] = node, heap2[index] = parent, index = parentIndex;
        else break a;
      }
    }
    __name(push, "push");
    function peek(heap2) {
      return 0 === heap2.length ? null : heap2[0];
    }
    __name(peek, "peek");
    function pop(heap2) {
      if (0 === heap2.length) return null;
      var first = heap2[0], last = heap2.pop();
      if (last !== first) {
        heap2[0] = last;
        a: for (var index = 0, length = heap2.length, halfLength = length >>> 1; index < halfLength; ) {
          var leftIndex = 2 * (index + 1) - 1, left = heap2[leftIndex], rightIndex = leftIndex + 1, right = heap2[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap2[index] = right, heap2[rightIndex] = last, index = rightIndex) : (heap2[index] = left, heap2[leftIndex] = last, index = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap2[index] = right, heap2[rightIndex] = last, index = rightIndex;
          else break a;
        }
      }
      return first;
    }
    __name(pop, "pop");
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    __name(compare, "compare");
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var localPerformance;
    var localDate;
    var initialTime;
    var taskQueue = [];
    var timerQueue = [];
    var taskIdCounter = 1;
    var currentTask = null;
    var currentPriorityLevel = 3;
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    var needsPaint = false;
    var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
    var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
    var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    __name(advanceTimers, "advanceTimers");
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    __name(handleTimeout, "handleTimeout");
    var isMessageLoopRunning = false;
    var taskTimeoutID = -1;
    var frameInterval = 5;
    var startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    __name(shouldYieldToHost, "shouldYieldToHost");
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    __name(performWorkUntilDeadline, "performWorkUntilDeadline");
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        localSetImmediate(performWorkUntilDeadline);
      }, "schedulePerformWorkUntilDeadline");
    else if ("undefined" !== typeof MessageChannel) {
      channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        port.postMessage(null);
      }, "schedulePerformWorkUntilDeadline");
    } else
      schedulePerformWorkUntilDeadline = /* @__PURE__ */ __name(function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      }, "schedulePerformWorkUntilDeadline");
    var channel;
    var port;
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    __name(requestHostTimeout, "requestHostTimeout");
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_scheduler_production();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom.production.js
var require_react_dom_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
    "use strict";
    var React6 = require_react();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    __name(formatProdErrorMessage, "formatProdErrorMessage");
    function noop2() {
    }
    __name(noop2, "noop");
    var Internals = {
      d: {
        f: noop2,
        r: /* @__PURE__ */ __name(function() {
          throw Error(formatProdErrorMessage(522));
        }, "r"),
        D: noop2,
        C: noop2,
        L: noop2,
        m: noop2,
        X: noop2,
        S: noop2,
        M: noop2
      },
      p: 0,
      findDOMNode: null
    };
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    __name(createPortal$1, "createPortal$1");
    var ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    __name(getCrossOriginStringAs, "getCrossOriginStringAs");
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    exports.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    __name(checkDCE, "checkDCE");
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_production();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-client.production.js
var require_react_dom_client_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
    "use strict";
    var Scheduler = require_scheduler();
    var React6 = require_react();
    var ReactDOM = require_react_dom();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    __name(formatProdErrorMessage, "formatProdErrorMessage");
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    __name(isValidContainer, "isValidContainer");
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    __name(getNearestMountedFiber, "getNearestMountedFiber");
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    __name(getSuspenseInstanceFromFiber, "getSuspenseInstanceFromFiber");
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    __name(getActivityInstanceFromFiber, "getActivityInstanceFromFiber");
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    __name(assertIsMounted, "assertIsMounted");
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b.return) a = parentA, b = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    __name(findCurrentFiberUsingSlowPath, "findCurrentFiberUsingSlowPath");
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    __name(findCurrentHostFiberImpl, "findCurrentHostFiberImpl");
    var assign = Object.assign;
    var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    __name(getIteratorFn, "getIteratorFn");
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    __name(getComponentNameFromType, "getComponentNameFromType");
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = React6.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    };
    var valueStack = [];
    var index = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    __name(createCursor, "createCursor");
    function pop(cursor) {
      0 > index || (cursor.current = valueStack[index], valueStack[index] = null, index--);
    }
    __name(pop, "pop");
    function push(cursor, value) {
      index++;
      valueStack[index] = cursor.current;
      cursor.current = value;
    }
    __name(push, "push");
    var contextStackCursor = createCursor(null);
    var contextFiberStackCursor = createCursor(null);
    var rootInstanceStackCursor = createCursor(null);
    var hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    __name(pushHostContainer, "pushHostContainer");
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    __name(popHostContainer, "popHostContainer");
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    __name(pushHostContext, "pushHostContext");
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    __name(popHostContext, "popHostContext");
    var prefix;
    var suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name + suffix;
    }
    __name(describeBuiltInComponentFrame, "describeBuiltInComponentFrame");
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: /* @__PURE__ */ __name(function() {
            try {
              if (construct) {
                var Fake = /* @__PURE__ */ __name(function() {
                  throw Error();
                }, "Fake");
                Object.defineProperty(Fake.prototype, "props", {
                  set: /* @__PURE__ */ __name(function() {
                    throw Error();
                  }, "set")
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }, "DetermineComponentFrameRoot")
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame2 = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame2.includes("<anonymous>") && (frame2 = frame2.replace("<anonymous>", fn.displayName));
                    return frame2;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    __name(describeNativeComponentFrame, "describeNativeComponentFrame");
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    __name(describeFiber, "describeFiber");
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do
          info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    __name(getStackByFiberInDevAndProd, "getStackByFiberInDevAndProd");
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
    var cancelCallback$1 = Scheduler.unstable_cancelCallback;
    var shouldYield = Scheduler.unstable_shouldYield;
    var requestPaint = Scheduler.unstable_requestPaint;
    var now2 = Scheduler.unstable_now;
    var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
    var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
    var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
    var NormalPriority$1 = Scheduler.unstable_NormalPriority;
    var LowPriority = Scheduler.unstable_LowPriority;
    var IdlePriority = Scheduler.unstable_IdlePriority;
    var log$1 = Scheduler.log;
    var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
    var rendererID = null;
    var injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    __name(setIsStrictModeForDevtools, "setIsStrictModeForDevtools");
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
    var log14 = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log14(x) / LN2 | 0) | 0;
    }
    __name(clz32Fallback, "clz32Fallback");
    var nextTransitionUpdateLane = 256;
    var nextTransitionDeferredLane = 262144;
    var nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    __name(getHighestPriorityLanes, "getHighestPriorityLanes");
    function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root3.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
      root3 = root3.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    __name(getNextLanes, "getNextLanes");
    function checkIfRootIsPrerendering(root3, renderLanes2) {
      return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
    }
    __name(checkIfRootIsPrerendering, "checkIfRootIsPrerendering");
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    __name(computeExpirationTime, "computeExpirationTime");
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    __name(claimNextRetryLane, "claimNextRetryLane");
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    __name(createLaneMap, "createLaneMap");
    function markRootUpdated$1(root3, updateLane) {
      root3.pendingLanes |= updateLane;
      268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
    }
    __name(markRootUpdated$1, "markRootUpdated$1");
    function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root3.pendingLanes;
      root3.pendingLanes = remainingLanes;
      root3.suspendedLanes = 0;
      root3.pingedLanes = 0;
      root3.warmLanes = 0;
      root3.expiredLanes &= remainingLanes;
      root3.entangledLanes &= remainingLanes;
      root3.errorRecoveryDisabledLanes &= remainingLanes;
      root3.shellSuspendCounter = 0;
      var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    __name(markRootFinished, "markRootFinished");
    function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
      root3.pendingLanes |= spawnedLane;
      root3.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root3.entangledLanes |= spawnedLane;
      root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    __name(markSpawnedDeferredLane, "markSpawnedDeferredLane");
    function markRootEntangled(root3, entangledLanes) {
      var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
      for (root3 = root3.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root3[index$8] & entangledLanes && (root3[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    __name(markRootEntangled, "markRootEntangled");
    function getBumpedLaneForHydration(root3, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root3.suspendedLanes | renderLanes2)) ? 0 : renderLane;
    }
    __name(getBumpedLaneForHydration, "getBumpedLaneForHydration");
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    __name(getBumpedLaneForHydrationByLane, "getBumpedLaneForHydrationByLane");
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    __name(lanesToEventPriority, "lanesToEventPriority");
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    __name(resolveUpdatePriority, "resolveUpdatePriority");
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    __name(runWithPriority, "runWithPriority");
    var randomKey = Math.random().toString(36).slice(2);
    var internalInstanceKey = "__reactFiber$" + randomKey;
    var internalPropsKey = "__reactProps$" + randomKey;
    var internalContainerInstanceKey = "__reactContainer$" + randomKey;
    var internalEventHandlersKey = "__reactEvents$" + randomKey;
    var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
    var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
    var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
    var internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    __name(detachDeletedInstance, "detachDeletedInstance");
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    __name(getClosestInstanceFromNode, "getClosestInstanceFromNode");
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node;
      }
      return null;
    }
    __name(getInstanceFromNode, "getInstanceFromNode");
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    __name(getNodeFromInstance, "getNodeFromInstance");
    function getResourcesFromRoot(root3) {
      var resources = root3[internalRootNodeResourcesKey];
      resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
      return resources;
    }
    __name(getResourcesFromRoot, "getResourcesFromRoot");
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    __name(markNodeAsHoistable, "markNodeAsHoistable");
    var allNativeEvents = /* @__PURE__ */ new Set();
    var registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    __name(registerTwoPhaseEvent, "registerTwoPhaseEvent");
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    __name(registerDirectEvent, "registerDirectEvent");
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    );
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    __name(isAttributeNameSafe, "isAttributeNameSafe");
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node.removeAttribute(name);
                return;
              }
          }
          node.setAttribute(name, "" + value);
        }
    }
    __name(setValueForAttribute, "setValueForAttribute");
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttribute(name, "" + value);
      }
    }
    __name(setValueForKnownAttribute, "setValueForKnownAttribute");
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    __name(setValueForNamespacedAttribute, "setValueForNamespacedAttribute");
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    __name(getToStringValue, "getToStringValue");
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    __name(isCheckable, "isCheckable");
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      );
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: /* @__PURE__ */ __name(function() {
            return get.call(this);
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            currentValue = "" + value;
            set.call(this, value);
          }, "set")
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: /* @__PURE__ */ __name(function() {
            return currentValue;
          }, "getValue"),
          setValue: /* @__PURE__ */ __name(function(value) {
            currentValue = "" + value;
          }, "setValue"),
          stopTracking: /* @__PURE__ */ __name(function() {
            node._valueTracker = null;
            delete node[valueField];
          }, "stopTracking")
        };
      }
    }
    __name(trackValueOnNode, "trackValueOnNode");
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(
          node,
          valueField,
          "" + node[valueField]
        );
      }
    }
    __name(track, "track");
    function updateValueIfChanged(node) {
      if (!node) return false;
      var tracker = node._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    __name(updateValueIfChanged, "updateValueIfChanged");
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    __name(getActiveElement, "getActiveElement");
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    __name(escapeSelectorAttributeValueInsideDoubleQuotes, "escapeSelectorAttributeValueInsideDoubleQuotes");
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    __name(updateInput, "updateInput");
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
          track(element);
          return;
        }
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      track(element);
    }
    __name(initInput, "initInput");
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    __name(setDefaultValue, "setDefaultValue");
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0; propValue < node.length; propValue++)
          i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = true;
            setDefaultSelected && (node[i].defaultSelected = true);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    __name(updateOptions, "updateOptions");
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    __name(updateTextarea, "updateTextarea");
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
      track(element);
    }
    __name(initTextarea, "initTextarea");
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    __name(setTextContent, "setTextContent");
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    __name(setValueForStyle, "setValueForStyle");
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node = node.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
    }
    __name(setValueForStyles, "setValueForStyles");
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    __name(isCustomElement, "isCustomElement");
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]);
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    __name(sanitizeURL, "sanitizeURL");
    function noop$1() {
    }
    __name(noop$1, "noop$1");
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    __name(getEventTarget, "getEventTarget");
    var restoreTarget = null;
    var restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    __name(restoreStateOfTarget, "restoreStateOfTarget");
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
    }
    __name(batchedUpdates$1, "batchedUpdates$1");
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    __name(getListener, "getListener");
    var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    var passiveBrowserEventsSupported = false;
    if (canUseDOM)
      try {
        options = {};
        Object.defineProperty(options, "passive", {
          get: /* @__PURE__ */ __name(function() {
            passiveBrowserEventsSupported = true;
          }, "get")
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var options;
    var root2 = null;
    var startText = null;
    var fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    __name(getData, "getData");
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    __name(getEventCharCode, "getEventCharCode");
    function functionThatReturnsTrue() {
      return true;
    }
    __name(functionThatReturnsTrue, "functionThatReturnsTrue");
    function functionThatReturnsFalse() {
      return false;
    }
    __name(functionThatReturnsFalse, "functionThatReturnsFalse");
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      __name(SyntheticBaseEvent, "SyntheticBaseEvent");
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: /* @__PURE__ */ __name(function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        }, "preventDefault"),
        stopPropagation: /* @__PURE__ */ __name(function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        }, "stopPropagation"),
        persist: /* @__PURE__ */ __name(function() {
        }, "persist"),
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    __name(createSyntheticEvent, "createSyntheticEvent");
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: /* @__PURE__ */ __name(function(event) {
        return event.timeStamp || Date.now();
      }, "timeStamp"),
      defaultPrevented: 0,
      isTrusted: 0
    };
    var SyntheticEvent = createSyntheticEvent(EventInterface);
    var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
    var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
    var lastMovementX;
    var lastMovementY;
    var lastMouseEvent;
    var MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: /* @__PURE__ */ __name(function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      }, "relatedTarget"),
      movementX: /* @__PURE__ */ __name(function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      }, "movementX"),
      movementY: /* @__PURE__ */ __name(function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }, "movementY")
    });
    var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
    var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
    var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
    var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
    var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
    var AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
    var ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: /* @__PURE__ */ __name(function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }, "clipboardData")
    });
    var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
    var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
    var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
    var normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    __name(modifierStateGetter, "modifierStateGetter");
    function getEventModifierState() {
      return modifierStateGetter;
    }
    __name(getEventModifierState, "getEventModifierState");
    var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: /* @__PURE__ */ __name(function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      }, "key"),
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: /* @__PURE__ */ __name(function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      }, "charCode"),
      keyCode: /* @__PURE__ */ __name(function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }, "keyCode"),
      which: /* @__PURE__ */ __name(function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }, "which")
    });
    var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
    var PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    });
    var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
    var TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    });
    var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
    var TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
    var WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: /* @__PURE__ */ __name(function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      }, "deltaX"),
      deltaY: /* @__PURE__ */ __name(function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      }, "deltaY"),
      deltaZ: 0,
      deltaMode: 0
    });
    var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
    var ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    });
    var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
    var END_KEYCODES = [9, 13, 27, 32];
    var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
    var documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
    var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
    var SPACEBAR_CHAR = String.fromCharCode(32);
    var hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    __name(isFallbackCompositionEnd, "isFallbackCompositionEnd");
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    __name(getDataFromCustomEvent, "getDataFromCustomEvent");
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    __name(getNativeBeforeInputChars, "getNativeBeforeInputChars");
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    __name(getFallbackBeforeInputChars, "getFallbackBeforeInputChars");
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    __name(isTextInputElement, "isTextInputElement");
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    __name(createAndAccumulateChangeEvent, "createAndAccumulateChangeEvent");
    var activeElement$1 = null;
    var activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    __name(runEventInBatch, "runEventInBatch");
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    __name(getInstIfValueChanged, "getInstIfValueChanged");
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    __name(getTargetInstForChangeEvent, "getTargetInstForChangeEvent");
    var isInputEventSupported = false;
    if (canUseDOM) {
      if (canUseDOM) {
        isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
    }
    var JSCompiler_inline_result$jscomp$286;
    var isSupported$jscomp$inline_427;
    var element$jscomp$inline_428;
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    __name(stopWatchingForValueChange, "stopWatchingForValueChange");
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    __name(handlePropertyChange, "handlePropertyChange");
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    __name(handleEventsForInputEventPolyfill, "handleEventsForInputEventPolyfill");
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    __name(getTargetInstForInputEventPolyfill, "getTargetInstForInputEventPolyfill");
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    __name(getTargetInstForClickEvent, "getTargetInstForClickEvent");
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    __name(getTargetInstForInputOrChangeEvent, "getTargetInstForInputOrChangeEvent");
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    __name(is, "is");
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    __name(shallowEqual, "shallowEqual");
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    __name(getLeafNode, "getLeafNode");
    function getNodeForCharacterOffset(root3, offset) {
      var node = getLeafNode(root3);
      root3 = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root3 + node.textContent.length;
          if (root3 <= offset && nodeEnd >= offset)
            return { node, offset: offset - root3 };
          root3 = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    __name(getNodeForCharacterOffset, "getNodeForCharacterOffset");
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    __name(containsNode, "containsNode");
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    __name(getActiveElementDeep, "getActiveElementDeep");
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    __name(hasSelectionCapabilities, "hasSelectionCapabilities");
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
    var activeElement = null;
    var activeElementInst = null;
    var lastSelection = null;
    var mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    __name(constructSelectEvent, "constructSelectEvent");
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    __name(makePrefixMap, "makePrefixMap");
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    var prefixedEventNames = {};
    var style = {};
    canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    __name(getVendorPrefixedEventName, "getVendorPrefixedEventName");
    var ANIMATION_END = getVendorPrefixedEventName("animationend");
    var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
    var ANIMATION_START = getVendorPrefixedEventName("animationstart");
    var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
    var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
    var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
    var TRANSITION_END = getVendorPrefixedEventName("transitionend");
    var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
    var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    __name(registerSimpleEvent, "registerSimpleEvent");
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    var concurrentQueues = [];
    var concurrentQueuesIndex = 0;
    var concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    __name(finishQueueingConcurrentUpdates, "finishQueueingConcurrentUpdates");
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    __name(enqueueUpdate$1, "enqueueUpdate$1");
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    __name(enqueueConcurrentHookUpdate, "enqueueConcurrentHookUpdate");
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    __name(enqueueConcurrentRenderForLane, "enqueueConcurrentRenderForLane");
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    __name(markUpdateLaneFromFiberToRoot, "markUpdateLaneFromFiberToRoot");
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    __name(getRootForUpdatedFiber, "getRootForUpdatedFiber");
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    __name(FiberNode, "FiberNode");
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    __name(createFiberImplClass, "createFiberImplClass");
    function shouldConstruct(Component3) {
      Component3 = Component3.prototype;
      return !(!Component3 || !Component3.isReactComponent);
    }
    __name(shouldConstruct, "shouldConstruct");
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    __name(createWorkInProgress, "createWorkInProgress");
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    __name(resetWorkInProgress, "resetWorkInProgress");
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_TYPE:
            return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_LIST_TYPE:
            return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    __name(createFiberFromTypeAndProps, "createFiberFromTypeAndProps");
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    __name(createFiberFromFragment, "createFiberFromFragment");
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    __name(createFiberFromText, "createFiberFromText");
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    __name(createFiberFromDehydratedFragment, "createFiberFromDehydratedFragment");
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    __name(createFiberFromPortal, "createFiberFromPortal");
    var CapturedStacks = /* @__PURE__ */ new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    __name(createCapturedValueAtFiber, "createCapturedValueAtFiber");
    var forkStack = [];
    var forkStackIndex = 0;
    var treeForkProvider = null;
    var treeForkCount = 0;
    var idStack = [];
    var idStackIndex = 0;
    var treeContextProvider = null;
    var treeContextId = 1;
    var treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    __name(pushTreeFork, "pushTreeFork");
    function pushTreeId(workInProgress2, totalChildren, index2) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index2 += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    __name(pushTreeId, "pushTreeId");
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    __name(pushMaterializedTreeId, "pushMaterializedTreeId");
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    __name(popTreeContext, "popTreeContext");
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    __name(restoreSuspendedTreeContext, "restoreSuspendedTreeContext");
    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;
    var hydrationErrors = null;
    var rootOrSingletonContext = false;
    var HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    __name(throwOnHydrationMismatch, "throwOnHydrationMismatch");
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber, true);
    }
    __name(prepareToHydrateHostInstance, "prepareToHydrateHostInstance");
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    __name(popToNextHostParent, "popToNextHostParent");
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    __name(popHydrationState, "popHydrationState");
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    __name(resetHydrationState, "resetHydrationState");
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    __name(upgradeHydrationErrorsToRecoverable, "upgradeHydrationErrorsToRecoverable");
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    __name(queueHydrationError, "queueHydrationError");
    var valueCursor = createCursor(null);
    var currentlyRenderingFiber$1 = null;
    var lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    __name(pushProvider, "pushProvider");
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    __name(popProvider, "popProvider");
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    __name(scheduleContextWorkOnParentPath, "scheduleContextWorkOnParentPath");
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    __name(propagateContextChanges, "propagateContextChanges");
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    __name(propagateParentContextChanges, "propagateParentContextChanges");
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    __name(checkIfContextChanged, "checkIfContextChanged");
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    __name(prepareToReadContext, "prepareToReadContext");
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    __name(readContext, "readContext");
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    __name(readContextDuringReconciliation, "readContextDuringReconciliation");
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    __name(readContextForConsumer, "readContextForConsumer");
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: /* @__PURE__ */ __name(function(type, listener) {
          listeners.push(listener);
        }, "addEventListener")
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    };
    var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
    var NormalPriority = Scheduler.unstable_NormalPriority;
    var CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    __name(createCache, "createCache");
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    __name(releaseCache, "releaseCache");
    var currentEntangledListeners = null;
    var currentEntangledPendingCount = 0;
    var currentEntangledLane = 0;
    var currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: /* @__PURE__ */ __name(function(resolve) {
            entangledListeners.push(resolve);
          }, "then")
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    __name(entangleAsyncAction, "entangleAsyncAction");
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    __name(pingEngtangledActionScope, "pingEngtangledActionScope");
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: /* @__PURE__ */ __name(function(resolve) {
          listeners.push(resolve);
        }, "then")
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    __name(chainThenableValue, "chainThenableValue");
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now2();
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    __name(peekCacheFromPool, "peekCacheFromPool");
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    __name(pushTransition, "pushTransition");
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    __name(getSuspendedCache, "getSuspendedCache");
    var SuspenseException = Error(formatProdErrorMessage(460));
    var SuspenseyCommitException = Error(formatProdErrorMessage(474));
    var SuspenseActionException = Error(formatProdErrorMessage(542));
    var noopSuspenseyCommitThenable = { then: /* @__PURE__ */ __name(function() {
    }, "then") };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    __name(isThenableResolved, "isThenableResolved");
    function trackUsedThenable(thenableState2, thenable, index2) {
      index2 = thenableState2[index2];
      void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$1, noop$1), thenable = index2);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    __name(trackUsedThenable, "trackUsedThenable");
    function resolveLazy(lazyType) {
      try {
        var init2 = lazyType._init;
        return init2(lazyType._payload);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw suspendedThenable = x, SuspenseException;
        throw x;
      }
    }
    __name(resolveLazy, "resolveLazy");
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    __name(getSuspendedThenable, "getSuspendedThenable");
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    __name(checkIfUseWrappedInAsyncCatch, "checkIfUseWrappedInAsyncCatch");
    var thenableState$1 = null;
    var thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index2 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index2);
    }
    __name(unwrapThenable, "unwrapThenable");
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    __name(coerceRef, "coerceRef");
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    __name(throwOnInvalidObjectTypeImpl, "throwOnInvalidObjectTypeImpl");
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      __name(deleteChild, "deleteChild");
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      __name(deleteRemainingChildren, "deleteRemainingChildren");
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      __name(mapRemainingChildren, "mapRemainingChildren");
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      __name(useFiber, "useFiber");
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      __name(placeChild, "placeChild");
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      __name(placeSingleChild, "placeSingleChild");
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      __name(updateTextNode, "updateTextNode");
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      __name(updateElement, "updateElement");
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      __name(updatePortal, "updatePortal");
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      __name(updateFragment, "updateFragment");
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      __name(createChild, "createChild");
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      __name(updateSlot, "updateSlot");
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      __name(updateFromMap, "updateFromMap");
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      __name(reconcileChildrenArray, "reconcileChildrenArray");
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      __name(reconcileChildrenIterator, "reconcileChildrenIterator");
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      __name(reconcileChildFibersImpl, "reconcileChildFibersImpl");
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    __name(createChildReconciler, "createChildReconciler");
    var reconcileChildFibers = createChildReconciler(true);
    var mountChildFibers = createChildReconciler(false);
    var hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    __name(initializeUpdateQueue, "initializeUpdateQueue");
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    __name(cloneUpdateQueue, "cloneUpdateQueue");
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    __name(createUpdate, "createUpdate");
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    __name(enqueueUpdate, "enqueueUpdate");
    function entangleTransitions(root3, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    __name(entangleTransitions, "entangleTransitions");
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    __name(enqueueCapturedUpdate, "enqueueCapturedUpdate");
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    __name(suspendIfUpdateReadFromEntangledAsyncAction, "suspendIfUpdateReadFromEntangledAsyncAction");
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    __name(processUpdateQueue, "processUpdateQueue");
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    __name(callCallback, "callCallback");
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    __name(commitCallbacks, "commitCallbacks");
    var currentTreeHiddenStackCursor = createCursor(null);
    var prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    __name(pushHiddenContext, "pushHiddenContext");
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    __name(reuseHiddenContextOnStack, "reuseHiddenContextOnStack");
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    __name(popHiddenContext, "popHiddenContext");
    var suspenseHandlerStackCursor = createCursor(null);
    var shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    __name(pushPrimaryTreeSuspenseHandler, "pushPrimaryTreeSuspenseHandler");
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    __name(pushDehydratedActivitySuspenseHandler, "pushDehydratedActivitySuspenseHandler");
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
    }
    __name(pushOffscreenSuspenseHandler, "pushOffscreenSuspenseHandler");
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    __name(reuseSuspenseHandlerOnStack, "reuseSuspenseHandlerOnStack");
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    __name(popSuspenseHandler, "popSuspenseHandler");
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    __name(findFirstSuspended, "findFirstSuspended");
    var renderLanes = 0;
    var currentlyRenderingFiber = null;
    var currentHook = null;
    var workInProgressHook = null;
    var didScheduleRenderPhaseUpdate = false;
    var didScheduleRenderPhaseUpdateDuringThisPass = false;
    var shouldDoubleInvokeUserFnsInHooksDEV = false;
    var localIdCounter = 0;
    var thenableIndexCounter = 0;
    var thenableState = null;
    var globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    __name(throwInvalidHookError, "throwInvalidHookError");
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
      return true;
    }
    __name(areHookInputsEqual, "areHookInputsEqual");
    function renderWithHooks(current, workInProgress2, Component3, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component3(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component3,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    __name(renderWithHooks, "renderWithHooks");
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    __name(finishRenderingHooks, "finishRenderingHooks");
    function renderWithHooksAgain(workInProgress2, Component3, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component3(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    __name(renderWithHooksAgain, "renderWithHooksAgain");
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    __name(TransitionAwareHostComponent, "TransitionAwareHostComponent");
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    __name(checkDidRenderIdHook, "checkDidRenderIdHook");
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    __name(bailoutHooks, "bailoutHooks");
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    __name(resetHooksOnUnwind, "resetHooksOnUnwind");
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    __name(mountWorkInProgressHook, "mountWorkInProgressHook");
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    __name(updateWorkInProgressHook, "updateWorkInProgressHook");
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    __name(createFunctionComponentUpdateQueue, "createFunctionComponentUpdateQueue");
    function useThenable(thenable) {
      var index2 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index2);
      index2 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    __name(useThenable, "useThenable");
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    __name(use, "use");
    function useMemoCache(size) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    __name(useMemoCache, "useMemoCache");
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    __name(basicStateReducer, "basicStateReducer");
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    __name(updateReducer, "updateReducer");
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    __name(updateReducerImpl, "updateReducerImpl");
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    __name(rerenderReducer, "rerenderReducer");
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    __name(updateSyncExternalStore, "updateSyncExternalStore");
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    __name(pushStoreConsistencyCheck, "pushStoreConsistencyCheck");
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    __name(updateStoreInstance, "updateStoreInstance");
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    __name(subscribeToStore, "subscribeToStore");
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    __name(checkIfSnapshotChanged, "checkIfSnapshotChanged");
    function forceStoreRerender(fiber) {
      var root3 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
    }
    __name(forceStoreRerender, "forceStoreRerender");
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    __name(mountStateImpl, "mountStateImpl");
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    __name(updateOptimisticImpl, "updateOptimisticImpl");
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: /* @__PURE__ */ __name(function(listener) {
            actionNode.listeners.push(listener);
          }, "then")
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    __name(dispatchActionState, "dispatchActionState");
    function runActionStateAction(actionQueue, node) {
      var action = node.action, payload = node.payload, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
        } catch (error$66) {
          onActionError(actionQueue, node, error$66);
        }
    }
    __name(runActionStateAction, "runActionStateAction");
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node, error);
        }
      ) : onActionSuccess(actionQueue, node, returnValue);
    }
    __name(handleActionReturnValue, "handleActionReturnValue");
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    __name(onActionSuccess, "onActionSuccess");
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    __name(onActionError, "onActionError");
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    __name(notifyActionListeners, "notifyActionListeners");
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    __name(actionStateReducer, "actionStateReducer");
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    __name(mountActionState, "mountActionState");
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    __name(updateActionState, "updateActionState");
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        { destroy: void 0 },
        actionStateActionEffect.bind(null, actionQueue, action),
        null
      ));
      return [state, dispatch, stateHook];
    }
    __name(updateActionStateImpl, "updateActionStateImpl");
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    __name(actionStateActionEffect, "actionStateActionEffect");
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    __name(rerenderActionState, "rerenderActionState");
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    __name(pushSimpleEffect, "pushSimpleEffect");
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    __name(updateRef, "updateRef");
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    __name(mountEffectImpl, "mountEffectImpl");
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      ));
    }
    __name(updateEffectImpl, "updateEffectImpl");
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    __name(mountEffect, "mountEffect");
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    __name(updateEffect, "updateEffect");
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    __name(useEffectEventImpl, "useEffectEventImpl");
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
    __name(updateEvent, "updateEvent");
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    __name(updateInsertionEffect, "updateInsertionEffect");
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    __name(updateLayoutEffect, "updateLayoutEffect");
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    __name(imperativeHandleEffect, "imperativeHandleEffect");
    function updateImperativeHandle(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    __name(updateImperativeHandle, "updateImperativeHandle");
    function mountDebugValue() {
    }
    __name(mountDebugValue, "mountDebugValue");
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    __name(updateCallback, "updateCallback");
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    __name(updateMemo, "updateMemo");
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    __name(mountDeferredValueImpl, "mountDeferredValueImpl");
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    __name(updateDeferredValueImpl, "updateDeferredValueImpl");
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: /* @__PURE__ */ __name(function() {
          }, "then"), status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    }
    __name(startTransition, "startTransition");
    function noop2() {
    }
    __name(noop2, "noop");
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop2 : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    __name(startHostTransition, "startHostTransition");
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    __name(ensureFormComponentIsStateful, "ensureFormComponentIsStateful");
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane()
      );
    }
    __name(requestFormReset$1, "requestFormReset$1");
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    __name(useHostTransitionStatus, "useHostTransitionStatus");
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    __name(updateId, "updateId");
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    __name(updateRefresh, "updateRefresh");
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    __name(refreshCache, "refreshCache");
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    __name(dispatchReducerAction, "dispatchReducerAction");
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    __name(dispatchSetState, "dispatchSetState");
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    __name(dispatchSetStateInternal, "dispatchSetStateInternal");
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    __name(dispatchOptimisticSetState, "dispatchOptimisticSetState");
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    __name(isRenderPhaseUpdate, "isRenderPhaseUpdate");
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    __name(enqueueRenderPhaseUpdate, "enqueueRenderPhaseUpdate");
    function entangleTransitionUpdate(root3, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root3.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root3, lane);
      }
    }
    __name(entangleTransitionUpdate, "entangleTransitionUpdate");
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: /* @__PURE__ */ __name(function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      }, "useCallback"),
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: /* @__PURE__ */ __name(function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      }, "useImperativeHandle"),
      useLayoutEffect: /* @__PURE__ */ __name(function(create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      }, "useLayoutEffect"),
      useInsertionEffect: /* @__PURE__ */ __name(function(create, deps) {
        mountEffectImpl(4, 2, create, deps);
      }, "useInsertionEffect"),
      useMemo: /* @__PURE__ */ __name(function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      }, "useMemo"),
      useReducer: /* @__PURE__ */ __name(function(reducer, initialArg, init2) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init2) {
          var initialState = init2(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init2(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      }, "useReducer"),
      useRef: /* @__PURE__ */ __name(function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      }, "useRef"),
      useState: /* @__PURE__ */ __name(function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      }, "useState"),
      useDebugValue: mountDebugValue,
      useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      }, "useDeferredValue"),
      useTransition: /* @__PURE__ */ __name(function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      }, "useTransition"),
      useSyncExternalStore: /* @__PURE__ */ __name(function(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
          subscribe
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      }, "useSyncExternalStore"),
      useId: /* @__PURE__ */ __name(function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "_";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      }, "useId"),
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: /* @__PURE__ */ __name(function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      }, "useOptimistic"),
      useMemoCache,
      useCacheRefresh: /* @__PURE__ */ __name(function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      }, "useCacheRefresh"),
      useEffectEvent: /* @__PURE__ */ __name(function(callback) {
        var hook = mountWorkInProgressHook(), ref = { impl: callback };
        hook.memoizedState = ref;
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }, "useEffectEvent")
    };
    var HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: /* @__PURE__ */ __name(function() {
        return updateReducer(basicStateReducer);
      }, "useState"),
      useDebugValue: mountDebugValue,
      useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }, "useDeferredValue"),
      useTransition: /* @__PURE__ */ __name(function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }, "useTransition"),
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: /* @__PURE__ */ __name(function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      }, "useOptimistic"),
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: /* @__PURE__ */ __name(function() {
        return rerenderReducer(basicStateReducer);
      }, "useState"),
      useDebugValue: mountDebugValue,
      useDeferredValue: /* @__PURE__ */ __name(function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      }, "useDeferredValue"),
      useTransition: /* @__PURE__ */ __name(function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      }, "useTransition"),
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: /* @__PURE__ */ __name(function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      }, "useOptimistic"),
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    __name(applyDerivedStateFromProps, "applyDerivedStateFromProps");
    var classComponentUpdater = {
      enqueueSetState: /* @__PURE__ */ __name(function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      }, "enqueueSetState"),
      enqueueReplaceState: /* @__PURE__ */ __name(function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      }, "enqueueReplaceState"),
      enqueueForceUpdate: /* @__PURE__ */ __name(function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }, "enqueueForceUpdate")
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    __name(checkShouldComponentUpdate, "checkShouldComponentUpdate");
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    __name(callComponentWillReceiveProps, "callComponentWillReceiveProps");
    function resolveClassComponentProps(Component3, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component3 = Component3.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var propName$73 in Component3)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component3[propName$73]);
      }
      return newProps;
    }
    __name(resolveClassComponentProps, "resolveClassComponentProps");
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    __name(defaultOnUncaughtError, "defaultOnUncaughtError");
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    __name(defaultOnCaughtError, "defaultOnCaughtError");
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    __name(defaultOnRecoverableError, "defaultOnRecoverableError");
    function logUncaughtError(root3, errorInfo) {
      try {
        var onUncaughtError = root3.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    __name(logUncaughtError, "logUncaughtError");
    function logCaughtError(root3, boundary, errorInfo) {
      try {
        var onCaughtError = root3.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    __name(logCaughtError, "logCaughtError");
    function createRootErrorUpdate(root3, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root3, errorInfo);
      };
      return lane;
    }
    __name(createRootErrorUpdate, "createRootErrorUpdate");
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    __name(createClassErrorUpdate, "createClassErrorUpdate");
    function initializeClassErrorUpdate(update, root3, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root3, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    __name(initializeClassErrorUpdate, "initializeClassErrorUpdate");
    function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root3, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root3.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root3,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    __name(throwException, "throwException");
    var SelectiveHydrationException = Error(formatProdErrorMessage(461));
    var didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    __name(reconcileChildren, "reconcileChildren");
    function updateForwardRef(current, workInProgress2, Component3, nextProps, renderLanes2) {
      Component3 = Component3.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component3,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    __name(updateForwardRef, "updateForwardRef");
    function updateMemoComponent(current, workInProgress2, Component3, nextProps, renderLanes2) {
      if (null === current) {
        var type = Component3.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component3.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component3.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component3 = Component3.compare;
        Component3 = null !== Component3 ? Component3 : shallowEqual;
        if (Component3(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    __name(updateMemoComponent, "updateMemoComponent");
    function updateSimpleMemoComponent(current, workInProgress2, Component3, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component3,
        nextProps,
        renderLanes2
      );
    }
    __name(updateSimpleMemoComponent, "updateSimpleMemoComponent");
    function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextProps = workInProgress2.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            prevState,
            renderLanes2,
            nextProps
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2,
            nextProps
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    __name(updateOffscreenComponent, "updateOffscreenComponent");
    function bailoutOffscreenComponent(current, workInProgress2) {
      null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    __name(bailoutOffscreenComponent, "bailoutOffscreenComponent");
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    __name(deferHiddenOffscreenComponent, "deferHiddenOffscreenComponent");
    function mountActivityChildren(workInProgress2, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress2.mode
      );
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    __name(mountActivityChildren, "mountActivityChildren");
    function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current;
    }
    __name(retryActivityComponentWithoutHydrating, "retryActivityComponentWithoutHydrating");
    function updateActivityComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
      workInProgress2.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (null !== workInProgress2.memoizedState)
            workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else throw Error(formatProdErrorMessage(558));
        else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
            throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children
      });
      current.ref = workInProgress2.ref;
      workInProgress2.child = current;
      current.return = workInProgress2;
      return current;
    }
    __name(updateActivityComponent, "updateActivityComponent");
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    __name(markRef, "markRef");
    function updateFunctionComponent(current, workInProgress2, Component3, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component3 = renderWithHooks(
        current,
        workInProgress2,
        Component3,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component3, renderLanes2);
      return workInProgress2.child;
    }
    __name(updateFunctionComponent, "updateFunctionComponent");
    function replayFunctionComponent(current, workInProgress2, nextProps, Component3, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component3,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component3 = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component3 && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    __name(replayFunctionComponent, "replayFunctionComponent");
    function updateClassComponent(current, workInProgress2, Component3, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component3.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component3(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component3.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component3.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component3,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component3.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component3, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component3.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component3.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component3,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component3,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component3, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component3.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component3.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component3,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component3,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component3 = nextProps && "function" !== typeof Component3.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component3,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component3, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    __name(updateClassComponent, "updateClassComponent");
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    __name(mountHostRootWithoutHydrating, "mountHostRootWithoutHydrating");
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    __name(mountSuspenseOffscreenState, "mountSuspenseOffscreenState");
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    __name(getRemainingWorkInPrimaryTree, "getRemainingWorkInPrimaryTree");
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            showFallback
          ), nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
          JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
          digest,
          nextPrimaryChildren
        ) : (nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    __name(updateSuspenseComponent, "updateSuspenseComponent");
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    __name(mountSuspensePrimaryChildren, "mountSuspensePrimaryChildren");
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    __name(mountWorkInProgressOffscreenFiber, "mountWorkInProgressOffscreenFiber");
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    __name(retrySuspenseComponentWithoutHydrating, "retrySuspenseComponentWithoutHydrating");
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    __name(scheduleSuspenseWorkOnFiber, "scheduleSuspenseWorkOnFiber");
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    __name(initSuspenseListRenderState, "initSuspenseListRenderState");
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      nextProps = isHydrating ? treeForkCount : 0;
      if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode,
            nextProps
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode,
            nextProps
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress2,
            false,
            null,
            null,
            void 0,
            nextProps
          );
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    __name(updateSuspenseListComponent, "updateSuspenseListComponent");
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    __name(bailoutOnAlreadyFinishedWork, "bailoutOnAlreadyFinishedWork");
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    __name(checkScheduledUpdateOrContext, "checkScheduledUpdateOrContext");
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 31:
          if (null !== workInProgress2.memoizedState)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          var state$102 = workInProgress2.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state$102 || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    __name(attemptEarlyBailoutIfNoScheduledUpdate, "attemptEarlyBailoutIfNoScheduledUpdate");
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            var props = workInProgress2.pendingProps;
            current = resolveLazy(workInProgress2.elementType);
            workInProgress2.type = current;
            if ("function" === typeof current)
              shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              ));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
            props,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            props,
            $$typeof,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, props, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress2, CacheContext, props);
            props !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: props,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError($$typeof);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  props,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, props, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if ($$typeof = props = nextHydratableInstance)
              props = canHydrateInstance(
                props,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
            $$typeof || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          $$typeof = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = $$typeof);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, props, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            props,
            renderLanes2
          ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
        case 9:
          return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    __name(beginWork, "beginWork");
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    __name(markUpdate, "markUpdate");
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if (type = 0 !== (workInProgress2.mode & 32)) type = false;
      if (type) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else workInProgress2.flags &= -16777217;
    }
    __name(preloadInstanceAndSuspendIfNeeded, "preloadInstanceAndSuspendIfNeeded");
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    __name(preloadResourceAndSuspendIfNeeded, "preloadResourceAndSuspendIfNeeded");
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    __name(scheduleRetryEffect, "scheduleRetryEffect");
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
        }
    }
    __name(cutOffTailIfNeeded, "cutOffTailIfNeeded");
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
      else
        for (child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    __name(bubbleProperties, "bubbleProperties");
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
          null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            null,
            newProps,
            renderLanes2
          ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            current,
            newProps,
            renderLanes2
          ));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, nextResource);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script><\/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                        is: newProps.is
                      }) : ownerDocument.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress2) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress2.stateNode = nextResource;
              a: switch (setInitialProperties(nextResource, type, newProps), type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            workInProgress2.type,
            null === current ? null : current.memoizedProps,
            workInProgress2.pendingProps,
            renderLanes2
          );
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2, true);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress2);
            if (null !== renderLanes2) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress2.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              current = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
            if (!current) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if (0 !== (workInProgress2.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress2.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress2.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress2), null;
          type = 0 !== (workInProgress2.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail && now2() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current = findFirstSuspended(nextResource), null !== current) {
                if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now2() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (null !== newProps.tail)
            return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now2(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
              suspenseStackCursor,
              type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
            ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    __name(completeWork, "completeWork");
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (null !== workInProgress2.memoizedState) {
            popSuspenseHandler(workInProgress2);
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    __name(unwindWork, "unwindWork");
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    __name(unwindInterruptedWork, "unwindInterruptedWork");
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    __name(commitHookEffectListMount, "commitHookEffectListMount");
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    __name(commitHookEffectListUnmount, "commitHookEffectListUnmount");
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    __name(commitClassCallbacks, "commitClassCallbacks");
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    __name(safelyCallComponentWillUnmount, "safelyCallComponentWillUnmount");
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    __name(safelyAttachRef, "safelyAttachRef");
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref.current = null;
    }
    __name(safelyDetachRef, "safelyDetachRef");
    function commitHostMount(finishedWork) {
      var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    __name(commitHostMount, "commitHostMount");
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    __name(commitHostUpdate, "commitHostUpdate");
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    __name(isHostParent, "isHostParent");
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    __name(getHostSibling, "getHostSibling");
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    __name(insertOrAppendPlacementNodeIntoContainer, "insertOrAppendPlacementNodeIntoContainer");
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    __name(insertOrAppendPlacementNode, "insertOrAppendPlacementNode");
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    __name(commitHostSingletonAcquisition, "commitHostSingletonAcquisition");
    var offscreenSubtreeIsHidden = false;
    var offscreenSubtreeWasHidden = false;
    var needsFormReset = false;
    var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
    var nextEffect = null;
    function commitBeforeMutationEffects(root3, firstChild) {
      root3 = root3.containerInfo;
      eventsEnabled = _enabled2;
      root3 = getActiveElementDeep(root3);
      if (hasSelectionCapabilities(root3)) {
        if ("selectionStart" in root3)
          var JSCompiler_temp = {
            start: root3.selectionStart,
            end: root3.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root3, parentNode = null;
              b: for (; ; ) {
                for (var next; ; ) {
                  node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                  node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (; ; ) {
                  if (node === root3) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                  parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
      _enabled2 = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root3)
          root3.return = firstChild, nextEffect = root3;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root3 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (0 !== (root3 & 4) && (root3 = firstChild.updateQueue, root3 = null !== root3 ? root3.events : null, null !== root3))
                  for (JSCompiler_temp = 0; JSCompiler_temp < root3.length; JSCompiler_temp++)
                    anchorOffset = root3[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root3 & 1024) && null !== focusNode) {
                  root3 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset
                    );
                    root3 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root3;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root3 & 1024)) {
                  if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root3);
                  else if (1 === JSCompiler_temp)
                    switch (root3.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root3);
                        break;
                      default:
                        root3.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root3 = firstChild.sibling;
            if (null !== root3) {
              root3.return = firstChild.return;
              nextEffect = root3;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    __name(commitBeforeMutationEffects, "commitBeforeMutationEffects");
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    __name(commitLayoutEffectOnFiber, "commitLayoutEffectOnFiber");
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    __name(detachFiberAfterEffects, "detachFiberAfterEffects");
    var hostParent = null;
    var hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    __name(recursivelyTraverseDeletionEffects, "recursivelyTraverseDeletionEffects");
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    __name(commitDeletionEffectsOnFiber, "commitDeletionEffectsOnFiber");
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    __name(commitActivityHydrationCallbacks, "commitActivityHydrationCallbacks");
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    __name(commitSuspenseHydrationCallbacks, "commitSuspenseHydrationCallbacks");
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    __name(getRetryCache, "getRetryCache");
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    __name(attachSuspenseRetryListeners, "attachSuspenseRetryListeners");
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root3 = childToDelete.alternate;
          null !== root3 && (root3.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    __name(recursivelyTraverseMutationEffects, "recursivelyTraverseMutationEffects");
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root3) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root3.containerInfo);
          recursivelyTraverseMutationEffects(root3, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root3.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now2());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root3, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
              if (5 === root3.tag || 26 === root3.tag) {
                if (null === current) {
                  wasHidden = current = root3;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root3.tag) {
                if (null === current) {
                  wasHidden = root3;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                root3.child.return = root3;
                root3 = root3.child;
                continue;
              }
              if (root3 === finishedWork) break a;
              for (; null === root3.sibling; ) {
                if (null === root3.return || root3.return === finishedWork) break a;
                current === root3 && (current = null);
                root3 = root3.return;
              }
              current === root3 && (current = null);
              root3.sibling.return = root3.return;
              root3 = root3.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root3, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    __name(commitMutationEffectsOnFiber, "commitMutationEffectsOnFiber");
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    __name(commitReconciliationEffects, "commitReconciliationEffects");
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    __name(recursivelyResetForms, "recursivelyResetForms");
    function recursivelyTraverseLayoutEffects(root3, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    __name(recursivelyTraverseLayoutEffects, "recursivelyTraverseLayoutEffects");
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    __name(recursivelyTraverseDisappearLayoutEffects, "recursivelyTraverseDisappearLayoutEffects");
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    __name(recursivelyTraverseReappearLayoutEffects, "recursivelyTraverseReappearLayoutEffects");
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    __name(commitOffscreenPassiveMountEffects, "commitOffscreenPassiveMountEffects");
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    __name(commitCachePassiveMountEffect, "commitCachePassiveMountEffect");
    function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root3,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    __name(recursivelyTraversePassiveMountEffects, "recursivelyTraversePassiveMountEffects");
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id3 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id3,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id3 = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256) || false
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id3, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    __name(commitPassiveMountOnFiber, "commitPassiveMountOnFiber");
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    __name(recursivelyTraverseReconnectPassiveEffects, "recursivelyTraverseReconnectPassiveEffects");
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    __name(recursivelyTraverseAtomicPassiveEffects, "recursivelyTraverseAtomicPassiveEffects");
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ), parentFiber = parentFiber.sibling;
    }
    __name(recursivelyAccumulateSuspenseyCommit, "recursivelyAccumulateSuspenseyCommit");
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            suspendedState,
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    __name(accumulateSuspenseyCommitOnFiber, "accumulateSuspenseyCommitOnFiber");
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    __name(detachAlternateSiblings, "detachAlternateSiblings");
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    __name(recursivelyTraversePassiveUnmountEffects, "recursivelyTraversePassiveUnmountEffects");
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    __name(commitPassiveUnmountOnFiber, "commitPassiveUnmountOnFiber");
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i = deletions.stateNode;
            i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    __name(recursivelyTraverseDisconnectPassiveEffects, "recursivelyTraverseDisconnectPassiveEffects");
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) cache.return = fiber, nextEffect = cache;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling, returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    __name(commitPassiveUnmountEffectsInsideOfDeletedTree_begin, "commitPassiveUnmountEffectsInsideOfDeletedTree_begin");
    var DefaultAsyncDispatcher = {
      getCacheForType: /* @__PURE__ */ __name(function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      }, "getCacheForType"),
      cacheSignal: /* @__PURE__ */ __name(function() {
        return readContext(CacheContext).controller.signal;
      }, "cacheSignal")
    };
    var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
    var executionContext = 0;
    var workInProgressRoot = null;
    var workInProgress = null;
    var workInProgressRootRenderLanes = 0;
    var workInProgressSuspendedReason = 0;
    var workInProgressThrownValue = null;
    var workInProgressRootDidSkipSuspendedSiblings = false;
    var workInProgressRootIsPrerendering = false;
    var workInProgressRootDidAttachPingListener = false;
    var entangledRenderLanes = 0;
    var workInProgressRootExitStatus = 0;
    var workInProgressRootSkippedLanes = 0;
    var workInProgressRootInterleavedUpdatedLanes = 0;
    var workInProgressRootPingedLanes = 0;
    var workInProgressDeferredLane = 0;
    var workInProgressSuspendedRetryLanes = 0;
    var workInProgressRootConcurrentErrors = null;
    var workInProgressRootRecoverableErrors = null;
    var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    var globalMostRecentFallbackTime = 0;
    var globalMostRecentTransitionTime = 0;
    var workInProgressRootRenderTargetTime = Infinity;
    var workInProgressTransitions = null;
    var legacyErrorBoundariesThatAlreadyFailed = null;
    var pendingEffectsStatus = 0;
    var pendingEffectsRoot = null;
    var pendingFinishedWork = null;
    var pendingEffectsLanes = 0;
    var pendingEffectsRemainingLanes = 0;
    var pendingPassiveTransitions = null;
    var pendingRecoverableErrors = null;
    var nestedUpdateCount = 0;
    var rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
    }
    __name(requestUpdateLane, "requestUpdateLane");
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    __name(requestDeferredLane, "requestDeferredLane");
    function scheduleUpdateOnFiber(root3, fiber, lane) {
      if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        prepareFreshStack(root3, 0), markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root3, lane);
      if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
        root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root3,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root3);
    }
    __name(scheduleUpdateOnFiber, "scheduleUpdateOnFiber");
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root3 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root3,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now2(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    __name(performWorkOnRoot, "performWorkOnRoot");
    function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root3.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$1
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason
        );
        var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now2() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now2() : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root3.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root3,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root3,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    __name(commitRootWhenReady, "commitRootWhenReady");
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    __name(isRenderConsistentWithExternalStores, "isRenderConsistentWithExternalStores");
    function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root3.suspendedLanes |= suspendedLanes;
      root3.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root3.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
    }
    __name(markRootSuspended, "markRootSuspended");
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    __name(flushSyncWork$1, "flushSyncWork$1");
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    __name(resetWorkInProgressStack, "resetWorkInProgressStack");
    function prepareFreshStack(root3, lanes) {
      var timeoutHandle = root3.timeoutHandle;
      -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root3.cancelPendingCommit;
      null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root3;
      workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root3.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root3[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    __name(prepareFreshStack, "prepareFreshStack");
    function handleThrow(root3, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root3,
        createCapturedValueAtFiber(thrownValue, root3.current)
      ));
    }
    __name(handleThrow, "handleThrow");
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
    }
    __name(shouldRemainOnPreviousScreen, "shouldRemainOnPreviousScreen");
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    __name(pushDispatcher, "pushDispatcher");
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    __name(pushAsyncDispatcher, "pushAsyncDispatcher");
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    __name(renderDidSuspendDelayIfPossible, "renderDidSuspendDelayIfPossible");
    function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root3, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root3, thrownValue$165);
        }
      while (1);
      lanes && root3.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    __name(renderRootSync, "renderRootSync");
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    __name(workLoopSync, "workLoopSync");
    function renderRootConcurrent(root3, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now2() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root3,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = /* @__PURE__ */ __name(function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root3);
                }, "lanes");
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root3, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    __name(renderRootConcurrent, "renderRootConcurrent");
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    __name(workLoopConcurrentByScheduler, "workLoopConcurrentByScheduler");
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    __name(performUnitOfWork, "performUnitOfWork");
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork;
      var current = next.alternate;
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next);
        default:
          unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    __name(replaySuspendedUnitOfWork, "replaySuspendedUnitOfWork");
    function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root3,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root3 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root3 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root3);
      } else completeUnitOfWork(unitOfWork);
    }
    __name(throwAndUnwindWorkLoop, "throwAndUnwindWorkLoop");
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next) {
          workInProgress = next;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    __name(completeUnitOfWork, "completeUnitOfWork");
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    __name(unwindUnitOfWork, "unwindUnitOfWork");
    function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root3.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root3,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root3;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root3.callbackNode = null, root3.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root3, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    __name(commitRoot, "commitRoot");
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root3);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled2 = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root3.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    __name(flushMutationEffects, "flushMutationEffects");
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    __name(flushLayoutEffects, "flushLayoutEffects");
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
        var remainingLanes = root3.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root3.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root3);
        remainingLanes = root3.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0, false);
      }
    }
    __name(flushSpawnedWork, "flushSpawnedWork");
    function releaseRootPooledCache(root3, remainingLanes) {
      0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
    }
    __name(releaseRootPooledCache, "releaseRootPooledCache");
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    __name(flushPendingEffects, "flushPendingEffects");
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
      }
    }
    __name(flushPassiveEffects, "flushPassiveEffects");
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    __name(captureCommitPhaseErrorOnRoot, "captureCommitPhaseErrorOnRoot");
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    __name(captureCommitPhaseError, "captureCommitPhaseError");
    function attachPingListener(root3, wakeable, lanes) {
      var pingCache = root3.pingCache;
      if (null === pingCache) {
        pingCache = root3.pingCache = new PossiblyWeakMap();
        var threadIDs = /* @__PURE__ */ new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
    }
    __name(attachPingListener, "attachPingListener");
    function pingSuspendedRoot(root3, wakeable, pingedLanes) {
      var pingCache = root3.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
      root3.warmLanes &= ~pingedLanes;
      workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now2() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root3);
    }
    __name(pingSuspendedRoot, "pingSuspendedRoot");
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    __name(retryTimedOutBoundary, "retryTimedOutBoundary");
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    __name(retryDehydratedSuspenseBoundary, "retryDehydratedSuspenseBoundary");
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    __name(resolveRetryWakeable, "resolveRetryWakeable");
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    __name(scheduleCallback$1, "scheduleCallback$1");
    var firstScheduledRoot = null;
    var lastScheduledRoot = null;
    var didScheduleMicrotask = false;
    var mightHavePendingSyncWork = false;
    var isFlushingWork = false;
    var currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root3) {
      root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    __name(ensureRootIsScheduled, "ensureRootIsScheduled");
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (!onlyLegacy)
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$170.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    __name(flushSyncWorkAcrossRoots_impl, "flushSyncWorkAcrossRoots_impl");
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    __name(processRootScheduleInImmediateTask, "processRootScheduleInImmediateTask");
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now2(), prev = null, root3 = firstScheduledRoot; null !== root3; ) {
        var next = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
        if (0 === nextLanes)
          root3.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
        else if (prev = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root3 = next;
      }
      0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    __name(processRootScheduleInMicrotask, "processRootScheduleInMicrotask");
    function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
      for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root3,
        root3 === currentTime ? suspendedLanes : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      pingedLanes = root3.callbackNode;
      if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root3.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root3.callbackPriority = currentTime;
        root3.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root3.callbackPriority = 2;
      root3.callbackNode = null;
      return 2;
    }
    __name(scheduleTaskForRootDuringMicrotask, "scheduleTaskForRootDuringMicrotask");
    function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root3.callbackNode = null, root3.callbackPriority = 0, null;
      var originalCallbackNode = root3.callbackNode;
      if (flushPendingEffects() && root3.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root3,
        root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root3, now2());
      return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
    }
    __name(performWorkOnRootViaSchedulerTask, "performWorkOnRootViaSchedulerTask");
    function performSyncWorkOnRoot(root3, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root3, lanes, true);
    }
    __name(performSyncWorkOnRoot, "performSyncWorkOnRoot");
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    __name(scheduleImmediateRootScheduleTask, "scheduleImmediateRootScheduleTask");
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    __name(requestTransitionLane, "requestTransitionLane");
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    __name(coerceFormActionProp, "coerceFormActionProp");
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    __name(createFormDataWithSubmitter, "createFormDataWithSubmitter");
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: /* @__PURE__ */ __name(function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              }, "listener"),
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    __name(extractEvents$1, "extractEvents$1");
    for (i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
      eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580
      );
    }
    var eventName$jscomp$inline_1578;
    var domEventName$jscomp$inline_1579;
    var capitalizedEvent$jscomp$inline_1580;
    var i$jscomp$inline_1577;
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    );
    var nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    __name(processDispatchQueue, "processDispatchQueue");
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    __name(listenToNonDelegatedEvent, "listenToNonDelegatedEvent");
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    __name(listenToNativeEvent, "listenToNativeEvent");
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    __name(listenToAllSupportedEvents, "listenToAllSupportedEvents");
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    __name(addTrappedEventListener, "addTrappedEventListener");
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                      lastHostComponent++;
                    _instance = 0;
                    for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (; 0 < _instance - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance--;
                    for (; lastHostComponent--; ) {
                      if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    __name(dispatchEventForPluginEventSystem, "dispatchEventForPluginEventSystem");
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    __name(createDispatchListener, "createDispatchListener");
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    __name(accumulateTwoPhaseListeners, "accumulateTwoPhaseListeners");
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    __name(getParent, "getParent");
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    __name(accumulateEnterLeaveListenersForEvent, "accumulateEnterLeaveListenersForEvent");
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
    var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    __name(normalizeMarkupForTextOrAttribute, "normalizeMarkupForTextOrAttribute");
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    __name(checkForUnmatchedText, "checkForUnmatchedText");
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    __name(setProp, "setProp");
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    __name(setPropOnCustomElement, "setPropOnCustomElement");
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$184, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    __name(setInitialProperties, "setInitialProperties");
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
              switch (propKey$201) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$201,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$201 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(
                    domElement,
                    tag,
                    type,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$201 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
          for (checked in nextProps)
            if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
            for (defaultChecked in nextProps)
              propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$232 in lastProps)
        propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
      for (lastProp in nextProps)
        propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
    }
    __name(updateProperties, "updateProperties");
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    __name(isLikelyStaticResource, "isLikelyStaticResource");
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (var count = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
          var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
          if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
            count++;
            if (10 < count) break;
          }
        }
        if (0 < count) return bits / count / 1e6;
      }
      return navigator.connection && (count = navigator.connection.downlink, "number" === typeof count) ? count : 5;
    }
    __name(estimateBandwidth, "estimateBandwidth");
    var eventsEnabled = null;
    var selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    __name(getOwnerDocumentFromRootContainer, "getOwnerDocumentFromRootContainer");
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    __name(getOwnHostContext, "getOwnHostContext");
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
    }
    __name(getChildHostContextProd, "getChildHostContextProd");
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    __name(shouldSetTextContent, "shouldSetTextContent");
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    __name(shouldAttemptEagerTransition, "shouldAttemptEagerTransition");
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
    var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var localPromise = "function" === typeof Promise ? Promise : void 0;
    var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    __name(handleErrorInNextTick, "handleErrorInNextTick");
    function isSingletonScope(type) {
      return "head" === type;
    }
    __name(isSingletonScope, "isSingletonScope");
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance, depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node || "/&" === node) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
            depth++;
          else if ("html" === node)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if ("head" === node) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    __name(clearHydrationBoundary, "clearHydrationBoundary");
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node)
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    __name(hideOrUnhideDehydratedBoundary, "hideOrUnhideDehydratedBoundary");
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    __name(clearContainerSparingly, "clearContainerSparingly");
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    __name(canHydrateInstance, "canHydrateInstance");
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    __name(canHydrateTextInstance, "canHydrateTextInstance");
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    __name(canHydrateHydrationBoundary, "canHydrateHydrationBoundary");
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    __name(isSuspenseInstancePending, "isSuspenseInstancePending");
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
    }
    __name(isSuspenseInstanceFallback, "isSuspenseInstanceFallback");
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = /* @__PURE__ */ __name(function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        }, "listener");
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    __name(registerSuspenseInstanceRetry, "registerSuspenseInstanceRetry");
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node;
    }
    __name(getNextHydratable, "getNextHydratable");
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if ("/$" === data || "/&" === data) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    __name(getNextHydratableInstanceAfterHydrationBoundary, "getNextHydratableInstanceAfterHydrationBoundary");
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" !== data && "/&" !== data || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    __name(getParentHydrationBoundary, "getParentHydrationBoundary");
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    __name(resolveSingletonInstance, "resolveSingletonInstance");
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    __name(releaseSingletonInstance, "releaseSingletonInstance");
    var preloadPropsMap = /* @__PURE__ */ new Map();
    var preconnectsSet = /* @__PURE__ */ new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    __name(getHoistableRoot, "getHoistableRoot");
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    __name(flushSyncWork, "flushSyncWork");
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    __name(requestFormReset, "requestFormReset");
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    __name(preconnectAs, "preconnectAs");
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    __name(prefetchDNS, "prefetchDNS");
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    __name(preconnect, "preconnect");
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    __name(preload, "preload");
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    __name(preloadModule, "preloadModule");
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state.loading = 5;
          else {
            href = assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state.loading |= 1;
            });
            link.addEventListener("error", function() {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state
          };
          styles.set(key, resource);
        }
      }
    }
    __name(preinitStyle, "preinitStyle");
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    __name(preinitScript, "preinitScript");
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    __name(preinitModuleScript, "preinitModuleScript");
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$244 = styles$243.get(type);
            resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type)
            )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
              JSCompiler_inline_result,
              type,
              pendingProps,
              resource$244.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    __name(getResource, "getResource");
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    __name(getStyleKey, "getStyleKey");
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    __name(getStylesheetSelectorFromKey, "getStylesheetSelectorFromKey");
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    __name(stylesheetPropsFromRawProps, "stylesheetPropsFromRawProps");
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= 1;
      }), key.addEventListener("error", function() {
        return state.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    __name(preloadStylesheet, "preloadStylesheet");
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    __name(getScriptKey, "getScriptKey");
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    __name(getScriptSelectorFromKey, "getScriptSelectorFromKey");
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$249)
              return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return resource.instance = instance$249;
          case "script":
            instance$249 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$249)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$249))
              instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    __name(acquireResource, "acquireResource");
    function insertStylesheet(instance, precedence, root3) {
      for (var nodes = root3.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance, precedence.firstChild));
    }
    __name(insertStylesheet, "insertStylesheet");
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    __name(adoptPreloadPropsForStylesheet, "adoptPreloadPropsForStylesheet");
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    __name(adoptPreloadPropsForScript, "adoptPreloadPropsForScript");
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = /* @__PURE__ */ new Map();
        var caches = tagCaches = /* @__PURE__ */ new Map();
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    __name(getHydratableHoistableCache, "getHydratableHoistableCache");
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    __name(mountHoistable, "mountHoistable");
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type = props.disabled, "string" === typeof props.precedence && null == type;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    __name(isHostHoistableType, "isHostHoistableType");
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    __name(preloadResource, "preloadResource");
    function suspendResource(state, hoistableRoot, resource, props) {
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    __name(suspendResource, "suspendResource");
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function() {
            state.waitingForImages = false;
            if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
        );
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    __name(waitForCommitToBeReady, "waitForCommitToBeReady");
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    __name(onUnsuspend, "onUnsuspend");
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    __name(insertSuspendedStylesheets, "insertSuspendedStylesheets");
    function insertStylesheetIntoRoot(root3, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root3);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = /* @__PURE__ */ new Map();
          precedencesByRoot.set(root3, precedences);
          for (var nodes = root3.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
              precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(null, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
        resource.state.loading |= 4;
      }
    }
    __name(insertStylesheetIntoRoot, "insertStylesheetIntoRoot");
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    __name(FiberRootNode, "FiberRootNode");
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    __name(createFiberRoot, "createFiberRoot");
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    __name(getContextForSubtree, "getContextForSubtree");
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    __name(updateContainerImpl, "updateContainerImpl");
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    __name(markRetryLaneImpl, "markRetryLaneImpl");
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    __name(markRetryLaneIfNotHydrated, "markRetryLaneIfNotHydrated");
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    __name(attemptContinuousHydration, "attemptContinuousHydration");
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root3 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    __name(attemptHydrationAtCurrentPriority, "attemptHydrationAtCurrentPriority");
    var _enabled2 = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    __name(dispatchDiscreteEvent, "dispatchDiscreteEvent");
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    __name(dispatchContinuousEvent, "dispatchContinuousEvent");
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled2) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root3 = fiber;
                      root3.pendingLanes |= 2;
                      for (root3.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root3.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now2() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    __name(dispatchEvent, "dispatchEvent");
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    __name(findInstanceBlockingEvent, "findInstanceBlockingEvent");
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    __name(findInstanceBlockingTarget, "findInstanceBlockingTarget");
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    __name(getEventPriority, "getEventPriority");
    var hasScheduledReplayAttempt = false;
    var queuedFocus = null;
    var queuedDrag = null;
    var queuedMouse = null;
    var queuedPointers = /* @__PURE__ */ new Map();
    var queuedPointerCaptures = /* @__PURE__ */ new Map();
    var queuedExplicitHydrationTargets = [];
    var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    __name(clearIfContinuousEvent, "clearIfContinuousEvent");
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    __name(accumulateOrCreateContinuousQueuedReplayableEvent, "accumulateOrCreateContinuousQueuedReplayableEvent");
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    __name(queueIfContinuousEvent, "queueIfContinuousEvent");
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    __name(attemptExplicitHydrationTarget, "attemptExplicitHydrationTarget");
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    __name(attemptReplayContinuousQueuedEvent, "attemptReplayContinuousQueuedEvent");
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    __name(attemptReplayContinuousQueuedEventInMap, "attemptReplayContinuousQueuedEventInMap");
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    __name(replayUnblockedEvents, "replayUnblockedEvents");
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    __name(scheduleCallbackIfUnblocked, "scheduleCallbackIfUnblocked");
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i = 0; i < formReplayingQueue.length; i += 3) {
            var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    __name(scheduleReplayQueueIfNeeded, "scheduleReplayQueueIfNeeded");
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      __name(unblock, "unblock");
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
        attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    __name(retryIfBlockedOn, "retryIfBlockedOn");
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && "react-transition" === event.info && event.intercept({
          handler: /* @__PURE__ */ __name(function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          }, "handler"),
          focusReset: "manual",
          scroll: "manual"
        });
      }
      __name(handleNavigate, "handleNavigate");
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      __name(handleNavigateComplete, "handleNavigateComplete");
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      __name(startFakeNavigation, "startFakeNavigation");
      if ("object" === typeof navigation) {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    __name(defaultOnDefaultTransitionIndicator, "defaultOnDefaultTransitionIndicator");
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    __name(ReactDOMRoot, "ReactDOMRoot");
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root3 = this._internalRoot;
      if (null === root3) throw Error(formatProdErrorMessage(409));
      var current = root3.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root3, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root3 = this._internalRoot;
      if (null !== root3) {
        this._internalRoot = null;
        var container = root3.containerInfo;
        updateContainerImpl(root3.current, 2, null, root3, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    __name(ReactDOMHydrationRoot, "ReactDOMHydrationRoot");
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React6.version;
    if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.3"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.3",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.3"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347
          ), injectedHook = hook$jscomp$inline_2348;
        } catch (err) {
        }
    }
    var hook$jscomp$inline_2348;
    exports.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    exports.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports, module2) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    __name(checkDCE, "checkDCE");
    if (true) {
      checkDCE();
      module2.exports = require_react_dom_client_production();
    } else {
      module2.exports = null;
    }
  }
});

// node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    __name(jsxProd, "jsxProd");
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsxProd;
    exports.jsxs = jsxProd;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module2) {
    "use strict";
    if (true) {
      module2.exports = require_react_jsx_runtime_production();
    } else {
      module2.exports = null;
    }
  }
});

// spa/vrf-demo.tsx
var import_react28 = __toESM(require_react());
var import_client = __toESM(require_client());

// spa/SpaLayout.tsx
var import_react = __toESM(require_react());
function SpaLayout({ title, description, children }) {
  const pathname = typeof window !== "undefined" ? window.location.pathname : "";
  const navItems = [
    { href: "/", label: "Home" },
    { href: "/spa/vrf-demo.html", label: "VRF Demo" },
    { href: "/spa/relay-demo.html", label: "Relay Demo" },
    { href: "/spa/nist-tests.html", label: "NIST Tests" }
  ];
  return /* @__PURE__ */ import_react.default.createElement("div", { className: "min-h-screen bg-background text-foreground" }, /* @__PURE__ */ import_react.default.createElement("header", { className: "border-b border-border/50 bg-card/60" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "container mx-auto px-4 py-6" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between" }, /* @__PURE__ */ import_react.default.createElement("div", { className: "flex items-center gap-3" }, /* @__PURE__ */ import_react.default.createElement("a", { href: "/", className: "flex items-center gap-2 text-xl font-bold font-display" }, /* @__PURE__ */ import_react.default.createElement("span", null, /* @__PURE__ */ import_react.default.createElement("span", { className: "text-primary" }, "\uA4D8"), /* @__PURE__ */ import_react.default.createElement("span", { className: "text-secondary" }, "K"))), /* @__PURE__ */ import_react.default.createElement("span", { className: "hidden sm:block text-muted-foreground" }, "/"), /* @__PURE__ */ import_react.default.createElement("span", { className: "hidden sm:block text-sm font-medium text-muted-foreground" }, title)), /* @__PURE__ */ import_react.default.createElement("nav", { className: "flex flex-wrap gap-2" }, navItems.map((item) => {
    const isActive = pathname === item.href;
    return /* @__PURE__ */ import_react.default.createElement(
      "a",
      {
        key: item.href,
        href: item.href,
        "aria-current": isActive ? "page" : void 0,
        className: [
          "inline-flex items-center rounded-lg px-3 py-1.5 text-sm font-medium transition-colors border",
          isActive ? "bg-primary/10 text-primary border-primary/30" : "text-muted-foreground hover:text-foreground hover:bg-muted/50 border-transparent"
        ].join(" ")
      },
      item.label
    );
  }))), /* @__PURE__ */ import_react.default.createElement("h1", { className: "text-3xl font-bold font-display mt-5" }, title), /* @__PURE__ */ import_react.default.createElement("p", { className: "text-muted-foreground mt-2 max-w-3xl" }, description))), /* @__PURE__ */ import_react.default.createElement("main", { className: "container mx-auto px-4 py-8" }, children));
}
__name(SpaLayout, "SpaLayout");

// app/vrf-demo/components/vrf-visualizer.tsx
var import_react27 = __toESM(require_react());

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react2 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react2.createContext)({});

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react3 = __toESM(require_react(), 1);
function useConstant(init2) {
  const ref = (0, import_react3.useRef)(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}
__name(useConstant, "useConstant");

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React3 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react4 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react4.createContext)(null);

// node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react5 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react5.createContext)({
  transformPagePoint: /* @__PURE__ */ __name((p) => p, "transformPagePoint"),
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var _PopChildMeasure = class _PopChildMeasure extends React2.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
__name(_PopChildMeasure, "PopChildMeasure");
var PopChildMeasure = _PopChildMeasure;
function PopChild({ children, isPresent }) {
  const id3 = (0, import_react6.useId)();
  const ref = (0, import_react6.useRef)(null);
  const size = (0, import_react6.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const { nonce } = (0, import_react6.useContext)(MotionConfigContext);
  (0, import_react6.useInsertionEffect)(() => {
    const { width, height, top, left } = size.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id3;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return (0, import_jsx_runtime.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size, children: React2.cloneElement(children, { ref }) });
}
__name(PopChild, "PopChild");

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var PresenceChild = /* @__PURE__ */ __name(({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id3 = (0, import_react7.useId)();
  const memoizedOnExitComplete = (0, import_react7.useCallback)((childId) => {
    presenceChildren.set(childId, true);
    for (const isComplete of presenceChildren.values()) {
      if (!isComplete)
        return;
    }
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]);
  const context = (0, import_react7.useMemo)(
    () => ({
      id: id3,
      initial,
      isPresent,
      custom,
      onExitComplete: memoizedOnExitComplete,
      register: /* @__PURE__ */ __name((childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }, "register")
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]
  );
  (0, import_react7.useMemo)(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  React3.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = (0, import_jsx_runtime2.jsx)(PopChild, { isPresent, children });
  }
  return (0, import_jsx_runtime2.jsx)(PresenceContext.Provider, { value: context, children });
}, "PresenceChild");
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
__name(newChildrenMap, "newChildrenMap");

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react8 = __toESM(require_react(), 1);
function usePresence(subscribe = true) {
  const context = (0, import_react8.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id3 = (0, import_react8.useId)();
  (0, import_react8.useEffect)(() => {
    if (subscribe)
      register(id3);
  }, [subscribe]);
  const safeToRemove = (0, import_react8.useCallback)(() => subscribe && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
__name(usePresence, "usePresence");

// node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs
var import_react9 = __toESM(require_react(), 1);
var getChildKey = /* @__PURE__ */ __name((child) => child.key || "", "getChildKey");
function onlyElements(children) {
  const filtered = [];
  import_react9.Children.forEach(children, (child) => {
    if ((0, import_react9.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
__name(onlyElements, "onlyElements");

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react10 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser = typeof window !== "undefined";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser ? import_react10.useLayoutEffect : import_react10.useEffect;

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var AnimatePresence = /* @__PURE__ */ __name(({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = (0, import_react11.useMemo)(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = (0, import_react11.useRef)(true);
  const pendingPresentChildren = (0, import_react11.useRef)(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = (0, import_react11.useState)(presentChildren);
  const [renderedChildren, setRenderedChildren] = (0, import_react11.useState)(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return;
  }
  if (false) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  const { forceRender } = (0, import_react11.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: renderedChildren.map((child) => {
    const key = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
    const onExit = /* @__PURE__ */ __name(() => {
      if (exitComplete.has(key)) {
        exitComplete.set(key, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender === null || forceRender === void 0 ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
        onExitComplete && onExitComplete();
      }
    }, "onExit");
    return (0, import_jsx_runtime3.jsx)(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom: isPresent ? void 0 : custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, children: child }, key);
  }) });
}, "AnimatePresence");

// node_modules/motion-utils/dist/es/noop.mjs
var noop = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (any) => any, "noop");

// node_modules/motion-utils/dist/es/errors.mjs
var warning = noop;
var invariant = noop;
if (false) {
  warning = /* @__PURE__ */ __name((check, message) => {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  }, "warning");
  invariant = /* @__PURE__ */ __name((check, message) => {
    if (!check) {
      throw new Error(message);
    }
  }, "invariant");
}

// node_modules/motion-utils/dist/es/memo.mjs
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
__name(memo, "memo");

// node_modules/motion-utils/dist/es/progress.mjs
var progress = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
}, "progress");

// node_modules/motion-utils/dist/es/time-conversion.mjs
var secondsToMilliseconds = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3, "secondsToMilliseconds");
var millisecondsToSeconds = /* @__PURE__ */ __name(/* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3, "millisecondsToSeconds");

// node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs
var MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};

// node_modules/framer-motion/dist/es/frameloop/render-step.mjs
function createRenderStep(runNextFrame) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  __name(triggerCallback, "triggerCallback");
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: /* @__PURE__ */ __name((callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    }, "schedule"),
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: /* @__PURE__ */ __name((callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    }, "cancel"),
    /**
     * Execute all schedule callbacks.
     */
    process: /* @__PURE__ */ __name((frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }, "process")
  };
  return step;
}
__name(createRenderStep, "createRenderStep");

// node_modules/framer-motion/dist/es/frameloop/batcher.mjs
var stepsOrder = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = /* @__PURE__ */ __name(() => runNextFrame = true, "flagRunNextFrame");
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
  const processBatch = /* @__PURE__ */ __name(() => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    read.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  }, "processBatch");
  const wake = /* @__PURE__ */ __name(() => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  }, "wake");
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = /* @__PURE__ */ __name((process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps[stepsOrder[i]].cancel(process2);
    }
  }, "cancel");
  return { schedule, cancel, state, steps };
}
__name(createRenderBatcher, "createRenderBatcher");

// node_modules/framer-motion/dist/es/frameloop/frame.mjs
var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react12 = __toESM(require_react(), 1);
var LazyContext = (0, import_react12.createContext)({ strict: false });

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
var featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: /* @__PURE__ */ __name((props) => featureProps[key].some((name) => !!props[name]), "isEnabled")
  };
}

// node_modules/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}
__name(loadFeatures, "loadFeatures");

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
__name(isValidMotionProp, "isValidMotionProp");

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = /* @__PURE__ */ __name((key) => !isValidMotionProp(key), "shouldForward");
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = /* @__PURE__ */ __name((key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key), "shouldForward");
}
__name(loadExternalIsValidProp, "loadExternalIsValidProp");
try {
  loadExternalIsValidProp(__require("@emotion/is-prop-valid").default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
__name(filterProps, "filterProps");

// node_modules/framer-motion/dist/es/render/components/create-proxy.mjs
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = /* @__PURE__ */ __name((...args) => {
    if (false) {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return componentFactory(...args);
  }, "deprecatedFactoryFunction");
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: /* @__PURE__ */ __name((_target, key) => {
      if (key === "create")
        return componentFactory;
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }, "get")
  });
}
__name(createDOMMotionComponentProxy, "createDOMMotionComponentProxy");

// node_modules/framer-motion/dist/es/motion/index.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react13 = __toESM(require_react(), 1);
var MotionContext = (0, import_react13.createContext)({});

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react14 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
__name(isVariantLabel, "isVariantLabel");

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
__name(isAnimationControls, "isAnimationControls");

// node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
var variantProps = ["initial", ...variantPriorityOrder];

// node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
__name(isControllingVariants, "isControllingVariants");
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
__name(isVariantNode, "isVariantNode");

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
__name(getCurrentTreeVariants, "getCurrentTreeVariants");

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, (0, import_react14.useContext)(MotionContext));
  return (0, import_react14.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
__name(useCreateMotionContext, "useCreateMotionContext");
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
__name(variantLabelsAsDependency, "variantLabelsAsDependency");

// node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react15 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
__name(isRefObject, "isRefObject");

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react15.useCallback)(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
__name(useMotionRef, "useMotionRef");

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react17 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = /* @__PURE__ */ __name((str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), "camelToDash");

// node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId";
var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// node_modules/framer-motion/dist/es/frameloop/microtask.mjs
var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react16 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react16.createContext)({});

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component3, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const { visualElement: parent } = (0, import_react17.useContext)(MotionContext);
  const lazyContext = (0, import_react17.useContext)(LazyContext);
  const presenceContext = (0, import_react17.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react17.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react17.useRef)(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component3, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = (0, import_react17.useContext)(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = (0, import_react17.useRef)(false);
  (0, import_react17.useInsertionEffect)(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = (0, import_react17.useRef)(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react17.useEffect)(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a2;
        (_a2 = window.MotionHandoffMarkAsComplete) === null || _a2 === void 0 ? void 0 : _a2.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
__name(useVisualElement, "useVisualElement");
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
__name(createProjectionNode, "createProjectionNode");
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
__name(getClosestProjectingNode, "getClosestProjectingNode");

// node_modules/framer-motion/dist/es/motion/index.mjs
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component: Component3 }) {
  var _a, _b;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...(0, import_react18.useContext)(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component3, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return (0, import_jsx_runtime4.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime4.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component3, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  __name(MotionComponent, "MotionComponent");
  MotionComponent.displayName = `motion.${typeof Component3 === "string" ? Component3 : `create(${(_b = (_a = Component3.displayName) !== null && _a !== void 0 ? _a : Component3.name) !== null && _b !== void 0 ? _b : ""})`}`;
  const ForwardRefMotionComponent = (0, import_react18.forwardRef)(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component3;
  return ForwardRefMotionComponent;
}
__name(createRendererMotionComponent, "createRendererMotionComponent");
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react18.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
__name(useLayoutId, "useLayoutId");
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = (0, import_react18.useContext)(LazyContext).strict;
  if (false) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
  }
}
__name(useStrictMode, "useStrictMode");
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 === null || drag2 === void 0 ? void 0 : drag2.isEnabled(props)) || (layout2 === null || layout2 === void 0 ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}
__name(getProjectionFunctionality, "getProjectionFunctionality");

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component3) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component3 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component3.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component3) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component3)
  ) {
    return true;
  }
  return false;
}
__name(isSVGComponent, "isSVGComponent");

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react19 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
__name(getValueState, "getValueState");
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
__name(resolveVariantFromProps, "resolveVariantFromProps");

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = /* @__PURE__ */ __name((v) => {
  return Array.isArray(v);
}, "isKeyframesTarget");

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = /* @__PURE__ */ __name((v) => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
}, "isCustomValue");
var resolveFinalValueInKeyframes = /* @__PURE__ */ __name((v) => {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
}, "resolveFinalValueInKeyframes");

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = /* @__PURE__ */ __name((value) => Boolean(value && value.getVelocity), "isMotionValue");

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
__name(resolveMotionValue, "resolveMotionValue");

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState, onUpdate }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onUpdate) {
    state.onMount = (instance) => onUpdate({ props, current: instance, ...state });
    state.onUpdate = (visualElement) => onUpdate(visualElement);
  }
  return state;
}
__name(makeState, "makeState");
var makeUseVisualState = /* @__PURE__ */ __name((config) => (props, isStatic) => {
  const context = (0, import_react19.useContext)(MotionContext);
  const presenceContext = (0, import_react19.useContext)(PresenceContext);
  const make = /* @__PURE__ */ __name(() => makeState(config, props, context, presenceContext), "make");
  return isStatic ? make() : useConstant(make);
}, "makeUseVisualState");
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate === void 0)
      animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
__name(makeLatestValues, "makeLatestValues");

// node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = new Set(transformPropOrder);

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
var checkStringStartsWith = /* @__PURE__ */ __name((token) => (key) => typeof key === "string" && key.startsWith(token), "checkStringStartsWith");
var isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
var startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
var isCSSVariableToken = /* @__PURE__ */ __name((value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
}, "isCSSVariableToken");
var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = /* @__PURE__ */ __name((value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
}, "getValueAsType");

// node_modules/framer-motion/dist/es/utils/clamp.mjs
var clamp = /* @__PURE__ */ __name((min, max, v) => {
  if (v > max)
    return max;
  if (v < min)
    return min;
  return v;
}, "clamp");

// node_modules/framer-motion/dist/es/value/types/numbers/index.mjs
var number = {
  test: /* @__PURE__ */ __name((v) => typeof v === "number", "test"),
  parse: parseFloat,
  transform: /* @__PURE__ */ __name((v) => v, "transform")
};
var alpha = {
  ...number,
  transform: /* @__PURE__ */ __name((v) => clamp(0, 1, v), "transform")
};
var scale = {
  ...number,
  default: 1
};

// node_modules/framer-motion/dist/es/value/types/numbers/units.mjs
var createUnitType = /* @__PURE__ */ __name((unit) => ({
  test: /* @__PURE__ */ __name((v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1, "test"),
  parse: parseFloat,
  transform: /* @__PURE__ */ __name((v) => `${v}${unit}`, "transform")
}), "createUnitType");
var degrees = /* @__PURE__ */ createUnitType("deg");
var percent = /* @__PURE__ */ createUnitType("%");
var px = /* @__PURE__ */ createUnitType("px");
var vh = /* @__PURE__ */ createUnitType("vh");
var vw = /* @__PURE__ */ createUnitType("vw");
var progressPercentage = {
  ...percent,
  parse: /* @__PURE__ */ __name((v) => percent.parse(v) / 100, "parse"),
  transform: /* @__PURE__ */ __name((v) => percent.transform(v * 100), "transform")
};

// node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs
var browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
};

// node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs
var transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
var int = {
  ...number,
  transform: Math.round
};

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
__name(buildTransform, "buildTransform");

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
__name(buildHTMLStyles, "buildHTMLStyles");

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
__name(buildSVGPath, "buildSVGPath");

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
__name(calcOrigin, "calcOrigin");
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
__name(calcSVGTransformOrigin, "calcSVGTransformOrigin");

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style, dimensions } = state;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
__name(buildSVGAttrs, "buildSVGAttrs");

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = /* @__PURE__ */ __name(() => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), "createHtmlRenderState");

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = /* @__PURE__ */ __name(() => ({
  ...createHtmlRenderState(),
  attrs: {}
}), "createSvgRenderState");

// node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = /* @__PURE__ */ __name((tag) => typeof tag === "string" && tag.toLowerCase() === "svg", "isSVGTag");

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
__name(renderHTML, "renderHTML");

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
__name(renderSVG, "renderSVG");

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
__name(addScaleCorrector, "addScaleCorrector");

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
__name(isForcedMotionValue, "isForcedMotionValue");

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  var _a;
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps, "scrapeMotionValuesFromProps");

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
__name(scrapeMotionValuesFromProps2, "scrapeMotionValuesFromProps");

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
function updateSVGDimensions(instance, renderState) {
  try {
    renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
  } catch (e) {
    renderState.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
__name(updateSVGDimensions, "updateSVGDimensions");
var layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onUpdate: /* @__PURE__ */ __name(({ props, prevProps, current, renderState, latestValues }) => {
      if (!current)
        return;
      let hasTransform2 = !!props.drag;
      if (!hasTransform2) {
        for (const key in latestValues) {
          if (transformProps.has(key)) {
            hasTransform2 = true;
            break;
          }
        }
      }
      if (!hasTransform2)
        return;
      let needsMeasure = !prevProps;
      if (prevProps) {
        for (let i = 0; i < layoutProps.length; i++) {
          const key = layoutProps[i];
          if (props[key] !== prevProps[key]) {
            needsMeasure = true;
          }
        }
      }
      if (!needsMeasure)
        return;
      frame.read(() => {
        updateSVGDimensions(current, renderState);
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);
          renderSVG(current, renderState);
        });
      });
    }, "onUpdate")
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react22 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react20 = __toESM(require_react(), 1);
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
__name(copyRawValuesOnly, "copyRawValuesOnly");
function useInitialMotionValues({ transformTemplate }, visualState) {
  return (0, import_react20.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
__name(useInitialMotionValues, "useInitialMotionValues");
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
__name(useStyle, "useStyle");
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
__name(useHTMLProps, "useHTMLProps");

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react21 = __toESM(require_react(), 1);
function useSVGProps(props, visualState, _isStatic, Component3) {
  const visualProps = (0, import_react21.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component3), props.transformTemplate);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
__name(useSVGProps, "useSVGProps");

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = false) {
  const useRender = /* @__PURE__ */ __name((Component3, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component3) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component3);
    const filteredProps = filterProps(props, typeof Component3 === "string", forwardMotionProps);
    const elementProps = Component3 !== import_react22.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react22.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react22.createElement)(Component3, {
      ...elementProps,
      children: renderedChildren
    });
  }, "useRender");
  return useRender;
}
__name(createUseRender, "createUseRender");

// node_modules/framer-motion/dist/es/render/components/create-factory.mjs
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return /* @__PURE__ */ __name(function createMotionComponent2(Component3, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component3) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component3
    };
    return createRendererMotionComponent(config);
  }, "createMotionComponent");
}
__name(createMotionComponentFactory, "createMotionComponentFactory");

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
__name(shallowCompare, "shallowCompare");

// node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}
__name(resolveVariant, "resolveVariant");

// node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs
var supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);

// node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs
var _BaseGroupPlaybackControls = class _BaseGroupPlaybackControls {
  constructor(animations2) {
    this.stop = () => this.runAll("stop");
    this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => "finished" in animation ? animation.finished : animation));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline, fallback) {
    const subscriptions = this.animations.map((animation) => {
      if (supportsScrollTimeline() && animation.attachTimeline) {
        return animation.attachTimeline(timeline);
      } else if (typeof fallback === "function") {
        return fallback(animation);
      }
    });
    return () => {
      subscriptions.forEach((cancel, i) => {
        cancel && cancel();
        this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max = Math.max(max, this.animations[i].duration);
    }
    return max;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
};
__name(_BaseGroupPlaybackControls, "BaseGroupPlaybackControls");
var BaseGroupPlaybackControls = _BaseGroupPlaybackControls;

// node_modules/motion-dom/dist/es/animation/controls/Group.mjs
var _GroupPlaybackControls = class _GroupPlaybackControls extends BaseGroupPlaybackControls {
  then(onResolve, onReject) {
    return Promise.all(this.animations).then(onResolve).catch(onReject);
  }
};
__name(_GroupPlaybackControls, "GroupPlaybackControls");
var GroupPlaybackControls = _GroupPlaybackControls;

// node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs
function getValueTransition(transition, key) {
  return transition ? transition[key] || transition["default"] || transition : void 0;
}
__name(getValueTransition, "getValueTransition");

// node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs
var maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}
__name(calcGeneratorDuration, "calcGeneratorDuration");

// node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs
function isGenerator(type) {
  return typeof type === "function";
}
__name(isGenerator, "isGenerator");

// node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs
function attachTimeline(animation, timeline) {
  animation.timeline = timeline;
  animation.onfinish = null;
}
__name(attachTimeline, "attachTimeline");

// node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs
var isBezierDefinition = /* @__PURE__ */ __name((easing) => Array.isArray(easing) && typeof easing[0] === "number", "isBezierDefinition");

// node_modules/motion-dom/dist/es/utils/supports/flags.mjs
var supportsFlags = {
  linearEasing: void 0
};

// node_modules/motion-dom/dist/es/utils/supports/memo.mjs
function memoSupports(callback, supportsFlag) {
  const memoized = memo(callback);
  return () => {
    var _a;
    return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized();
  };
}
__name(memoSupports, "memoSupports");

// node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs
var supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e) {
    return false;
  }
  return true;
}, "linearEasing");

// node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs
var generateLinearEasing = /* @__PURE__ */ __name((easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i = 0; i < numPoints; i++) {
    points += easing(progress(0, numPoints - 1, i)) + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
}, "generateLinearEasing");

// node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs
function isWaapiSupportedEasing(easing) {
  return Boolean(typeof easing === "function" && supportsLinearEasing() || !easing || typeof easing === "string" && (easing in supportedWaapiEasing || supportsLinearEasing()) || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
__name(isWaapiSupportedEasing, "isWaapiSupportedEasing");
var cubicBezierAsString = /* @__PURE__ */ __name(([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`, "cubicBezierAsString");
var supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function" && supportsLinearEasing()) {
    return generateLinearEasing(easing, duration);
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
__name(mapEasingToNativeEasing, "mapEasingToNativeEasing");

// node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs
var isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}
__name(isDragActive, "isDragActive");

// node_modules/motion-dom/dist/es/utils/resolve-elements.mjs
function resolveElements(elementOrSelector, scope, selectorCache) {
  var _a;
  if (elementOrSelector instanceof Element) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root2 = document;
    if (scope) {
      root2 = scope.current;
    }
    const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root2.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
__name(resolveElements, "resolveElements");

// node_modules/motion-dom/dist/es/gestures/utils/setup.mjs
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = /* @__PURE__ */ __name(() => gestureAbortController.abort(), "cancel");
  return [elements, eventOptions, cancel];
}
__name(setupGesture, "setupGesture");

// node_modules/motion-dom/dist/es/gestures/hover.mjs
function filterEvents(callback) {
  return (event) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    callback(event);
  };
}
__name(filterEvents, "filterEvents");
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = filterEvents((enterEvent) => {
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = filterEvents((leaveEvent) => {
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    });
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  });
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
__name(hover, "hover");

// node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = /* @__PURE__ */ __name((parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
}, "isNodeOrChild");

// node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs
var isPrimaryPointer = /* @__PURE__ */ __name((event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
}, "isPrimaryPointer");

// node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs
var focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
__name(isElementKeyboardAccessible, "isElementKeyboardAccessible");

// node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs
var isPressing = /* @__PURE__ */ new WeakSet();

// node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs
function filterEvents2(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
__name(filterEvents2, "filterEvents");
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
__name(firePointerEvent, "firePointerEvent");
var enableKeyboardPress = /* @__PURE__ */ __name((focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents2(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents2(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = /* @__PURE__ */ __name(() => firePointerEvent(element, "cancel"), "handleBlur");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
}, "enableKeyboardPress");

// node_modules/motion-dom/dist/es/gestures/press/index.mjs
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
__name(isValidPressEvent, "isValidPressEvent");
function press(elementOrSelector, onPressStart, options = {}) {
  const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);
  const startPress = /* @__PURE__ */ __name((startEvent) => {
    const element = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent) || isPressing.has(element))
      return;
    isPressing.add(element);
    const onPressEnd = onPressStart(startEvent);
    const onPointerEnd = /* @__PURE__ */ __name((endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
        return;
      }
      isPressing.delete(element);
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    }, "onPointerEnd");
    const onPointerUp = /* @__PURE__ */ __name((upEvent) => {
      onPointerEnd(upEvent, options.useGlobalTarget || isNodeOrChild(element, upEvent.target));
    }, "onPointerUp");
    const onPointerCancel = /* @__PURE__ */ __name((cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    }, "onPointerCancel");
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  }, "startPress");
  elements.forEach((element) => {
    if (!isElementKeyboardAccessible(element) && element.getAttribute("tabindex") === null) {
      element.tabIndex = 0;
    }
    const target = options.useGlobalTarget ? window : element;
    target.addEventListener("pointerdown", startPress, eventOptions);
    element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);
  });
  return cancelEvents;
}
__name(press, "press");

// node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}
__name(setDragLock, "setDragLock");

// node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);

// node_modules/framer-motion/dist/es/frameloop/sync-time.mjs
var now;
function clearTime() {
  now = void 0;
}
__name(clearTime, "clearTime");
var time = {
  now: /* @__PURE__ */ __name(() => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  }, "now"),
  set: /* @__PURE__ */ __name((newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }, "set")
};

// node_modules/framer-motion/dist/es/utils/array.mjs
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
__name(addUniqueItem, "addUniqueItem");
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
__name(removeItem, "removeItem");

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var _SubscriptionManager = class _SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};
__name(_SubscriptionManager, "SubscriptionManager");
var SubscriptionManager = _SubscriptionManager;

// node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
__name(velocityPerSecond, "velocityPerSecond");

// node_modules/framer-motion/dist/es/value/index.mjs
var MAX_VELOCITY_DELTA = 30;
var isFloat = /* @__PURE__ */ __name((value) => {
  return !isNaN(parseFloat(value));
}, "isFloat");
var collectMotionValues = {
  current: void 0
};
var _MotionValue = class _MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init2, options = {}) {
    this.version = "11.18.2";
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v, render = true) => {
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init2);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (false) {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
__name(_MotionValue, "MotionValue");
var MotionValue = _MotionValue;
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
__name(motionValue, "motionValue");

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
__name(setMotionValue, "setMotionValue");
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
__name(setTarget, "setTarget");

// node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
__name(isWillChangeMotionValue, "isWillChangeMotionValue");

// node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}
__name(addValueToWillChange, "addValueToWillChange");

// node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
__name(getOptimisedAppearId, "getOptimisedAppearId");

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: false
};

// node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs
var calcBezier = /* @__PURE__ */ __name((t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t, "calcBezier");
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
__name(binarySubdivide, "binarySubdivide");
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = /* @__PURE__ */ __name((aX) => binarySubdivide(aX, 0, 1, mX1, mX2), "getTForX");
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
__name(cubicBezier, "cubicBezier");

// node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs
var mirrorEasing = /* @__PURE__ */ __name((easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2, "mirrorEasing");

// node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs
var reverseEasing = /* @__PURE__ */ __name((easing) => (p) => 1 - easing(1 - p), "reverseEasing");

// node_modules/framer-motion/dist/es/easing/back.mjs
var backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
var backIn = /* @__PURE__ */ reverseEasing(backOut);
var backInOut = /* @__PURE__ */ mirrorEasing(backIn);

// node_modules/framer-motion/dist/es/easing/anticipate.mjs
var anticipate = /* @__PURE__ */ __name((p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))), "anticipate");

// node_modules/framer-motion/dist/es/easing/circ.mjs
var circIn = /* @__PURE__ */ __name((p) => 1 - Math.sin(Math.acos(p)), "circIn");
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circIn);

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = /* @__PURE__ */ __name((v) => /^0[^.\s]+$/u.test(v), "isZeroValueString");

// node_modules/framer-motion/dist/es/animation/utils/is-none.mjs
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
__name(isNone, "isNone");

// node_modules/framer-motion/dist/es/value/types/utils/sanitize.mjs
var sanitize = /* @__PURE__ */ __name((v) => Math.round(v * 1e5) / 1e5, "sanitize");

// node_modules/framer-motion/dist/es/value/types/utils/float-regex.mjs
var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

// node_modules/framer-motion/dist/es/value/types/utils/is-nullish.mjs
function isNullish(v) {
  return v == null;
}
__name(isNullish, "isNullish");

// node_modules/framer-motion/dist/es/value/types/utils/single-color-regex.mjs
var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

// node_modules/framer-motion/dist/es/value/types/color/utils.mjs
var isColorString = /* @__PURE__ */ __name((type, testProp) => (v) => {
  return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
}, "isColorString");
var splitColor = /* @__PURE__ */ __name((aName, bName, cName) => (v) => {
  if (typeof v !== "string")
    return v;
  const [a, b, c, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, "splitColor");

// node_modules/framer-motion/dist/es/value/types/color/rgba.mjs
var clampRgbUnit = /* @__PURE__ */ __name((v) => clamp(0, 255, v), "clampRgbUnit");
var rgbUnit = {
  ...number,
  transform: /* @__PURE__ */ __name((v) => Math.round(clampRgbUnit(v)), "transform")
};
var rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: /* @__PURE__ */ __name(({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")", "transform")
};

// node_modules/framer-motion/dist/es/value/types/color/hex.mjs
function parseHex(v) {
  let r2 = "";
  let g = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r2 = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r2 = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r2 += r2;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
__name(parseHex, "parseHex");
var hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/framer-motion/dist/es/value/types/color/hsla.mjs
var hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: /* @__PURE__ */ __name(({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }, "transform")
};

// node_modules/framer-motion/dist/es/value/types/color/index.mjs
var color = {
  test: /* @__PURE__ */ __name((v) => rgba.test(v) || hex.test(v) || hsla.test(v), "test"),
  parse: /* @__PURE__ */ __name((v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  }, "parse"),
  transform: /* @__PURE__ */ __name((v) => {
    return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }, "transform")
};

// node_modules/framer-motion/dist/es/value/types/utils/color-regex.mjs
var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

// node_modules/framer-motion/dist/es/value/types/complex/index.mjs
function test(v) {
  var _a, _b;
  return isNaN(v) && typeof v === "string" && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
__name(test, "test");
var NUMBER_TOKEN = "number";
var COLOR_TOKEN = "color";
var VAR_TOKEN = "var";
var VAR_FUNCTION_TOKEN = "var(";
var SPLIT_TOKEN = "${}";
var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
__name(analyseComplexValue, "analyseComplexValue");
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
__name(parseComplexValue, "parseComplexValue");
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
__name(createTransformer, "createTransformer");
var convertNumbersToZero = /* @__PURE__ */ __name((v) => typeof v === "number" ? 0 : v, "convertNumbersToZero");
function getAnimatableNone(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
__name(getAnimatableNone, "getAnimatableNone");
var complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone
};

// node_modules/framer-motion/dist/es/value/types/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
__name(applyDefaultFilter, "applyDefaultFilter");
var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
var filter = {
  ...complex,
  getAnimatableNone: /* @__PURE__ */ __name((v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }, "getAnimatableNone")
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
var defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
var getDefaultValueType = /* @__PURE__ */ __name((key) => defaultValueTypes[key], "getDefaultValueType");

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
__name(getAnimatableNone2, "getAnimatableNone");

// node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs
var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
    }
  }
}
__name(makeNoneKeyframesAnimatable, "makeNoneKeyframesAnimatable");

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
var isNumOrPxType = /* @__PURE__ */ __name((v) => v === number || v === px, "isNumOrPxType");
var getPosFromMatrix = /* @__PURE__ */ __name((matrix, pos) => parseFloat(matrix.split(", ")[pos]), "getPosFromMatrix");
var getTranslateFromMatrix = /* @__PURE__ */ __name((pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/u);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
}, "getTranslateFromMatrix");
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
__name(removeNonTranslationalTransform, "removeNonTranslationalTransform");
var positionalValues = {
  // Dimensions
  width: /* @__PURE__ */ __name(({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight), "width"),
  height: /* @__PURE__ */ __name(({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom), "height"),
  top: /* @__PURE__ */ __name((_bbox, { top }) => parseFloat(top), "top"),
  left: /* @__PURE__ */ __name((_bbox, { left }) => parseFloat(left), "left"),
  bottom: /* @__PURE__ */ __name(({ y }, { top }) => parseFloat(top) + (y.max - y.min), "bottom"),
  right: /* @__PURE__ */ __name(({ x }, { left }) => parseFloat(left) + (x.max - x.min), "right"),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;

// node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs
var toResolve = /* @__PURE__ */ new Set();
var isScheduled = false;
var anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a;
          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete());
  toResolve.clear();
}
__name(measureAllKeyframes, "measureAllKeyframes");
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
__name(readAllKeyframes, "readAllKeyframes");
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
__name(flushKeyframeResolvers, "flushKeyframeResolvers");
var _KeyframeResolver = class _KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.isComplete = false;
    this.isAsync = false;
    this.needsMeasurement = false;
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null) {
        if (i === 0) {
          const currentValue = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== void 0) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== void 0 && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === void 0) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue2 && currentValue === void 0) {
            motionValue2.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
        }
      }
    }
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete)
      this.scheduleResolve();
  }
};
__name(_KeyframeResolver, "KeyframeResolver");
var KeyframeResolver = _KeyframeResolver;

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = /* @__PURE__ */ __name((v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v), "isNumericalString");

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
var splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
__name(parseCSSVariable, "parseCSSVariable");
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
__name(getVariableValue, "getVariableValue");

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = /* @__PURE__ */ __name((v) => (type) => type.test(v), "testValueType");

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: /* @__PURE__ */ __name((v) => v === "auto", "test"),
  parse: /* @__PURE__ */ __name((v) => v, "parse")
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = /* @__PURE__ */ __name((v) => dimensionValueTypes.find(testValueType(v)), "findDimensionValueType");

// node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs
var _DOMKeyframesResolver = class _DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
};
__name(_DOMKeyframesResolver, "DOMKeyframesResolver");
var DOMKeyframesResolver = _DOMKeyframesResolver;

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = /* @__PURE__ */ __name((value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
}, "isAnimatable");

// node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] !== current)
      return true;
  }
}
__name(hasKeyframesChanged, "hasKeyframesChanged");
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
__name(canAnimate, "canAnimate");

// node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
var isNotNull = /* @__PURE__ */ __name((value) => value !== null, "isNotNull");
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === void 0 ? resolvedKeyframes[index] : finalKeyframe;
}
__name(getFinalKeyframe, "getFinalKeyframe");

// node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs
var MAX_RESOLVE_DELAY = 40;
var _BaseAnimation = class _BaseAnimation {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.createdAt = time.now();
    this.options = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    if (!this.resolvedAt)
      return this.createdAt;
    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes2, finalKeyframe) {
    this.resolvedAt = time.now();
    this.hasAttemptedResolve = true;
    const { name, type, velocity, delay: delay2, onComplete, onUpdate, isGenerator: isGenerator2 } = this.options;
    if (!isGenerator2 && !canAnimate(keyframes2, name, type, velocity)) {
      if (instantAnimationState.current || !delay2) {
        onUpdate && onUpdate(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete && onComplete();
        this.resolveFinishedPromise();
        return;
      } else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes2, finalKeyframe);
    if (resolvedAnimation === false)
      return;
    this._resolved = {
      keyframes: keyframes2,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.type = "keyframes";
    this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((resolve) => {
      this.resolveFinishedPromise = resolve;
    });
  }
};
__name(_BaseAnimation, "BaseAnimation");
var BaseAnimation = _BaseAnimation;

// node_modules/framer-motion/dist/es/utils/mix/number.mjs
var mixNumber = /* @__PURE__ */ __name((from, to, progress2) => {
  return from + (to - from) * progress2;
}, "mixNumber");

// node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
__name(hueToRgb, "hueToRgb");
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
__name(hslaToRgba, "hslaToRgba");

// node_modules/framer-motion/dist/es/utils/mix/immediate.mjs
function mixImmediate(a, b) {
  return (p) => p > 0 ? b : a;
}
__name(mixImmediate, "mixImmediate");

// node_modules/framer-motion/dist/es/utils/mix/color.mjs
var mixLinearColor = /* @__PURE__ */ __name((from, to, v) => {
  const fromExpo = from * from;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, "mixLinearColor");
var colorTypes = [hex, rgba, hsla];
var getColorType = /* @__PURE__ */ __name((v) => colorTypes.find((type) => type.test(v)), "getColorType");
function asRGBA(color2) {
  const type = getColorType(color2);
  warning(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
__name(asRGBA, "asRGBA");
var mixColor = /* @__PURE__ */ __name((from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to);
  }
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba.transform(blended);
  };
}, "mixColor");

// node_modules/framer-motion/dist/es/utils/pipe.mjs
var combineFunctions = /* @__PURE__ */ __name((a, b) => (v) => b(a(v)), "combineFunctions");
var pipe = /* @__PURE__ */ __name((...transformers) => transformers.reduce(combineFunctions), "pipe");

// node_modules/framer-motion/dist/es/utils/mix/visibility.mjs
var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p) => p <= 0 ? origin : target;
  } else {
    return (p) => p >= 1 ? target : origin;
  }
}
__name(mixVisibility, "mixVisibility");

// node_modules/framer-motion/dist/es/utils/mix/complex.mjs
function mixNumber2(a, b) {
  return (p) => mixNumber(a, b, p);
}
__name(mixNumber2, "mixNumber");
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber2;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
__name(getMixer, "getMixer");
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
__name(mixArray, "mixArray");
function mixObject(a, b) {
  const output = { ...a, ...b };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
__name(mixObject, "mixObject");
function matchOrder(origin, target) {
  var _a;
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
__name(matchOrder, "matchOrder");
var mixComplex = /* @__PURE__ */ __name((origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin, target);
  }
}, "mixComplex");

// node_modules/framer-motion/dist/es/utils/mix/index.mjs
function mix(from, to, p) {
  if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
    return mixNumber(from, to, p);
  }
  const mixer = getMixer(from);
  return mixer(from, to);
}
__name(mix, "mix");

// node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
__name(calcGeneratorVelocity, "calcGeneratorVelocity");

// node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs
var springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};

// node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs
var safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = /* @__PURE__ */ __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    }, "envelope");
    derivative = /* @__PURE__ */ __name((undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    }, "derivative");
  } else {
    envelope = /* @__PURE__ */ __name((undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    }, "envelope");
    derivative = /* @__PURE__ */ __name((undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    }, "derivative");
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
__name(findSpring, "findSpring");
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
__name(approximateRoot, "approximateRoot");
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
__name(calcAngularFreq, "calcAngularFreq");

// node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
__name(isSpringType, "isSpringType");
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root2 = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root2 * root2;
      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
__name(getSpringOptions, "getSpringOptions");
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = /* @__PURE__ */ __name((t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    }, "resolveSpring");
  } else if (dampingRatio === 1) {
    resolveSpring = /* @__PURE__ */ __name((t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t), "resolveSpring");
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = /* @__PURE__ */ __name((t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    }, "resolveSpring");
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: /* @__PURE__ */ __name((t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0;
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    }, "next"),
    toString: /* @__PURE__ */ __name(() => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    }, "toString")
  };
  return generator;
}
__name(spring, "spring");

// node_modules/framer-motion/dist/es/animation/generators/inertia.mjs
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = /* @__PURE__ */ __name((v) => min !== void 0 && v < min || max !== void 0 && v > max, "isOutOfBounds");
  const nearestBoundary = /* @__PURE__ */ __name((v) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  }, "nearestBoundary");
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = /* @__PURE__ */ __name((t) => -amplitude * Math.exp(-t / timeConstant), "calcDelta");
  const calcLatest = /* @__PURE__ */ __name((t) => target + calcDelta(t), "calcLatest");
  const applyFriction = /* @__PURE__ */ __name((t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  }, "applyFriction");
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = /* @__PURE__ */ __name((t) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  }, "checkCatchBoundary");
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: /* @__PURE__ */ __name((t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    }, "next")
  };
}
__name(inertia, "inertia");

// node_modules/framer-motion/dist/es/easing/ease.mjs
var easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
var easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
var easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);

// node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs
var isEasingArray = /* @__PURE__ */ __name((ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
}, "isEasingArray");

// node_modules/framer-motion/dist/es/easing/utils/map.mjs
var easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
var easingDefinitionToFunction = /* @__PURE__ */ __name((definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
}, "easingDefinitionToFunction");

// node_modules/framer-motion/dist/es/utils/interpolate.mjs
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
__name(createMixers, "createMixers");
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = /* @__PURE__ */ __name((v) => {
    if (isZeroDeltaRange && v < input[0])
      return output[0];
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1])
          break;
      }
    }
    const progressInRange = progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  }, "interpolator");
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}
__name(interpolate, "interpolate");

// node_modules/framer-motion/dist/es/utils/offsets/fill.mjs
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset.push(mixNumber(min, 1, offsetProgress));
  }
}
__name(fillOffset, "fillOffset");

// node_modules/framer-motion/dist/es/utils/offsets/default.mjs
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
__name(defaultOffset, "defaultOffset");

// node_modules/framer-motion/dist/es/utils/offsets/time.mjs
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
__name(convertOffsetToTimes, "convertOffsetToTimes");

// node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
__name(defaultEasing, "defaultEasing");
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: /* @__PURE__ */ __name((t) => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }, "next")
  };
}
__name(keyframes, "keyframes");

// node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs
var frameloopDriver = /* @__PURE__ */ __name((update) => {
  const passTimestamp = /* @__PURE__ */ __name(({ timestamp }) => update(timestamp), "passTimestamp");
  return {
    start: /* @__PURE__ */ __name(() => frame.update(passTimestamp, true), "start"),
    stop: /* @__PURE__ */ __name(() => cancelFrame(passTimestamp), "stop"),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: /* @__PURE__ */ __name(() => frameData.isProcessing ? frameData.timestamp : time.now(), "now")
  };
}, "frameloopDriver");

// node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs
var generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
var percentToProgress = /* @__PURE__ */ __name((percent2) => percent2 / 100, "percentToProgress");
var _MainThreadAnimation = class _MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    this.holdTime = null;
    this.cancelTime = null;
    this.currentTime = 0;
    this.playbackSpeed = 1;
    this.pendingPlayState = "running";
    this.startTime = null;
    this.state = "idle";
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      const { onStop } = this.options;
      onStop && onStop();
    };
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    const onResolved = /* @__PURE__ */ __name((resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), "onResolved");
    this.resolver = new KeyframeResolver$1(keyframes2, onResolved, name, motionValue2, element);
    this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten();
    if (this._resolved) {
      Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
  }
  initPlayback(keyframes$1) {
    const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = this.options;
    const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      if (false) {
        invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
      }
      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const { autoplay = true } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const { resolved } = this;
    if (!resolved) {
      const { keyframes: keyframes3 } = this.options;
      return { done: true, value: keyframes3[keyframes3.length - 1] };
    }
    const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes: keyframes2, calculatedDuration, totalDuration, resolvedDuration } = resolved;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2, repeat, repeatType, repeatDelay, onUpdate } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== void 0) {
      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const { resolved } = this;
    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, onPlay, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now2 = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    } else if (this.state === "finished") {
      this.startTime = now2;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const { onComplete } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(time2) {
    this.startTime = 0;
    return this.tick(time2, true);
  }
};
__name(_MainThreadAnimation, "MainThreadAnimation");
var MainThreadAnimation = _MainThreadAnimation;

// node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs
var acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);

// node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeInOut", times } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
__name(startWaapiAnimation, "startWaapiAnimation");

// node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs
var supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

// node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs
var sampleDelta = 10;
var maxDuration = 2e4;
function requiresPregeneratedKeyframes(options) {
  return isGenerator(options.type) || options.type === "spring" || !isWaapiSupportedEasing(options.ease);
}
__name(requiresPregeneratedKeyframes, "requiresPregeneratedKeyframes");
function pregenerateKeyframes(keyframes2, options) {
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes: keyframes2,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = { done: false, value: keyframes2[0] };
  const pregeneratedKeyframes = [];
  let t = 0;
  while (!state.done && t < maxDuration) {
    state = sampleAnimation.sample(t);
    pregeneratedKeyframes.push(state.value);
    t += sampleDelta;
  }
  return {
    times: void 0,
    keyframes: pregeneratedKeyframes,
    duration: t - sampleDelta,
    ease: "linear"
  };
}
__name(pregenerateKeyframes, "pregenerateKeyframes");
var unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
__name(isUnsupportedEase, "isUnsupportedEase");
var _AcceleratedAnimation = class _AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const { name, motionValue: motionValue2, element, keyframes: keyframes2 } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes2, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue2, element);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes2, finalKeyframe) {
    let { duration = 300, times, ease: ease2, type, motionValue: motionValue2, name, startTime } = this.options;
    if (!motionValue2.owner || !motionValue2.owner.current) {
      return false;
    }
    if (typeof ease2 === "string" && supportsLinearEasing() && isUnsupportedEase(ease2)) {
      ease2 = unsupportedEasingFunctions[ease2];
    }
    if (requiresPregeneratedKeyframes(this.options)) {
      const { onComplete, onUpdate, motionValue: motionValue3, element, ...options } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes2, options);
      keyframes2 = pregeneratedAnimation.keyframes;
      if (keyframes2.length === 1) {
        keyframes2[1] = keyframes2[0];
      }
      duration = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease2 = pregeneratedAnimation.ease;
      type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue2.owner.current, name, keyframes2, { ...this.options, duration, times, ease: ease2 });
    animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    if (this.pendingTimeline) {
      attachTimeline(animation, this.pendingTimeline);
      this.pendingTimeline = void 0;
    } else {
      animation.onfinish = () => {
        const { onComplete } = this.options;
        motionValue2.set(getFinalKeyframe(keyframes2, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation,
      duration,
      times,
      type,
      ease: ease2,
      keyframes: keyframes2
    };
  }
  get duration() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { duration } = resolved;
    return millisecondsToSeconds(duration);
  }
  get time() {
    const { resolved } = this;
    if (!resolved)
      return 0;
    const { animation } = resolved;
    return millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.currentTime = secondsToMilliseconds(newTime);
  }
  get speed() {
    const { resolved } = this;
    if (!resolved)
      return 1;
    const { animation } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const { resolved } = this;
    if (!resolved)
      return "idle";
    const { animation } = resolved;
    return animation.playState;
  }
  get startTime() {
    const { resolved } = this;
    if (!resolved)
      return null;
    const { animation } = resolved;
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const { resolved } = this;
      if (!resolved)
        return noop;
      const { animation } = resolved;
      attachTimeline(animation, timeline);
    }
    return noop;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    if (animation.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation.play();
  }
  pause() {
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation } = resolved;
    animation.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle")
      return;
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    const { resolved } = this;
    if (!resolved)
      return;
    const { animation, keyframes: keyframes2, duration, type, ease: ease2, times } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished") {
      return;
    }
    if (this.time) {
      const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes: keyframes2,
        duration,
        type,
        ease: ease2,
        times,
        isGenerator: true
      });
      const sampleTime = secondsToMilliseconds(this.time);
      motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const { onStop } = this.options;
    onStop && onStop();
    this.cancel();
  }
  complete() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.finish();
  }
  cancel() {
    const { resolved } = this;
    if (!resolved)
      return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
    if (!motionValue2 || !motionValue2.owner || !(motionValue2.owner.current instanceof HTMLElement)) {
      return false;
    }
    const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !transformTemplate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
};
__name(_AcceleratedAnimation, "AcceleratedAnimation");
var AcceleratedAnimation = _AcceleratedAnimation;

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
var criticallyDampedSpring = /* @__PURE__ */ __name((target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), "criticallyDampedSpring");
var keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
var ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
var getDefaultTransition = /* @__PURE__ */ __name((valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
}, "getDefaultTransition");

// node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
__name(isTransitionDefined, "isTransitionDefined");

// node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
var animateMotionValue = /* @__PURE__ */ __name((name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: /* @__PURE__ */ __name((v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    }, "onUpdate"),
    onComplete: /* @__PURE__ */ __name(() => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    }, "onComplete"),
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  if (options.duration) {
    options.duration = secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return new GroupPlaybackControls([]);
    }
  }
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
}, "animateMotionValue");

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
__name(shouldBlockAnimation, "shouldBlockAnimation");
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  var _a;
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations2.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}
__name(animateTarget, "animateTarget");

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
__name(animateVariant, "animateVariant");
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
__name(animateChildren, "animateChildren");
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
__name(sortByTreeOrder, "sortByTreeOrder");

// node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
__name(animateVisualElement, "animateVisualElement");

// node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs
var numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i = 0; i < numVariantProps; i++) {
    const name = variantProps[i];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
__name(getVariantContext, "getVariantContext");

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var reversePriorityOrder = [...variantPriorityOrder].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
__name(animateList, "animateList");
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = /* @__PURE__ */ __name((type) => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  }, "buildResolvedTypeValues");
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  __name(setAnimateFunction, "setAnimateFunction");
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = /* @__PURE__ */ __name((key) => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = false;
      }, "markToAnimate");
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== void 0 && next !== null) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue2 = visualElement.getValue(key);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  __name(animateChanges, "animateChanges");
  function setActive(type, isActive) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  __name(setActive, "setActive");
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: /* @__PURE__ */ __name(() => state, "getState"),
    reset: /* @__PURE__ */ __name(() => {
      state = createState();
      isInitialRender = true;
    }, "reset")
  };
}
__name(createAnimationState, "createAnimationState");
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
__name(checkVariantsDidChange, "checkVariantsDidChange");
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
__name(createTypeState, "createTypeState");
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
__name(createState, "createState");

// node_modules/framer-motion/dist/es/motion/features/Feature.mjs
var _Feature = class _Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {
  }
};
__name(_Feature, "Feature");
var Feature = _Feature;

// node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
var _AnimationFeature = class _AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    this.node.animationState.reset();
    (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
  }
};
__name(_AnimationFeature, "AnimationFeature");
var AnimationFeature = _AnimationFeature;

// node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
var id = 0;
var _ExitAnimationFeature = class _ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const { register } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
};
__name(_ExitAnimationFeature, "ExitAnimationFeature");
var ExitAnimationFeature = _ExitAnimationFeature;

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};

// node_modules/framer-motion/dist/es/events/add-dom-event.mjs
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
__name(addDomEvent, "addDomEvent");

// node_modules/framer-motion/dist/es/events/event-info.mjs
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
__name(extractEventInfo, "extractEventInfo");
var addPointerInfo = /* @__PURE__ */ __name((handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
}, "addPointerInfo");

// node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
__name(addPointerEvent, "addPointerEvent");

// node_modules/framer-motion/dist/es/utils/distance.mjs
var distance = /* @__PURE__ */ __name((a, b) => Math.abs(a - b), "distance");
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
__name(distance2D, "distance2D");

// node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
var _PanSession = class _PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
};
__name(_PanSession, "PanSession");
var PanSession = _PanSession;
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
__name(transformPoint, "transformPoint");
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
__name(subtractPoint, "subtractPoint");
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
__name(getPanInfo, "getPanInfo");
function startDevicePoint(history) {
  return history[0];
}
__name(startDevicePoint, "startDevicePoint");
function lastDevicePoint(history) {
  return history[history.length - 1];
}
__name(lastDevicePoint, "lastDevicePoint");
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
__name(getVelocity, "getVelocity");

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
var SCALE_PRECISION = 1e-4;
var SCALE_MIN = 1 - SCALE_PRECISION;
var SCALE_MAX = 1 + SCALE_PRECISION;
var TRANSLATE_PRECISION = 0.01;
var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
__name(calcLength, "calcLength");
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
__name(isNear, "isNear");
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
__name(calcAxisDelta, "calcAxisDelta");
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
__name(calcBoxDelta, "calcBoxDelta");
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
__name(calcRelativeAxis, "calcRelativeAxis");
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
__name(calcRelativeBox, "calcRelativeBox");
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
__name(calcRelativeAxisPosition, "calcRelativeAxisPosition");
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
__name(calcRelativePosition, "calcRelativePosition");

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mixNumber(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mixNumber(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
__name(applyConstraints, "applyConstraints");
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
__name(calcRelativeAxisConstraints, "calcRelativeAxisConstraints");
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
__name(calcRelativeConstraints, "calcRelativeConstraints");
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
__name(calcViewportAxisConstraints, "calcViewportAxisConstraints");
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
__name(calcViewportConstraints, "calcViewportConstraints");
function calcOrigin2(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
__name(calcOrigin2, "calcOrigin");
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
__name(rebaseAxisConstraints, "rebaseAxisConstraints");
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
__name(resolveDragElastic, "resolveDragElastic");
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
__name(resolveAxisElastic, "resolveAxisElastic");
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
__name(resolvePointElastic, "resolvePointElastic");

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = /* @__PURE__ */ __name(() => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), "createAxisDelta");
var createDelta = /* @__PURE__ */ __name(() => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), "createDelta");
var createAxis = /* @__PURE__ */ __name(() => ({ min: 0, max: 0 }), "createAxis");
var createBox = /* @__PURE__ */ __name(() => ({
  x: createAxis(),
  y: createAxis()
}), "createBox");

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
__name(eachAxis, "eachAxis");

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
__name(convertBoundingBoxToBox, "convertBoundingBoxToBox");
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
__name(convertBoxToBoundingBox, "convertBoxToBoundingBox");
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
__name(transformBoxPoints, "transformBoxPoints");

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
__name(isIdentityScale, "isIdentityScale");
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
__name(hasScale, "hasScale");
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
__name(hasTransform, "hasTransform");
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
__name(has2DTranslate, "has2DTranslate");
function is2DTranslate(value) {
  return value && value !== "0%";
}
__name(is2DTranslate, "is2DTranslate");

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
__name(scalePoint, "scalePoint");
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
__name(applyPointDelta, "applyPointDelta");
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(applyAxisDelta, "applyAxisDelta");
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
__name(applyBoxDelta, "applyBoxDelta");
var TREE_SCALE_SNAP_MIN = 0.999999999999;
var TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
__name(applyTreeDeltas, "applyTreeDeltas");
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
__name(translateAxis, "translateAxis");
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
__name(transformAxis, "transformAxis");
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
__name(transformBox, "transformBox");

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
__name(measureViewportBox, "measureViewportBox");
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
__name(measurePageBox, "measurePageBox");

// node_modules/framer-motion/dist/es/utils/get-context-window.mjs
var getContextWindow = /* @__PURE__ */ __name(({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
}, "getContextWindow");

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var _VisualElementDragControls = class _VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = /* @__PURE__ */ __name((event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    }, "onSessionStart");
    const onStart = /* @__PURE__ */ __name((event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    }, "onStart");
    const onMove = /* @__PURE__ */ __name((event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    }, "onMove");
    const onSessionEnd = /* @__PURE__ */ __name((event, info) => this.stop(event, info), "onSessionEnd");
    const resumeAnimation = /* @__PURE__ */ __name(() => eachAxis((axis) => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
    }), "resumeAnimation");
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mixNumber(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = /* @__PURE__ */ __name(() => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    }, "measureDragConstraints");
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
__name(_VisualElementDragControls, "VisualElementDragControls");
var VisualElementDragControls = _VisualElementDragControls;
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
__name(shouldDrag, "shouldDrag");
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
__name(getCurrentDirection, "getCurrentDirection");

// node_modules/framer-motion/dist/es/gestures/drag/index.mjs
var _DragGesture = class _DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};
__name(_DragGesture, "DragGesture");
var DragGesture = _DragGesture;

// node_modules/framer-motion/dist/es/gestures/pan/index.mjs
var asyncHandler = /* @__PURE__ */ __name((handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
}, "asyncHandler");
var _PanGesture = class _PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: /* @__PURE__ */ __name((event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }, "onEnd")
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};
__name(_PanGesture, "PanGesture");
var PanGesture = _PanGesture;

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
__name(pixelsToPercent, "pixelsToPercent");
var correctBorderRadius = {
  correct: /* @__PURE__ */ __name((latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }, "correct")
};

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var correctBoxShadow = {
  correct: /* @__PURE__ */ __name((latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }, "correct")
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var _MeasureLayoutWithContext = class _MeasureLayoutWithContext extends import_react23.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: /* @__PURE__ */ __name(() => this.safeToRemove(), "onExitComplete")
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
__name(_MeasureLayoutWithContext, "MeasureLayoutWithContext");
var MeasureLayoutWithContext = _MeasureLayoutWithContext;
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = (0, import_react23.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime5.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react23.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
__name(MeasureLayout, "MeasureLayout");
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/animation/animate/single-value.mjs
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
__name(animateSingleValue, "animateSingleValue");

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
__name(isSVGElement, "isSVGElement");

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = /* @__PURE__ */ __name((a, b) => a.depth - b.depth, "compareByDepth");

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var _FlatTree = class _FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};
__name(_FlatTree, "FlatTree");
var FlatTree = _FlatTree;

// node_modules/framer-motion/dist/es/utils/delay.mjs
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = /* @__PURE__ */ __name(({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  }, "checkElapsed");
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
__name(delay, "delay");

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = /* @__PURE__ */ __name((value) => typeof value === "string" ? parseFloat(value) : value, "asNumber");
var isPx = /* @__PURE__ */ __name((value) => typeof value === "number" || px.test(value), "isPx");
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
__name(mixValues, "mixValues");
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
__name(getRadius, "getRadius");
var easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
var easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(min, max, easing) {
  return (p) => {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress(min, max, p));
  };
}
__name(compress, "compress");

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
__name(copyAxisInto, "copyAxisInto");
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
__name(copyBoxInto, "copyBoxInto");
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
__name(copyAxisDeltaInto, "copyAxisDeltaInto");

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
__name(removePointDelta, "removePointDelta");
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
__name(removeAxisDelta, "removeAxisDelta");
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
__name(removeAxisTransforms, "removeAxisTransforms");
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
__name(removeBoxTransforms, "removeBoxTransforms");

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
__name(isAxisDeltaZero, "isAxisDeltaZero");
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
__name(isDeltaZero, "isDeltaZero");
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
__name(axisEquals, "axisEquals");
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
__name(boxEquals, "boxEquals");
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
__name(axisEqualsRounded, "axisEqualsRounded");
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
__name(boxEqualsRounded, "boxEqualsRounded");
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
__name(aspectRatio, "aspectRatio");
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
__name(axisDeltaEquals, "axisDeltaEquals");

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var _NodeStack = class _NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};
__name(_NodeStack, "NodeStack");
var NodeStack = _NodeStack;

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate)
      transform += `rotate(${rotate}deg) `;
    if (rotateX)
      transform += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform += `skewX(${skewX}deg) `;
    if (skewY)
      transform += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
__name(buildProjectionTransform, "buildProjectionTransform");

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
var isDebug = typeof window !== "undefined" && window.MotionDebug !== void 0;
var transformAxes = ["", "X", "Y", "Z"];
var hiddenVisibility = { visibility: "hidden" };
var animationTarget = 1e3;
var id2 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
__name(resetDistortingTransform, "resetDistortingTransform");
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
__name(cancelTreeOptimisedTransformAnimations, "cancelTreeOptimisedTransformAnimations");
function createProjectionNode2({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  var _a;
  return _a = class {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (isDebug) {
          metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (isDebug) {
          window.MotionDebug.record(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = /* @__PURE__ */ __name(() => this.root.updateBlockedByResize = false, "resizeUnblockUpdate");
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a2;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a2 = this.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a2;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a2 = this.scroll) === null || _a2 === void 0 ? void 0 : _a2.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a2;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (isDebug) {
        metrics.resolvedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a2;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (isDebug) {
        metrics.recalculatedProjection++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a2;
      (_a2 = this.options.visualElement) === null || _a2 === void 0 ? void 0 : _a2.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: /* @__PURE__ */ __name((latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          }, "onUpdate"),
          onComplete: /* @__PURE__ */ __name(() => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }, "onComplete")
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? ((_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.lead) || this : this;
    }
    getPrevLead() {
      var _a2;
      const { layoutId } = this.options;
      return layoutId ? (_a2 = this.getStack()) === null || _a2 === void 0 ? void 0 : _a2.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a2, _b;
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x, y } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? (_b = (_a2 = valuesToRender.opacity) !== null && _a2 !== void 0 ? _a2 : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a2;
        return (_a2 = node.currentAnimation) === null || _a2 === void 0 ? void 0 : _a2.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  }, __name(_a, "ProjectionNode"), _a;
}
__name(createProjectionNode2, "createProjectionNode");
function updateLayout(node) {
  node.updateLayout();
}
__name(updateLayout, "updateLayout");
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
__name(notifyLayoutUpdate, "notifyLayoutUpdate");
function propagateDirtyNodes(node) {
  if (isDebug) {
    metrics.totalNodes++;
  }
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
__name(propagateDirtyNodes, "propagateDirtyNodes");
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
__name(cleanDirtyNodes, "cleanDirtyNodes");
function clearSnapshot(node) {
  node.clearSnapshot();
}
__name(clearSnapshot, "clearSnapshot");
function clearMeasurements(node) {
  node.clearMeasurements();
}
__name(clearMeasurements, "clearMeasurements");
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
__name(clearIsLayoutDirty, "clearIsLayoutDirty");
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
__name(resetTransformStyle, "resetTransformStyle");
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
__name(finishAnimation, "finishAnimation");
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
__name(resolveTargetDelta, "resolveTargetDelta");
function calcProjection(node) {
  node.calcProjection();
}
__name(calcProjection, "calcProjection");
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
__name(resetSkewAndRotation, "resetSkewAndRotation");
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
__name(removeLeadSnapshots, "removeLeadSnapshots");
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber(delta.translate, 0, p);
  output.scale = mixNumber(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
__name(mixAxisDelta, "mixAxisDelta");
function mixAxis(output, from, to, p) {
  output.min = mixNumber(from.min, to.min, p);
  output.max = mixNumber(from.max, to.max, p);
}
__name(mixAxis, "mixAxis");
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
__name(mixBox, "mixBox");
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
__name(hasOpacityCrossfade, "hasOpacityCrossfade");
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
var userAgentContains = /* @__PURE__ */ __name((string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), "userAgentContains");
var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
__name(roundAxis, "roundAxis");
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
__name(roundBox, "roundBox");
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
__name(shouldAnimatePositionOnly, "shouldAnimatePositionOnly");
function checkNodeWasScrollRoot(node) {
  var _a;
  return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
}
__name(checkNodeWasScrollRoot, "checkNodeWasScrollRoot");

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode2({
  attachResizeListener: /* @__PURE__ */ __name((ref, notify) => addDomEvent(ref, "resize", notify), "attachResizeListener"),
  measureScroll: /* @__PURE__ */ __name(() => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }), "measureScroll"),
  checkIsScrollRoot: /* @__PURE__ */ __name(() => true, "checkIsScrollRoot")
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode2({
  measureScroll: /* @__PURE__ */ __name((instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }), "measureScroll"),
  defaultParent: /* @__PURE__ */ __name(() => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  }, "defaultParent"),
  resetTransform: /* @__PURE__ */ __name((instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  }, "resetTransform"),
  checkIsScrollRoot: /* @__PURE__ */ __name((instance) => Boolean(window.getComputedStyle(instance).position === "fixed"), "checkIsScrollRoot")
});

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/gestures/hover.mjs
function handleHoverEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
__name(handleHoverEvent, "handleHoverEvent");
var _HoverGesture = class _HoverGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
};
__name(_HoverGesture, "HoverGesture");
var HoverGesture = _HoverGesture;

// node_modules/framer-motion/dist/es/gestures/focus.mjs
var _FocusGesture = class _FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};
__name(_FocusGesture, "FocusGesture");
var FocusGesture = _FocusGesture;

// node_modules/framer-motion/dist/es/gestures/press.mjs
function handlePressEvent(node, event, lifecycle) {
  const { props } = node;
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
__name(handlePressEvent, "handlePressEvent");
var _PressGesture = class _PressGesture extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
};
__name(_PressGesture, "PressGesture");
var PressGesture = _PressGesture;

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = /* @__PURE__ */ __name((entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, "fireObserverCallback");
var fireAllObserverCallbacks = /* @__PURE__ */ __name((entries) => {
  entries.forEach(fireObserverCallback);
}, "fireAllObserverCallbacks");
function initIntersectionObserver({ root: root2, ...options }) {
  const lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root: root2, ...options });
  }
  return rootObservers[key];
}
__name(initIntersectionObserver, "initIntersectionObserver");
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
__name(observeIntersection, "observeIntersection");

// node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
var thresholdNames = {
  some: 0,
  all: 1
};
var _InViewFeature = class _InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root: root2, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root2 ? root2.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = /* @__PURE__ */ __name((entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    }, "onIntersectionUpdate");
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
__name(_InViewFeature, "InViewFeature");
var InViewFeature = _InViewFeature;
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}
__name(hasViewportOptionChanged, "hasViewportOptionChanged");

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout.mjs
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var import_react24 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
var prefersReducedMotion = { current: null };
var hasReducedMotionListener = { current: false };

// node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = /* @__PURE__ */ __name(() => prefersReducedMotion.current = motionMediaQuery.matches, "setReducedMotionPreferences");
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
__name(initPrefersReducedMotion, "initPrefersReducedMotion");

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = [...dimensionValueTypes, color, complex];
var findValueType = /* @__PURE__ */ __name((v) => valueTypes.find(testValueType(v)), "findValueType");

// node_modules/framer-motion/dist/es/render/store.mjs
var visualElementStore = /* @__PURE__ */ new WeakMap();

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (false) {
        warnOnce(nextValue.version === "11.18.2", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
__name(updateMotionValuesFromProps, "updateMotionValuesFromProps");

// node_modules/framer-motion/dist/es/render/VisualElement.mjs
var propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
var _VisualElement = class _VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState, onUpdate } = visualState;
    this.onUpdate = onUpdate;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (false) {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    }
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
    this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a;
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone2(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
};
__name(_VisualElement, "VisualElement");
var VisualElement = _VisualElement;

// node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
var _DOMVisualElement = class _DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
};
__name(_DOMVisualElement, "DOMVisualElement");
var DOMVisualElement = _DOMVisualElement;

// node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
function getComputedStyle(element) {
  return window.getComputedStyle(element);
}
__name(getComputedStyle, "getComputedStyle");
var _HTMLVisualElement = class _HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
};
__name(_HTMLVisualElement, "HTMLVisualElement");
var HTMLVisualElement = _HTMLVisualElement;

// node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
var _SVGVisualElement = class _SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
};
__name(_SVGVisualElement, "SVGVisualElement");
var SVGVisualElement = _SVGVisualElement;

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = /* @__PURE__ */ __name((Component3, options) => {
  return isSVGComponent(Component3) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component3 !== import_react24.Fragment
  });
}, "createDomVisualElement");

// node_modules/framer-motion/dist/es/render/components/motion/create.mjs
var createMotionComponent = /* @__PURE__ */ createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);

// node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs
var motion = /* @__PURE__ */ createDOMMotionComponentProxy(createMotionComponent);

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var import_react26 = __toESM(require_react());

// node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = /* @__PURE__ */ __name((string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), "toKebabCase");
var mergeClasses = /* @__PURE__ */ __name((...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim(), "mergeClasses");

// node_modules/lucide-react/dist/esm/Icon.js
var import_react25 = __toESM(require_react());

// node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// node_modules/lucide-react/dist/esm/Icon.js
var Icon = (0, import_react25.forwardRef)(
  ({
    color: color2 = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return (0, import_react25.createElement)(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size,
        height: size,
        stroke: color2,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => (0, import_react25.createElement)(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = /* @__PURE__ */ __name((iconName, iconNode) => {
  const Component3 = (0, import_react26.forwardRef)(
    ({ className, ...props }, ref) => (0, import_react26.createElement)(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component3.displayName = `${iconName}`;
  return Component3;
}, "createLucideIcon");

// node_modules/lucide-react/dist/esm/icons/binary.js
var Binary = createLucideIcon("Binary", [
  ["rect", { x: "14", y: "14", width: "4", height: "6", rx: "2", key: "p02svl" }],
  ["rect", { x: "6", y: "4", width: "4", height: "6", rx: "2", key: "xm4xkj" }],
  ["path", { d: "M6 20h4", key: "1i6q5t" }],
  ["path", { d: "M14 10h4", key: "ru81e7" }],
  ["path", { d: "M6 14h2v6", key: "16z9wg" }],
  ["path", { d: "M14 4h2v6", key: "1idq9u" }]
]);

// node_modules/lucide-react/dist/esm/icons/box.js
var Box = createLucideIcon("Box", [
  [
    "path",
    {
      d: "M21 8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16Z",
      key: "hh9hay"
    }
  ],
  ["path", { d: "m3.3 7 8.7 5 8.7-5", key: "g66t2b" }],
  ["path", { d: "M12 22V12", key: "d0xqtd" }]
]);

// node_modules/lucide-react/dist/esm/icons/chevron-down.js
var ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);

// node_modules/lucide-react/dist/esm/icons/chevron-right.js
var ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);

// node_modules/lucide-react/dist/esm/icons/circle-alert.js
var CircleAlert = createLucideIcon("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);

// node_modules/lucide-react/dist/esm/icons/circle-check-big.js
var CircleCheckBig = createLucideIcon("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);

// node_modules/lucide-react/dist/esm/icons/hash.js
var Hash = createLucideIcon("Hash", [
  ["line", { x1: "4", x2: "20", y1: "9", y2: "9", key: "4lhtct" }],
  ["line", { x1: "4", x2: "20", y1: "15", y2: "15", key: "vyu0kd" }],
  ["line", { x1: "10", x2: "8", y1: "3", y2: "21", key: "1ggp8o" }],
  ["line", { x1: "16", x2: "14", y1: "3", y2: "21", key: "weycgp" }]
]);

// node_modules/lucide-react/dist/esm/icons/loader-circle.js
var LoaderCircle = createLucideIcon("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);

// node_modules/lucide-react/dist/esm/icons/pause.js
var Pause = createLucideIcon("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);

// node_modules/lucide-react/dist/esm/icons/play.js
var Play = createLucideIcon("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);

// node_modules/lucide-react/dist/esm/icons/rotate-ccw.js
var RotateCcw = createLucideIcon("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);

// node_modules/lucide-react/dist/esm/icons/shuffle.js
var Shuffle = createLucideIcon("Shuffle", [
  ["path", { d: "m18 14 4 4-4 4", key: "10pe0f" }],
  ["path", { d: "m18 2 4 4-4 4", key: "pucp1d" }],
  ["path", { d: "M2 18h1.973a4 4 0 0 0 3.3-1.7l5.454-8.6a4 4 0 0 1 3.3-1.7H22", key: "1ailkh" }],
  ["path", { d: "M2 6h1.972a4 4 0 0 1 3.6 2.2", key: "km57vx" }],
  ["path", { d: "M22 18h-6.041a4 4 0 0 1-3.3-1.8l-.359-.45", key: "os18l9" }]
]);

// node_modules/lucide-react/dist/esm/icons/zap.js
var Zap = createLucideIcon("Zap", [
  [
    "path",
    {
      d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
      key: "1xq2db"
    }
  ]
]);

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
__name(r, "r");
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
__name(clsx, "clsx");

// node_modules/tailwind-merge/dist/bundle-mjs.mjs
var CLASS_PART_SEPARATOR = "-";
var createClassGroupUtils = /* @__PURE__ */ __name((config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = /* @__PURE__ */ __name((className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }, "getClassGroupId");
  const getConflictingClassGroupIds = /* @__PURE__ */ __name((classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  }, "getConflictingClassGroupIds");
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}, "createClassGroupUtils");
var getGroupRecursive = /* @__PURE__ */ __name((classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
}, "getGroupRecursive");
var arbitraryPropertyRegex = /^\[(.+)\]$/;
var getGroupIdForArbitraryProperty = /* @__PURE__ */ __name((className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}, "getGroupIdForArbitraryProperty");
var createClassMap = /* @__PURE__ */ __name((config) => {
  const {
    theme,
    prefix
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}, "createClassMap");
var processClassesRecursively = /* @__PURE__ */ __name((classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}, "processClassesRecursively");
var getPart = /* @__PURE__ */ __name((classPartObject, path) => {
  let currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}, "getPart");
var isThemeGetter = /* @__PURE__ */ __name((func) => func.isThemeGetter, "isThemeGetter");
var getPrefixedClassGroupEntries = /* @__PURE__ */ __name((classGroupEntries, prefix) => {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}, "getPrefixedClassGroupEntries");
var createLruCache = /* @__PURE__ */ __name((maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: /* @__PURE__ */ __name(() => void 0, "get"),
      set: /* @__PURE__ */ __name(() => {
      }, "set")
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = /* @__PURE__ */ __name((key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }, "update");
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}, "createLruCache");
var IMPORTANT_MODIFIER = "!";
var createParseClassName = /* @__PURE__ */ __name((config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = /* @__PURE__ */ __name((className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index = 0; index < className.length; index++) {
      let currentCharacter = className[index];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index, index + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index));
          modifierStart = index + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  }, "parseClassName");
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
}, "createParseClassName");
var sortModifiers = /* @__PURE__ */ __name((modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
}, "sortModifiers");
var createConfigUtils = /* @__PURE__ */ __name((config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
}), "createConfigUtils");
var SPLIT_CLASSES_REGEX = /\s+/;
var mergeClassList = /* @__PURE__ */ __name((classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index = classNames.length - 1; index >= 0; index -= 1) {
    const originalClassName = classNames[index];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i = 0; i < conflictGroups.length; ++i) {
      const group = conflictGroups[i];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
}, "mergeClassList");
function twJoin() {
  let index = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index < arguments.length) {
    if (argument = arguments[index++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
__name(twJoin, "twJoin");
var toValue = /* @__PURE__ */ __name((mix2) => {
  if (typeof mix2 === "string") {
    return mix2;
  }
  let resolvedValue;
  let string = "";
  for (let k = 0; k < mix2.length; k++) {
    if (mix2[k]) {
      if (resolvedValue = toValue(mix2[k])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}, "toValue");
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  __name(initTailwindMerge, "initTailwindMerge");
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  __name(tailwindMerge, "tailwindMerge");
  return /* @__PURE__ */ __name(function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  }, "callTailwindMerge");
}
__name(createTailwindMerge, "createTailwindMerge");
var fromTheme = /* @__PURE__ */ __name((key) => {
  const themeGetter = /* @__PURE__ */ __name((theme) => theme[key] || [], "themeGetter");
  themeGetter.isThemeGetter = true;
  return themeGetter;
}, "fromTheme");
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var isLength = /* @__PURE__ */ __name((value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value), "isLength");
var isArbitraryLength = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "length", isLengthOnly), "isArbitraryLength");
var isNumber = /* @__PURE__ */ __name((value) => Boolean(value) && !Number.isNaN(Number(value)), "isNumber");
var isArbitraryNumber = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "number", isNumber), "isArbitraryNumber");
var isInteger = /* @__PURE__ */ __name((value) => Boolean(value) && Number.isInteger(Number(value)), "isInteger");
var isPercent = /* @__PURE__ */ __name((value) => value.endsWith("%") && isNumber(value.slice(0, -1)), "isPercent");
var isArbitraryValue = /* @__PURE__ */ __name((value) => arbitraryValueRegex.test(value), "isArbitraryValue");
var isTshirtSize = /* @__PURE__ */ __name((value) => tshirtUnitRegex.test(value), "isTshirtSize");
var sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var isArbitrarySize = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, sizeLabels, isNever), "isArbitrarySize");
var isArbitraryPosition = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "position", isNever), "isArbitraryPosition");
var imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
var isArbitraryImage = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, imageLabels, isImage), "isArbitraryImage");
var isArbitraryShadow = /* @__PURE__ */ __name((value) => getIsArbitraryValue(value, "", isShadow), "isArbitraryShadow");
var isAny = /* @__PURE__ */ __name(() => true, "isAny");
var getIsArbitraryValue = /* @__PURE__ */ __name((value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
}, "getIsArbitraryValue");
var isLengthOnly = /* @__PURE__ */ __name((value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
), "isLengthOnly");
var isNever = /* @__PURE__ */ __name(() => false, "isNever");
var isShadow = /* @__PURE__ */ __name((value) => shadowRegex.test(value), "isShadow");
var isImage = /* @__PURE__ */ __name((value) => imageRegex.test(value), "isImage");
var getDefaultConfig = /* @__PURE__ */ __name(() => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale2 = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = /* @__PURE__ */ __name(() => ["auto", "contain", "none"], "getOverscroll");
  const getOverflow = /* @__PURE__ */ __name(() => ["auto", "hidden", "clip", "visible", "scroll"], "getOverflow");
  const getSpacingWithAutoAndArbitrary = /* @__PURE__ */ __name(() => ["auto", isArbitraryValue, spacing], "getSpacingWithAutoAndArbitrary");
  const getSpacingWithArbitrary = /* @__PURE__ */ __name(() => [isArbitraryValue, spacing], "getSpacingWithArbitrary");
  const getLengthWithEmptyAndArbitrary = /* @__PURE__ */ __name(() => ["", isLength, isArbitraryLength], "getLengthWithEmptyAndArbitrary");
  const getNumberWithAutoAndArbitrary = /* @__PURE__ */ __name(() => ["auto", isNumber, isArbitraryValue], "getNumberWithAutoAndArbitrary");
  const getPositions = /* @__PURE__ */ __name(() => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], "getPositions");
  const getLineStyles = /* @__PURE__ */ __name(() => ["solid", "dashed", "dotted", "double", "none"], "getLineStyles");
  const getBlendModes = /* @__PURE__ */ __name(() => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], "getBlendModes");
  const getAlign = /* @__PURE__ */ __name(() => ["start", "end", "center", "between", "around", "evenly", "stretch"], "getAlign");
  const getZeroAndEmpty = /* @__PURE__ */ __name(() => ["", "0", isArbitraryValue], "getZeroAndEmpty");
  const getBreaks = /* @__PURE__ */ __name(() => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], "getBreaks");
  const getNumberAndArbitrary = /* @__PURE__ */ __name(() => [isNumber, isArbitraryValue], "getNumberAndArbitrary");
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale2]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale2]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale2]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, "getDefaultConfig");
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);

// lib/utils.ts
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
__name(cn, "cn");

// kktp/engine/kaspa/kas-wasm/kaspa.js
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
__name(getObject, "getObject");
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length) heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
__name(addHeapObject, "addHeapObject");
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_export_0(addHeapObject(e));
  }
}
__name(handleError, "handleError");
var WASM_VECTOR_LEN = 0;
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
__name(getUint8ArrayMemory0, "getUint8ArrayMemory0");
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : {
  encode: /* @__PURE__ */ __name(() => {
    throw Error("TextEncoder not available");
  }, "encode")
};
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view2) {
  return cachedTextEncoder.encodeInto(arg, view2);
} : function(arg, view2) {
  const buf = cachedTextEncoder.encode(arg);
  view2.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127) break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view2 = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view2);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
__name(passStringToWasm0, "passStringToWasm0");
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
__name(getDataViewMemory0, "getDataViewMemory0");
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : {
  decode: /* @__PURE__ */ __name(() => {
    throw Error("TextDecoder not available");
  }, "decode")
};
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(
    getUint8ArrayMemory0().subarray(ptr, ptr + len)
  );
}
__name(getStringFromWasm0, "getStringFromWasm0");
function isLikeNone(x) {
  return x === void 0 || x === null;
}
__name(isLikeNone, "isLikeNone");
function dropObject(idx) {
  if (idx < 132) return;
  heap[idx] = heap_next;
  heap_next = idx;
}
__name(dropObject, "dropObject");
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
__name(takeObject, "takeObject");
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
__name(getArrayU8FromWasm0, "getArrayU8FromWasm0");
var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((state) => {
  wasm.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
});
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name((...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_4.get(state.dtor)(a, state.b);
        CLOSURE_DTORS.unregister(state);
      } else {
        state.a = a;
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
__name(makeMutClosure, "makeMutClosure");
function makeClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = /* @__PURE__ */ __name((...args) => {
    state.cnt++;
    try {
      return f(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_4.get(state.dtor)(state.a, state.b);
        state.a = 0;
        CLOSURE_DTORS.unregister(state);
      }
    }
  }, "real");
  real.original = state;
  CLOSURE_DTORS.register(real, state, state);
  return real;
}
__name(makeClosure, "makeClosure");
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches && builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
__name(debugString, "debugString");
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
}
__name(_assertClass, "_assertClass");
var stack_pointer = 128;
function addBorrowedObject(obj) {
  if (stack_pointer == 1) throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
__name(addBorrowedObject, "addBorrowedObject");
function decryptXChaCha20Poly1305(base64string, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(
      base64string,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(
      password,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    wasm.decryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
__name(decryptXChaCha20Poly1305, "decryptXChaCha20Poly1305");
function encryptXChaCha20Poly1305(plainText, password) {
  let deferred4_0;
  let deferred4_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(
      plainText,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(
      password,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    wasm.encryptXChaCha20Poly1305(retptr, ptr0, len0, ptr1, len1);
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr3 = r0;
    var len3 = r1;
    if (r3) {
      ptr3 = 0;
      len3 = 0;
      throw takeObject(r2);
    }
    deferred4_0 = ptr3;
    deferred4_1 = len3;
    return getStringFromWasm0(ptr3, len3);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
  }
}
__name(encryptXChaCha20Poly1305, "encryptXChaCha20Poly1305");
function sompiToKaspaString(sompi) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.sompiToKaspaString(retptr, addHeapObject(sompi));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0;
      len1 = 0;
      throw takeObject(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0(ptr1, len1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
  }
}
__name(sompiToKaspaString, "sompiToKaspaString");
function kaspaToSompi(kaspa) {
  const ptr0 = passStringToWasm0(
    kaspa,
    wasm.__wbindgen_export_1,
    wasm.__wbindgen_export_2
  );
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.kaspaToSompi(ptr0, len0);
  return takeObject(ret);
}
__name(kaspaToSompi, "kaspaToSompi");
function createTransactions(settings) {
  const ret = wasm.createTransactions(addHeapObject(settings));
  return takeObject(ret);
}
__name(createTransactions, "createTransactions");
function verifyMessage(value) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.verifyMessage(retptr, addHeapObject(value));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return r0 !== 0;
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
__name(verifyMessage, "verifyMessage");
function signMessage(value) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.signMessage(retptr, addHeapObject(value));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return takeObject(r0);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
__name(signMessage, "signMessage");
function __wbg_adapter_66(arg0, arg1) {
  wasm.__wbindgen_export_5(arg0, arg1);
}
__name(__wbg_adapter_66, "__wbg_adapter_66");
function __wbg_adapter_69(arg0, arg1, arg2) {
  wasm.__wbindgen_export_6(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_69, "__wbg_adapter_69");
function __wbg_adapter_72(arg0, arg1) {
  wasm.__wbindgen_export_7(arg0, arg1);
}
__name(__wbg_adapter_72, "__wbg_adapter_72");
function __wbg_adapter_75(arg0, arg1, arg2) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    wasm.__wbindgen_export_8(retptr, arg0, arg1, addHeapObject(arg2));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    if (r1) {
      throw takeObject(r0);
    }
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
  }
}
__name(__wbg_adapter_75, "__wbg_adapter_75");
function __wbg_adapter_78(arg0, arg1, arg2) {
  wasm.__wbindgen_export_9(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_78, "__wbg_adapter_78");
function __wbg_adapter_81(arg0, arg1, arg2, arg3) {
  const ret = wasm.__wbindgen_export_10(arg0, arg1, addHeapObject(arg2), arg3);
  return takeObject(ret);
}
__name(__wbg_adapter_81, "__wbg_adapter_81");
function __wbg_adapter_84(arg0, arg1, arg2) {
  wasm.__wbindgen_export_11(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_84, "__wbg_adapter_84");
function __wbg_adapter_87(arg0, arg1, arg2) {
  wasm.__wbindgen_export_11(arg0, arg1, arg2);
}
__name(__wbg_adapter_87, "__wbg_adapter_87");
function __wbg_adapter_90(arg0, arg1, arg2) {
  wasm.__wbindgen_export_12(arg0, arg1, addHeapObject(arg2));
}
__name(__wbg_adapter_90, "__wbg_adapter_90");
function __wbg_adapter_199(arg0, arg1, arg2, arg3) {
  wasm.__wbindgen_export_13(
    arg0,
    arg1,
    addHeapObject(arg2),
    addHeapObject(arg3)
  );
}
__name(__wbg_adapter_199, "__wbg_adapter_199");
var AccountsDiscoveryKind = Object.freeze({
  Bip44: 0,
  0: "Bip44"
});
var AddressVersion = Object.freeze({
  /**
   * PubKey addresses always have the version byte set to 0
   */
  PubKey: 0,
  0: "PubKey",
  /**
   * PubKey ECDSA addresses always have the version byte set to 1
   */
  PubKeyECDSA: 1,
  1: "PubKeyECDSA",
  /**
   * ScriptHash addresses always have the version byte set to 8
   */
  ScriptHash: 8,
  8: "ScriptHash"
});
var CommitRevealAddressKind = Object.freeze({
  Receive: 0,
  0: "Receive",
  Change: 1,
  1: "Change"
});
var ConnectStrategy = Object.freeze({
  /**
   * Continuously attempt to connect to the server. This behavior will
   * block `connect()` function until the connection is established.
   */
  Retry: 0,
  0: "Retry",
  /**
   * Causes `connect()` to return immediately if the first-time connection
   * has failed.
   */
  Fallback: 1,
  1: "Fallback"
});
var Encoding = Object.freeze({
  Borsh: 0,
  0: "Borsh",
  SerdeJson: 1,
  1: "SerdeJson"
});
var FeeSource = Object.freeze({
  SenderPays: 0,
  0: "SenderPays",
  ReceiverPays: 1,
  1: "ReceiverPays"
});
var Language = Object.freeze({
  /**
   * English is presently the only supported language
   */
  English: 0,
  0: "English"
});
var NetworkType = Object.freeze({
  Mainnet: 0,
  0: "Mainnet",
  Testnet: 1,
  1: "Testnet",
  Devnet: 2,
  2: "Devnet",
  Simnet: 3,
  3: "Simnet"
});
var NewAddressKind = Object.freeze({
  Receive: 0,
  0: "Receive",
  Change: 1,
  1: "Change"
});
var Opcodes = Object.freeze({
  OpFalse: 0,
  0: "OpFalse",
  OpData1: 1,
  1: "OpData1",
  OpData2: 2,
  2: "OpData2",
  OpData3: 3,
  3: "OpData3",
  OpData4: 4,
  4: "OpData4",
  OpData5: 5,
  5: "OpData5",
  OpData6: 6,
  6: "OpData6",
  OpData7: 7,
  7: "OpData7",
  OpData8: 8,
  8: "OpData8",
  OpData9: 9,
  9: "OpData9",
  OpData10: 10,
  10: "OpData10",
  OpData11: 11,
  11: "OpData11",
  OpData12: 12,
  12: "OpData12",
  OpData13: 13,
  13: "OpData13",
  OpData14: 14,
  14: "OpData14",
  OpData15: 15,
  15: "OpData15",
  OpData16: 16,
  16: "OpData16",
  OpData17: 17,
  17: "OpData17",
  OpData18: 18,
  18: "OpData18",
  OpData19: 19,
  19: "OpData19",
  OpData20: 20,
  20: "OpData20",
  OpData21: 21,
  21: "OpData21",
  OpData22: 22,
  22: "OpData22",
  OpData23: 23,
  23: "OpData23",
  OpData24: 24,
  24: "OpData24",
  OpData25: 25,
  25: "OpData25",
  OpData26: 26,
  26: "OpData26",
  OpData27: 27,
  27: "OpData27",
  OpData28: 28,
  28: "OpData28",
  OpData29: 29,
  29: "OpData29",
  OpData30: 30,
  30: "OpData30",
  OpData31: 31,
  31: "OpData31",
  OpData32: 32,
  32: "OpData32",
  OpData33: 33,
  33: "OpData33",
  OpData34: 34,
  34: "OpData34",
  OpData35: 35,
  35: "OpData35",
  OpData36: 36,
  36: "OpData36",
  OpData37: 37,
  37: "OpData37",
  OpData38: 38,
  38: "OpData38",
  OpData39: 39,
  39: "OpData39",
  OpData40: 40,
  40: "OpData40",
  OpData41: 41,
  41: "OpData41",
  OpData42: 42,
  42: "OpData42",
  OpData43: 43,
  43: "OpData43",
  OpData44: 44,
  44: "OpData44",
  OpData45: 45,
  45: "OpData45",
  OpData46: 46,
  46: "OpData46",
  OpData47: 47,
  47: "OpData47",
  OpData48: 48,
  48: "OpData48",
  OpData49: 49,
  49: "OpData49",
  OpData50: 50,
  50: "OpData50",
  OpData51: 51,
  51: "OpData51",
  OpData52: 52,
  52: "OpData52",
  OpData53: 53,
  53: "OpData53",
  OpData54: 54,
  54: "OpData54",
  OpData55: 55,
  55: "OpData55",
  OpData56: 56,
  56: "OpData56",
  OpData57: 57,
  57: "OpData57",
  OpData58: 58,
  58: "OpData58",
  OpData59: 59,
  59: "OpData59",
  OpData60: 60,
  60: "OpData60",
  OpData61: 61,
  61: "OpData61",
  OpData62: 62,
  62: "OpData62",
  OpData63: 63,
  63: "OpData63",
  OpData64: 64,
  64: "OpData64",
  OpData65: 65,
  65: "OpData65",
  OpData66: 66,
  66: "OpData66",
  OpData67: 67,
  67: "OpData67",
  OpData68: 68,
  68: "OpData68",
  OpData69: 69,
  69: "OpData69",
  OpData70: 70,
  70: "OpData70",
  OpData71: 71,
  71: "OpData71",
  OpData72: 72,
  72: "OpData72",
  OpData73: 73,
  73: "OpData73",
  OpData74: 74,
  74: "OpData74",
  OpData75: 75,
  75: "OpData75",
  OpPushData1: 76,
  76: "OpPushData1",
  OpPushData2: 77,
  77: "OpPushData2",
  OpPushData4: 78,
  78: "OpPushData4",
  Op1Negate: 79,
  79: "Op1Negate",
  OpReserved: 80,
  80: "OpReserved",
  OpTrue: 81,
  81: "OpTrue",
  Op2: 82,
  82: "Op2",
  Op3: 83,
  83: "Op3",
  Op4: 84,
  84: "Op4",
  Op5: 85,
  85: "Op5",
  Op6: 86,
  86: "Op6",
  Op7: 87,
  87: "Op7",
  Op8: 88,
  88: "Op8",
  Op9: 89,
  89: "Op9",
  Op10: 90,
  90: "Op10",
  Op11: 91,
  91: "Op11",
  Op12: 92,
  92: "Op12",
  Op13: 93,
  93: "Op13",
  Op14: 94,
  94: "Op14",
  Op15: 95,
  95: "Op15",
  Op16: 96,
  96: "Op16",
  OpNop: 97,
  97: "OpNop",
  OpVer: 98,
  98: "OpVer",
  OpIf: 99,
  99: "OpIf",
  OpNotIf: 100,
  100: "OpNotIf",
  OpVerIf: 101,
  101: "OpVerIf",
  OpVerNotIf: 102,
  102: "OpVerNotIf",
  OpElse: 103,
  103: "OpElse",
  OpEndIf: 104,
  104: "OpEndIf",
  OpVerify: 105,
  105: "OpVerify",
  OpReturn: 106,
  106: "OpReturn",
  OpToAltStack: 107,
  107: "OpToAltStack",
  OpFromAltStack: 108,
  108: "OpFromAltStack",
  Op2Drop: 109,
  109: "Op2Drop",
  Op2Dup: 110,
  110: "Op2Dup",
  Op3Dup: 111,
  111: "Op3Dup",
  Op2Over: 112,
  112: "Op2Over",
  Op2Rot: 113,
  113: "Op2Rot",
  Op2Swap: 114,
  114: "Op2Swap",
  OpIfDup: 115,
  115: "OpIfDup",
  OpDepth: 116,
  116: "OpDepth",
  OpDrop: 117,
  117: "OpDrop",
  OpDup: 118,
  118: "OpDup",
  OpNip: 119,
  119: "OpNip",
  OpOver: 120,
  120: "OpOver",
  OpPick: 121,
  121: "OpPick",
  OpRoll: 122,
  122: "OpRoll",
  OpRot: 123,
  123: "OpRot",
  OpSwap: 124,
  124: "OpSwap",
  OpTuck: 125,
  125: "OpTuck",
  /**
   * Splice opcodes.
   */
  OpCat: 126,
  126: "OpCat",
  OpSubStr: 127,
  127: "OpSubStr",
  OpLeft: 128,
  128: "OpLeft",
  OpRight: 129,
  129: "OpRight",
  OpSize: 130,
  130: "OpSize",
  /**
   * Bitwise logic opcodes.
   */
  OpInvert: 131,
  131: "OpInvert",
  OpAnd: 132,
  132: "OpAnd",
  OpOr: 133,
  133: "OpOr",
  OpXor: 134,
  134: "OpXor",
  OpEqual: 135,
  135: "OpEqual",
  OpEqualVerify: 136,
  136: "OpEqualVerify",
  OpReserved1: 137,
  137: "OpReserved1",
  OpReserved2: 138,
  138: "OpReserved2",
  /**
   * Numeric related opcodes.
   */
  Op1Add: 139,
  139: "Op1Add",
  Op1Sub: 140,
  140: "Op1Sub",
  Op2Mul: 141,
  141: "Op2Mul",
  Op2Div: 142,
  142: "Op2Div",
  OpNegate: 143,
  143: "OpNegate",
  OpAbs: 144,
  144: "OpAbs",
  OpNot: 145,
  145: "OpNot",
  Op0NotEqual: 146,
  146: "Op0NotEqual",
  OpAdd: 147,
  147: "OpAdd",
  OpSub: 148,
  148: "OpSub",
  OpMul: 149,
  149: "OpMul",
  OpDiv: 150,
  150: "OpDiv",
  OpMod: 151,
  151: "OpMod",
  OpLShift: 152,
  152: "OpLShift",
  OpRShift: 153,
  153: "OpRShift",
  OpBoolAnd: 154,
  154: "OpBoolAnd",
  OpBoolOr: 155,
  155: "OpBoolOr",
  OpNumEqual: 156,
  156: "OpNumEqual",
  OpNumEqualVerify: 157,
  157: "OpNumEqualVerify",
  OpNumNotEqual: 158,
  158: "OpNumNotEqual",
  OpLessThan: 159,
  159: "OpLessThan",
  OpGreaterThan: 160,
  160: "OpGreaterThan",
  OpLessThanOrEqual: 161,
  161: "OpLessThanOrEqual",
  OpGreaterThanOrEqual: 162,
  162: "OpGreaterThanOrEqual",
  OpMin: 163,
  163: "OpMin",
  OpMax: 164,
  164: "OpMax",
  OpWithin: 165,
  165: "OpWithin",
  /**
   * Undefined opcodes.
   */
  OpUnknown166: 166,
  166: "OpUnknown166",
  OpUnknown167: 167,
  167: "OpUnknown167",
  /**
   * Crypto opcodes.
   */
  OpSHA256: 168,
  168: "OpSHA256",
  OpCheckMultiSigECDSA: 169,
  169: "OpCheckMultiSigECDSA",
  OpBlake2b: 170,
  170: "OpBlake2b",
  OpCheckSigECDSA: 171,
  171: "OpCheckSigECDSA",
  OpCheckSig: 172,
  172: "OpCheckSig",
  OpCheckSigVerify: 173,
  173: "OpCheckSigVerify",
  OpCheckMultiSig: 174,
  174: "OpCheckMultiSig",
  OpCheckMultiSigVerify: 175,
  175: "OpCheckMultiSigVerify",
  OpCheckLockTimeVerify: 176,
  176: "OpCheckLockTimeVerify",
  OpCheckSequenceVerify: 177,
  177: "OpCheckSequenceVerify",
  /**
   * Undefined opcodes.
   */
  OpUnknown178: 178,
  178: "OpUnknown178",
  OpUnknown179: 179,
  179: "OpUnknown179",
  OpUnknown180: 180,
  180: "OpUnknown180",
  OpUnknown181: 181,
  181: "OpUnknown181",
  OpUnknown182: 182,
  182: "OpUnknown182",
  OpUnknown183: 183,
  183: "OpUnknown183",
  OpUnknown184: 184,
  184: "OpUnknown184",
  OpUnknown185: 185,
  185: "OpUnknown185",
  OpUnknown186: 186,
  186: "OpUnknown186",
  OpUnknown187: 187,
  187: "OpUnknown187",
  OpUnknown188: 188,
  188: "OpUnknown188",
  OpUnknown189: 189,
  189: "OpUnknown189",
  OpUnknown190: 190,
  190: "OpUnknown190",
  OpUnknown191: 191,
  191: "OpUnknown191",
  OpUnknown192: 192,
  192: "OpUnknown192",
  OpUnknown193: 193,
  193: "OpUnknown193",
  OpUnknown194: 194,
  194: "OpUnknown194",
  OpUnknown195: 195,
  195: "OpUnknown195",
  OpUnknown196: 196,
  196: "OpUnknown196",
  OpUnknown197: 197,
  197: "OpUnknown197",
  OpUnknown198: 198,
  198: "OpUnknown198",
  OpUnknown199: 199,
  199: "OpUnknown199",
  OpUnknown200: 200,
  200: "OpUnknown200",
  OpUnknown201: 201,
  201: "OpUnknown201",
  OpUnknown202: 202,
  202: "OpUnknown202",
  OpUnknown203: 203,
  203: "OpUnknown203",
  OpUnknown204: 204,
  204: "OpUnknown204",
  OpUnknown205: 205,
  205: "OpUnknown205",
  OpUnknown206: 206,
  206: "OpUnknown206",
  OpUnknown207: 207,
  207: "OpUnknown207",
  OpUnknown208: 208,
  208: "OpUnknown208",
  OpUnknown209: 209,
  209: "OpUnknown209",
  OpUnknown210: 210,
  210: "OpUnknown210",
  OpUnknown211: 211,
  211: "OpUnknown211",
  OpUnknown212: 212,
  212: "OpUnknown212",
  OpUnknown213: 213,
  213: "OpUnknown213",
  OpUnknown214: 214,
  214: "OpUnknown214",
  OpUnknown215: 215,
  215: "OpUnknown215",
  OpUnknown216: 216,
  216: "OpUnknown216",
  OpUnknown217: 217,
  217: "OpUnknown217",
  OpUnknown218: 218,
  218: "OpUnknown218",
  OpUnknown219: 219,
  219: "OpUnknown219",
  OpUnknown220: 220,
  220: "OpUnknown220",
  OpUnknown221: 221,
  221: "OpUnknown221",
  OpUnknown222: 222,
  222: "OpUnknown222",
  OpUnknown223: 223,
  223: "OpUnknown223",
  OpUnknown224: 224,
  224: "OpUnknown224",
  OpUnknown225: 225,
  225: "OpUnknown225",
  OpUnknown226: 226,
  226: "OpUnknown226",
  OpUnknown227: 227,
  227: "OpUnknown227",
  OpUnknown228: 228,
  228: "OpUnknown228",
  OpUnknown229: 229,
  229: "OpUnknown229",
  OpUnknown230: 230,
  230: "OpUnknown230",
  OpUnknown231: 231,
  231: "OpUnknown231",
  OpUnknown232: 232,
  232: "OpUnknown232",
  OpUnknown233: 233,
  233: "OpUnknown233",
  OpUnknown234: 234,
  234: "OpUnknown234",
  OpUnknown235: 235,
  235: "OpUnknown235",
  OpUnknown236: 236,
  236: "OpUnknown236",
  OpUnknown237: 237,
  237: "OpUnknown237",
  OpUnknown238: 238,
  238: "OpUnknown238",
  OpUnknown239: 239,
  239: "OpUnknown239",
  OpUnknown240: 240,
  240: "OpUnknown240",
  OpUnknown241: 241,
  241: "OpUnknown241",
  OpUnknown242: 242,
  242: "OpUnknown242",
  OpUnknown243: 243,
  243: "OpUnknown243",
  OpUnknown244: 244,
  244: "OpUnknown244",
  OpUnknown245: 245,
  245: "OpUnknown245",
  OpUnknown246: 246,
  246: "OpUnknown246",
  OpUnknown247: 247,
  247: "OpUnknown247",
  OpUnknown248: 248,
  248: "OpUnknown248",
  OpUnknown249: 249,
  249: "OpUnknown249",
  OpSmallInteger: 250,
  250: "OpSmallInteger",
  OpPubKeys: 251,
  251: "OpPubKeys",
  OpUnknown252: 252,
  252: "OpUnknown252",
  OpPubKeyHash: 253,
  253: "OpPubKeyHash",
  OpPubKey: 254,
  254: "OpPubKey",
  OpInvalidOpCode: 255,
  255: "OpInvalidOpCode"
});
var SighashType = Object.freeze({
  All: 0,
  0: "All",
  None: 1,
  1: "None",
  Single: 2,
  2: "Single",
  AllAnyOneCanPay: 3,
  3: "AllAnyOneCanPay",
  NoneAnyOneCanPay: 4,
  4: "NoneAnyOneCanPay",
  SingleAnyOneCanPay: 5,
  5: "SingleAnyOneCanPay"
});
var __wbindgen_enum_BinaryType = ["blob", "arraybuffer"];
var __wbindgen_enum_IdbCursorDirection = [
  "next",
  "nextunique",
  "prev",
  "prevunique"
];
var __wbindgen_enum_IdbRequestReadyState = ["pending", "done"];
var __wbindgen_enum_IdbTransactionMode = [
  "readonly",
  "readwrite",
  "versionchange",
  "readwriteflush",
  "cleanup"
];
var __wbindgen_enum_RequestCredentials = ["omit", "same-origin", "include"];
var __wbindgen_enum_RequestMode = [
  "same-origin",
  "no-cors",
  "cors",
  "navigate"
];
var AbortableFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_abortable_free(ptr >>> 0, 1)
);
var AbortedFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_aborted_free(ptr >>> 0, 1));
var _Aborted = class _Aborted {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Aborted.prototype);
    obj.__wbg_ptr = ptr;
    AbortedFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AbortedFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_aborted_free(ptr, 0);
  }
};
__name(_Aborted, "Aborted");
var Aborted = _Aborted;
var AccountKindFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_accountkind_free(ptr >>> 0, 1)
);
var _AccountKind = class _AccountKind {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_AccountKind.prototype);
    obj.__wbg_ptr = ptr;
    AccountKindFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AccountKindFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_accountkind_free(ptr, 0);
  }
  /**
   * @param {string} kind
   */
  constructor(kind) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        kind,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.accountkind_ctor(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      AccountKindFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.accountkind_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_AccountKind, "AccountKind");
var AccountKind = _AccountKind;
var AddressFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_address_free(ptr >>> 0, 1));
var _Address = class _Address {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Address.prototype);
    obj.__wbg_ptr = ptr;
    AddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      version: this.version,
      prefix: this.prefix,
      payload: this.payload
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AddressFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_address_free(ptr, 0);
  }
  /**
   * @param {string} address
   */
  constructor(address) {
    const ptr0 = passStringToWasm0(
      address,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.address_constructor(ptr0, len0);
    this.__wbg_ptr = ret >>> 0;
    AddressFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @param {string} address
   * @returns {boolean}
   */
  static validate(address) {
    const ptr0 = passStringToWasm0(
      address,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.address_validate(ptr0, len0);
    return ret !== 0;
  }
  /**
   * Convert an address to a string.
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.address_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  get version() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.address_version(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  get prefix() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.address_prefix(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} prefix
   */
  set setPrefix(prefix) {
    const ptr0 = passStringToWasm0(
      prefix,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.address_set_setPrefix(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string}
   */
  get payload() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.address_payload(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {number} n
   * @returns {string}
   */
  short(n) {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.address_short(retptr, this.__wbg_ptr, n);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_Address, "Address");
var Address = _Address;
var AgentConstructorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_agentconstructoroptions_free(ptr >>> 0, 1)
);
var AppendFileOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_appendfileoptions_free(ptr >>> 0, 1)
);
var AssertionErrorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_assertionerroroptions_free(ptr >>> 0, 1)
);
var BalanceFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_balance_free(ptr >>> 0, 1));
var BalanceStringsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_balancestrings_free(ptr >>> 0, 1)
);
var ConsoleConstructorOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_consoleconstructoroptions_free(ptr >>> 0, 1)
);
var CreateHookCallbacksFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_createhookcallbacks_free(ptr >>> 0, 1)
);
var CreateReadStreamOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_createreadstreamoptions_free(ptr >>> 0, 1)
);
var CreateWriteStreamOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_createwritestreamoptions_free(ptr >>> 0, 1)
);
var CryptoBoxFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_cryptobox_free(ptr >>> 0, 1)
);
var CryptoBoxPrivateKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_cryptoboxprivatekey_free(ptr >>> 0, 1)
);
var CryptoBoxPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_cryptoboxpublickey_free(ptr >>> 0, 1)
);
var DerivationPathFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_derivationpath_free(ptr >>> 0, 1)
);
var FormatInputPathObjectFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_formatinputpathobject_free(ptr >>> 0, 1)
);
var GeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_generator_free(ptr >>> 0, 1)
);
var _Generator = class _Generator {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GeneratorFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_generator_free(ptr, 0);
  }
  /**
   * @param {IGeneratorSettingsObject} args
   */
  constructor(args) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.generator_ctor(retptr, addHeapObject(args));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      GeneratorFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Generate next transaction
   * @returns {Promise<any>}
   */
  next() {
    const ret = wasm.generator_next(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<GeneratorSummary>}
   */
  estimate() {
    const ret = wasm.generator_estimate(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {GeneratorSummary}
   */
  summary() {
    const ret = wasm.generator_summary(this.__wbg_ptr);
    return GeneratorSummary.__wrap(ret);
  }
};
__name(_Generator, "Generator");
var Generator = _Generator;
var GeneratorSummaryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_generatorsummary_free(ptr >>> 0, 1)
);
var _GeneratorSummary = class _GeneratorSummary {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_GeneratorSummary.prototype);
    obj.__wbg_ptr = ptr;
    GeneratorSummaryFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      networkType: this.networkType,
      utxos: this.utxos,
      fees: this.fees,
      mass: this.mass,
      transactions: this.transactions,
      finalAmount: this.finalAmount,
      finalTransactionId: this.finalTransactionId
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GeneratorSummaryFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_generatorsummary_free(ptr, 0);
  }
  /**
   * @returns {NetworkType}
   */
  get networkType() {
    const ret = wasm.generatorsummary_networkType(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {number}
   */
  get utxos() {
    const ret = wasm.generatorsummary_utxos(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {bigint}
   */
  get fees() {
    const ret = wasm.generatorsummary_fees(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {bigint}
   */
  get mass() {
    const ret = wasm.generatorsummary_mass(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {number}
   */
  get transactions() {
    const ret = wasm.generatorsummary_transactions(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {bigint | undefined}
   */
  get finalAmount() {
    const ret = wasm.generatorsummary_finalAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {string | undefined}
   */
  get finalTransactionId() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.generatorsummary_finalTransactionId(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_GeneratorSummary, "GeneratorSummary");
var GeneratorSummary = _GeneratorSummary;
var GetNameOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_getnameoptions_free(ptr >>> 0, 1)
);
var HashFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_hash_free(ptr >>> 0, 1));
var _Hash = class _Hash {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Hash.prototype);
    obj.__wbg_ptr = ptr;
    HashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    HashFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_hash_free(ptr, 0);
  }
  /**
   * @param {string} hex_str
   */
  constructor(hex_str) {
    const ptr0 = passStringToWasm0(
      hex_str,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.hash_constructor(ptr0, len0);
    this.__wbg_ptr = ret >>> 0;
    HashFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.hash_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_Hash, "Hash");
var Hash2 = _Hash;
var HeaderFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_header_free(ptr >>> 0, 1));
var KeypairFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_keypair_free(ptr >>> 0, 1));
var _Keypair = class _Keypair {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Keypair.prototype);
    obj.__wbg_ptr = ptr;
    KeypairFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      publicKey: this.publicKey,
      privateKey: this.privateKey,
      xOnlyPublicKey: this.xOnlyPublicKey
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    KeypairFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_keypair_free(ptr, 0);
  }
  /**
   * Get the [`PublicKey`] of this [`Keypair`].
   * @returns {string}
   */
  get publicKey() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.keypair_get_public_key(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get the [`PrivateKey`] of this [`Keypair`].
   * @returns {string}
   */
  get privateKey() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.keypair_get_private_key(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get the `XOnlyPublicKey` of this [`Keypair`].
   * @returns {any}
   */
  get xOnlyPublicKey() {
    const ret = wasm.keypair_get_xonly_public_key(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Get the [`Address`] of this Keypair's [`PublicKey`].
   * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
   * to determine the prefix of the address.
   * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddress(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.keypair_toAddress(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Get `ECDSA` [`Address`] of this Keypair's [`PublicKey`].
   * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
   * to determine the prefix of the address.
   * JavaScript: `let address = keypair.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddressECDSA(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.keypair_toAddressECDSA(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Create a new random [`Keypair`].
   * JavaScript: `let keypair = Keypair::random();`.
   * @returns {Keypair}
   */
  static random() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.keypair_random(retptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Keypair.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Create a new [`Keypair`] from a [`PrivateKey`].
   * JavaScript: `let privkey = new PrivateKey(hexString); let keypair = privkey.toKeypair();`.
   * @param {PrivateKey} secret_key
   * @returns {Keypair}
   */
  static fromPrivateKey(secret_key) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(secret_key, PrivateKey);
      wasm.keypair_fromPrivateKey(retptr, secret_key.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Keypair.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_Keypair, "Keypair");
var Keypair = _Keypair;
var MkdtempSyncOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_mkdtempsyncoptions_free(ptr >>> 0, 1)
);
var MnemonicFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_mnemonic_free(ptr >>> 0, 1));
var _Mnemonic = class _Mnemonic {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Mnemonic.prototype);
    obj.__wbg_ptr = ptr;
    MnemonicFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      entropy: this.entropy,
      phrase: this.phrase
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MnemonicFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_mnemonic_free(ptr, 0);
  }
  /**
   * @param {string} phrase
   * @param {Language | null} [language]
   */
  constructor(phrase, language) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        phrase,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.mnemonic_constructor(
        retptr,
        ptr0,
        len0,
        isLikeNone(language) ? 1 : language
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      MnemonicFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Validate mnemonic phrase. Returns `true` if the phrase is valid, `false` otherwise.
   * @param {string} phrase
   * @param {Language | null} [language]
   * @returns {boolean}
   */
  static validate(phrase, language) {
    const ptr0 = passStringToWasm0(
      phrase,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.mnemonic_validate(
      ptr0,
      len0,
      isLikeNone(language) ? 1 : language
    );
    return ret !== 0;
  }
  /**
   * @returns {string}
   */
  get entropy() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.mnemonic_entropy(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} entropy
   */
  set entropy(entropy) {
    const ptr0 = passStringToWasm0(
      entropy,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.mnemonic_set_entropy(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {number | null} [word_count]
   * @returns {Mnemonic}
   */
  static random(word_count) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.mnemonic_random(
        retptr,
        isLikeNone(word_count) ? 4294967297 : word_count >>> 0
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Mnemonic.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  get phrase() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.mnemonic_phrase(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} phrase
   */
  set phrase(phrase) {
    const ptr0 = passStringToWasm0(
      phrase,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.mnemonic_set_phrase(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {string | null} [password]
   * @returns {string}
   */
  toSeed(password) {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone(password) ? 0 : passStringToWasm0(
        password,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      var len0 = WASM_VECTOR_LEN;
      wasm.mnemonic_toSeed(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred2_0 = r0;
      deferred2_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
};
__name(_Mnemonic, "Mnemonic");
var Mnemonic = _Mnemonic;
var NetServerOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_netserveroptions_free(ptr >>> 0, 1)
);
var NetworkIdFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_networkid_free(ptr >>> 0, 1)
);
var _NetworkId = class _NetworkId {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_NetworkId.prototype);
    obj.__wbg_ptr = ptr;
    NetworkIdFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      type: this.type,
      suffix: this.suffix,
      id: this.id
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NetworkIdFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_networkid_free(ptr, 0);
  }
  /**
   * @returns {NetworkType}
   */
  get type() {
    const ret = wasm.__wbg_get_networkid_type(this.__wbg_ptr);
    return ret;
  }
  /**
   * @param {NetworkType} arg0
   */
  set type(arg0) {
    wasm.__wbg_set_networkid_type(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {number | undefined}
   */
  get suffix() {
    const ret = wasm.__wbg_get_networkid_suffix(this.__wbg_ptr);
    return ret === 4294967297 ? void 0 : ret;
  }
  /**
   * @param {number | null} [arg0]
   */
  set suffix(arg0) {
    wasm.__wbg_set_networkid_suffix(
      this.__wbg_ptr,
      isLikeNone(arg0) ? 4294967297 : arg0 >>> 0
    );
  }
  /**
   * @param {any} value
   */
  constructor(value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.networkid_ctor(retptr, addBorrowedObject(value));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      NetworkIdFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {string}
   */
  get id() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.networkid_id(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.networkid_id(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  addressPrefix() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.networkid_addressPrefix(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_NetworkId, "NetworkId");
var NetworkId = _NetworkId;
var NodeDescriptorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_nodedescriptor_free(ptr >>> 0, 1)
);
var _NodeDescriptor = class _NodeDescriptor {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_NodeDescriptor.prototype);
    obj.__wbg_ptr = ptr;
    NodeDescriptorFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      uid: this.uid,
      url: this.url
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NodeDescriptorFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_nodedescriptor_free(ptr, 0);
  }
  /**
   * The unique identifier of the node.
   * @returns {string}
   */
  get uid() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_nodedescriptor_uid(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * The unique identifier of the node.
   * @param {string} arg0
   */
  set uid(arg0) {
    const ptr0 = passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_nodedescriptor_uid(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * The URL of the node WebSocket (wRPC URL).
   * @returns {string}
   */
  get url() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_nodedescriptor_url(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * The URL of the node WebSocket (wRPC URL).
   * @param {string} arg0
   */
  set url(arg0) {
    const ptr0 = passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_nodedescriptor_url(this.__wbg_ptr, ptr0, len0);
  }
};
__name(_NodeDescriptor, "NodeDescriptor");
var NodeDescriptor = _NodeDescriptor;
var PSKBFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pskb_free(ptr >>> 0, 1));
var PSKTFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pskt_free(ptr >>> 0, 1));
var PaymentOutputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_paymentoutput_free(ptr >>> 0, 1)
);
var PaymentOutputsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_paymentoutputs_free(ptr >>> 0, 1)
);
var PendingTransactionFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_pendingtransaction_free(ptr >>> 0, 1)
);
var _PendingTransaction = class _PendingTransaction {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PendingTransaction.prototype);
    obj.__wbg_ptr = ptr;
    PendingTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      id: this.id,
      paymentAmount: this.paymentAmount,
      changeAmount: this.changeAmount,
      feeAmount: this.feeAmount,
      mass: this.mass,
      minimumSignatures: this.minimumSignatures,
      aggregateInputAmount: this.aggregateInputAmount,
      aggregateOutputAmount: this.aggregateOutputAmount,
      type: this.type,
      transaction: this.transaction
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PendingTransactionFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_pendingtransaction_free(ptr, 0);
  }
  /**
   * Transaction Id
   * @returns {string}
   */
  get id() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_id(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Total amount transferred to the destination (aggregate output - change).
   * @returns {any}
   */
  get paymentAmount() {
    const ret = wasm.pendingtransaction_paymentAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Change amount (if any).
   * @returns {bigint}
   */
  get changeAmount() {
    const ret = wasm.pendingtransaction_changeAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Total transaction fees (network fees + priority fees).
   * @returns {bigint}
   */
  get feeAmount() {
    const ret = wasm.pendingtransaction_feeAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Calculated transaction mass.
   * @returns {bigint}
   */
  get mass() {
    const ret = wasm.pendingtransaction_mass(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Minimum number of signatures required by the transaction.
   * (as specified during the transaction creation).
   * @returns {number}
   */
  get minimumSignatures() {
    const ret = wasm.pendingtransaction_minimumSignatures(this.__wbg_ptr);
    return ret;
  }
  /**
   * Total aggregate input amount.
   * @returns {bigint}
   */
  get aggregateInputAmount() {
    const ret = wasm.pendingtransaction_aggregateInputAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Total aggregate output amount.
   * @returns {bigint}
   */
  get aggregateOutputAmount() {
    const ret = wasm.pendingtransaction_aggregateOutputAmount(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Transaction type ("batch" or "final").
   * @returns {string}
   */
  get type() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_type(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * List of unique addresses used by transaction inputs.
   * This method can be used to determine addresses used by transaction inputs
   * in order to select private keys needed for transaction signing.
   * @returns {Array<any>}
   */
  addresses() {
    const ret = wasm.pendingtransaction_addresses(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Provides a list of UTXO entries used by the transaction.
   * @returns {Array<any>}
   */
  getUtxoEntries() {
    const ret = wasm.pendingtransaction_getUtxoEntries(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Creates and returns a signature for the input at the specified index.
   * @param {number} input_index
   * @param {PrivateKey} private_key
   * @param {SighashType | null} [sighash_type]
   * @returns {HexString}
   */
  createInputSignature(input_index, private_key, sighash_type) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(private_key, PrivateKey);
      wasm.pendingtransaction_createInputSignature(
        retptr,
        this.__wbg_ptr,
        input_index,
        private_key.__wbg_ptr,
        isLikeNone(sighash_type) ? 6 : sighash_type
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Sets a signature to the input at the specified index.
   * @param {number} input_index
   * @param {HexString | Uint8Array} signature_script
   */
  fillInput(input_index, signature_script) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_fillInput(
        retptr,
        this.__wbg_ptr,
        input_index,
        addHeapObject(signature_script)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Signs the input at the specified index with the supplied private key
   * and an optional SighashType.
   * @param {number} input_index
   * @param {PrivateKey} private_key
   * @param {SighashType | null} [sighash_type]
   */
  signInput(input_index, private_key, sighash_type) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(private_key, PrivateKey);
      wasm.pendingtransaction_signInput(
        retptr,
        this.__wbg_ptr,
        input_index,
        private_key.__wbg_ptr,
        isLikeNone(sighash_type) ? 6 : sighash_type
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Signs transaction with supplied [`Array`] or [`PrivateKey`] or an array of
   * raw private key bytes (encoded as `Uint8Array` or as hex strings)
   * @param {(PrivateKey | HexString | Uint8Array)[]} js_value
   * @param {boolean | null} [check_fully_signed]
   */
  sign(js_value, check_fully_signed) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_sign(
        retptr,
        this.__wbg_ptr,
        addHeapObject(js_value),
        isLikeNone(check_fully_signed) ? 16777215 : check_fully_signed ? 1 : 0
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Submit transaction to the supplied [`RpcClient`]
   * **IMPORTANT:** This method will remove UTXOs from the associated
   * {@link UtxoContext} if one was used to create the transaction
   * and will return UTXOs back to {@link UtxoContext} in case of
   * a failed submission.
   *
   * # Important
   *
   * Make sure to consume the returned `txid` value. Always invoke this method
   * as follows `let txid = await pendingTransaction.submit(rpc);`. If you do not
   * consume the returned value and the rpc object is temporary, the GC will
   * collect the `rpc` object passed to submit() potentially causing a panic.
   *
   * @see {@link RpcClient.submitTransaction}
   * @param {RpcClient} wasm_rpc_client
   * @returns {Promise<string>}
   */
  submit(wasm_rpc_client) {
    _assertClass(wasm_rpc_client, RpcClient);
    const ret = wasm.pendingtransaction_submit(
      this.__wbg_ptr,
      wasm_rpc_client.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * Returns encapsulated network [`Transaction`]
   * @returns {Transaction}
   */
  get transaction() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_transaction(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Transaction.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Serializes the transaction to a pure JavaScript Object.
   * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
   * @see {@link ISerializableTransaction}
   * @see {@link Transaction}, {@link ISerializableTransaction}
   * @returns {ITransaction | Transaction}
   */
  serializeToObject() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_serializeToObject(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Serializes the transaction to a JSON string.
   * The schema of the JSON is defined by {@link ISerializableTransaction}.
   * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromJSON}.
   * @see {@link Transaction}, {@link ISerializableTransaction}
   * @returns {string}
   */
  serializeToJSON() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_serializeToJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
   * Once serialized, the transaction can be deserialized using {@link Transaction.deserializeFromSafeJSON}.
   * @see {@link Transaction}, {@link ISerializableTransaction}
   * @returns {string}
   */
  serializeToSafeJSON() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.pendingtransaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
};
__name(_PendingTransaction, "PendingTransaction");
var PendingTransaction = _PendingTransaction;
var PipeOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_pipeoptions_free(ptr >>> 0, 1)
);
var PoWFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_pow_free(ptr >>> 0, 1));
var PrivateKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_privatekey_free(ptr >>> 0, 1)
);
var _PrivateKey = class _PrivateKey {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PrivateKey.prototype);
    obj.__wbg_ptr = ptr;
    PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PrivateKeyFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_privatekey_free(ptr, 0);
  }
  /**
   * Create a new [`PrivateKey`] from a hex-encoded string.
   * @param {string} key
   */
  constructor(key) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        key,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.privatekey_try_new(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      PrivateKeyFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Returns the [`PrivateKey`] key encoded as a hex string.
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekey_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Generate a [`Keypair`] from this [`PrivateKey`].
   * @returns {Keypair}
   */
  toKeypair() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekey_toKeypair(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Keypair.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PublicKey}
   */
  toPublicKey() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekey_toPublicKey(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return PublicKey.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Get the [`Address`] of the PublicKey generated from this PrivateKey.
   * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
   * to determine the prefix of the address.
   * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddress(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekey_toAddress(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Get `ECDSA` [`Address`] of the PublicKey generated from this PrivateKey.
   * Receives a [`NetworkType`](kaspa_consensus_core::network::NetworkType)
   * to determine the prefix of the address.
   * JavaScript: `let address = privateKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddressECDSA(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekey_toAddressECDSA(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
};
__name(_PrivateKey, "PrivateKey");
var PrivateKey = _PrivateKey;
var PrivateKeyGeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_privatekeygenerator_free(ptr >>> 0, 1)
);
var _PrivateKeyGenerator = class _PrivateKeyGenerator {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PrivateKeyGeneratorFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_privatekeygenerator_free(ptr, 0);
  }
  /**
   * @param {XPrv | string} xprv
   * @param {boolean} is_multisig
   * @param {bigint} account_index
   * @param {number | null} [cosigner_index]
   */
  constructor(xprv, is_multisig, account_index, cosigner_index) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekeygenerator_new(
        retptr,
        addBorrowedObject(xprv),
        is_multisig,
        account_index,
        isLikeNone(cosigner_index) ? 4294967297 : cosigner_index >>> 0
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      PrivateKeyGeneratorFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @param {number} index
   * @returns {PrivateKey}
   */
  receiveKey(index) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekeygenerator_receiveKey(retptr, this.__wbg_ptr, index);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} index
   * @returns {PrivateKey}
   */
  changeKey(index) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.privatekeygenerator_changeKey(retptr, this.__wbg_ptr, index);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_PrivateKeyGenerator, "PrivateKeyGenerator");
var PrivateKeyGenerator = _PrivateKeyGenerator;
var ProcessSendOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_processsendoptions_free(ptr >>> 0, 1)
);
var PrvKeyDataInfoFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_prvkeydatainfo_free(ptr >>> 0, 1)
);
var PublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_publickey_free(ptr >>> 0, 1)
);
var _PublicKey = class _PublicKey {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_PublicKey.prototype);
    obj.__wbg_ptr = ptr;
    PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PublicKeyFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_publickey_free(ptr, 0);
  }
  /**
   * Create a new [`PublicKey`] from a hex-encoded string.
   * @param {string} key
   */
  constructor(key) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        key,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.publickey_try_new(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      PublicKeyFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publickey_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get the [`Address`] of this PublicKey.
   * Receives a [`NetworkType`] to determine the prefix of the address.
   * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddress(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publickey_toAddress(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Get `ECDSA` [`Address`] of this PublicKey.
   * Receives a [`NetworkType`] to determine the prefix of the address.
   * JavaScript: `let address = publicKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddressECDSA(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.publickey_toAddressECDSA(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {XOnlyPublicKey}
   */
  toXOnlyPublicKey() {
    const ret = wasm.publickey_toXOnlyPublicKey(this.__wbg_ptr);
    return XOnlyPublicKey.__wrap(ret);
  }
  /**
   * Compute a 4-byte key fingerprint for this public key as a hex string.
   * Default implementation uses `RIPEMD160(SHA256(public_key))`.
   * @returns {HexString | undefined}
   */
  fingerprint() {
    const ret = wasm.publickey_fingerprint(this.__wbg_ptr);
    return takeObject(ret);
  }
};
__name(_PublicKey, "PublicKey");
var PublicKey = _PublicKey;
var PublicKeyGeneratorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_publickeygenerator_free(ptr >>> 0, 1)
);
var ReadStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_readstream_free(ptr >>> 0, 1)
);
var ResolverFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_resolver_free(ptr >>> 0, 1));
var _Resolver = class _Resolver {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Resolver.prototype);
    obj.__wbg_ptr = ptr;
    ResolverFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      urls: this.urls
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ResolverFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_resolver_free(ptr, 0);
  }
  /**
   * List of public Kaspa Resolver URLs.
   * @returns {string[] | undefined}
   */
  get urls() {
    const ret = wasm.resolver_urls(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Fetches a public Kaspa wRPC endpoint for the given encoding and network identifier.
   * @see {@link Encoding}, {@link NetworkId}, {@link Node}
   * @param {Encoding} encoding
   * @param {NetworkId | string} network_id
   * @returns {Promise<NodeDescriptor>}
   */
  getNode(encoding, network_id) {
    const ret = wasm.resolver_getNode(
      this.__wbg_ptr,
      encoding,
      addHeapObject(network_id)
    );
    return takeObject(ret);
  }
  /**
   * Fetches a public Kaspa wRPC endpoint URL for the given encoding and network identifier.
   * @see {@link Encoding}, {@link NetworkId}
   * @param {Encoding} encoding
   * @param {NetworkId | string} network_id
   * @returns {Promise<string>}
   */
  getUrl(encoding, network_id) {
    const ret = wasm.resolver_getUrl(
      this.__wbg_ptr,
      encoding,
      addHeapObject(network_id)
    );
    return takeObject(ret);
  }
  /**
   * Connect to a public Kaspa wRPC endpoint for the given encoding and network identifier
   * supplied via {@link IResolverConnect} interface.
   * @see {@link IResolverConnect}, {@link RpcClient}
   * @param {IResolverConnect | NetworkId | string} options
   * @returns {Promise<RpcClient>}
   */
  connect(options) {
    const ret = wasm.resolver_connect(this.__wbg_ptr, addHeapObject(options));
    return takeObject(ret);
  }
  /**
   * Creates a new Resolver client with the given
   * configuration supplied as {@link IResolverConfig}
   * interface. If not supplied, the default configuration
   * containing a list of community-operated resolvers
   * will be used.
   * @param {IResolverConfig | string[] | null} [args]
   */
  constructor(args) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.resolver_ctor(retptr, isLikeNone(args) ? 0 : addHeapObject(args));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      ResolverFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_Resolver, "Resolver");
var Resolver = _Resolver;
var RpcClientFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_rpcclient_free(ptr >>> 0, 1)
);
var _RpcClient = class _RpcClient {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_RpcClient.prototype);
    obj.__wbg_ptr = ptr;
    RpcClientFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      url: this.url,
      resolver: this.resolver,
      isConnected: this.isConnected,
      encoding: this.encoding,
      nodeId: this.nodeId
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RpcClientFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rpcclient_free(ptr, 0);
  }
  /**
   * Retrieves the current number of blocks in the Kaspa BlockDAG.
   * This is not a block count, not a "block height" and can not be
   * used for transaction validation.
   * Returned information: Current block count.
   * @see {@link IGetBlockCountRequest}, {@link IGetBlockCountResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetBlockCountRequest | null} [request]
   * @returns {Promise<IGetBlockCountResponse>}
   */
  getBlockCount(request) {
    const ret = wasm.rpcclient_getBlockCount(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Provides information about the Directed Acyclic Graph (DAG)
   * structure of the Kaspa BlockDAG.
   * Returned information: Number of blocks in the DAG,
   * number of tips in the DAG, hash of the selected parent block,
   * difficulty of the selected parent block, selected parent block
   * blue score, selected parent block time.
   * @see {@link IGetBlockDagInfoRequest}, {@link IGetBlockDagInfoResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetBlockDagInfoRequest | null} [request]
   * @returns {Promise<IGetBlockDagInfoResponse>}
   */
  getBlockDagInfo(request) {
    const ret = wasm.rpcclient_getBlockDagInfo(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Returns the total current coin supply of Kaspa network.
   * Returned information: Total coin supply.
   * @see {@link IGetCoinSupplyRequest}, {@link IGetCoinSupplyResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetCoinSupplyRequest | null} [request]
   * @returns {Promise<IGetCoinSupplyResponse>}
   */
  getCoinSupply(request) {
    const ret = wasm.rpcclient_getCoinSupply(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves information about the peers connected to the Kaspa node.
   * Returned information: Peer ID, IP address and port, connection
   * status, protocol version.
   * @see {@link IGetConnectedPeerInfoRequest}, {@link IGetConnectedPeerInfoResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetConnectedPeerInfoRequest | null} [request]
   * @returns {Promise<IGetConnectedPeerInfoResponse>}
   */
  getConnectedPeerInfo(request) {
    const ret = wasm.rpcclient_getConnectedPeerInfo(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves general information about the Kaspa node.
   * Returned information: Version of the Kaspa node, protocol
   * version, network identifier.
   * This call is primarily used by gRPC clients.
   * For wRPC clients, use {@link RpcClient.getServerInfo}.
   * @see {@link IGetInfoRequest}, {@link IGetInfoResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetInfoRequest | null} [request]
   * @returns {Promise<IGetInfoResponse>}
   */
  getInfo(request) {
    const ret = wasm.rpcclient_getInfo(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Provides a list of addresses of known peers in the Kaspa
   * network that the node can potentially connect to.
   * Returned information: List of peer addresses.
   * @see {@link IGetPeerAddressesRequest}, {@link IGetPeerAddressesResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetPeerAddressesRequest | null} [request]
   * @returns {Promise<IGetPeerAddressesResponse>}
   */
  getPeerAddresses(request) {
    const ret = wasm.rpcclient_getPeerAddresses(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves various metrics and statistics related to the
   * performance and status of the Kaspa node.
   * Returned information: Memory usage, CPU usage, network activity.
   * @see {@link IGetMetricsRequest}, {@link IGetMetricsResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetMetricsRequest | null} [request]
   * @returns {Promise<IGetMetricsResponse>}
   */
  getMetrics(request) {
    const ret = wasm.rpcclient_getMetrics(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves current number of network connections
   * @see {@link IGetConnectionsRequest}, {@link IGetConnectionsResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetConnectionsRequest | null} [request]
   * @returns {Promise<IGetConnectionsResponse>}
   */
  getConnections(request) {
    const ret = wasm.rpcclient_getConnections(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves the current sink block, which is the block with
   * the highest cumulative difficulty in the Kaspa BlockDAG.
   * Returned information: Sink block hash, sink block height.
   * @see {@link IGetSinkRequest}, {@link IGetSinkResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetSinkRequest | null} [request]
   * @returns {Promise<IGetSinkResponse>}
   */
  getSink(request) {
    const ret = wasm.rpcclient_getSink(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Returns the blue score of the current sink block, indicating
   * the total amount of work that has been done on the main chain
   * leading up to that block.
   * Returned information: Blue score of the sink block.
   * @see {@link IGetSinkBlueScoreRequest}, {@link IGetSinkBlueScoreResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetSinkBlueScoreRequest | null} [request]
   * @returns {Promise<IGetSinkBlueScoreResponse>}
   */
  getSinkBlueScore(request) {
    const ret = wasm.rpcclient_getSinkBlueScore(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Tests the connection and responsiveness of a Kaspa node.
   * Returned information: None.
   * @see {@link IPingRequest}, {@link IPingResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IPingRequest | null} [request]
   * @returns {Promise<IPingResponse>}
   */
  ping(request) {
    const ret = wasm.rpcclient_ping(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Gracefully shuts down the Kaspa node.
   * Returned information: None.
   * @see {@link IShutdownRequest}, {@link IShutdownResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IShutdownRequest | null} [request]
   * @returns {Promise<IShutdownResponse>}
   */
  shutdown(request) {
    const ret = wasm.rpcclient_shutdown(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves information about the Kaspa server.
   * Returned information: Version of the Kaspa server, protocol
   * version, network identifier.
   * @see {@link IGetServerInfoRequest}, {@link IGetServerInfoResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetServerInfoRequest | null} [request]
   * @returns {Promise<IGetServerInfoResponse>}
   */
  getServerInfo(request) {
    const ret = wasm.rpcclient_getServerInfo(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Obtains basic information about the synchronization status of the Kaspa node.
   * Returned information: Syncing status.
   * @see {@link IGetSyncStatusRequest}, {@link IGetSyncStatusResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetSyncStatusRequest | null} [request]
   * @returns {Promise<IGetSyncStatusResponse>}
   */
  getSyncStatus(request) {
    const ret = wasm.rpcclient_getSyncStatus(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Feerate estimates
   * @see {@link IGetFeeEstimateRequest}, {@link IGetFeeEstimateResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetFeeEstimateRequest | null} [request]
   * @returns {Promise<IGetFeeEstimateResponse>}
   */
  getFeeEstimate(request) {
    const ret = wasm.rpcclient_getFeeEstimate(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves the current network configuration.
   * Returned information: Current network configuration.
   * @see {@link IGetCurrentNetworkRequest}, {@link IGetCurrentNetworkResponse}
   * @throws `string` on an RPC error or a server-side error.
   * @param {IGetCurrentNetworkRequest | null} [request]
   * @returns {Promise<IGetCurrentNetworkResponse>}
   */
  getCurrentNetwork(request) {
    const ret = wasm.rpcclient_getCurrentNetwork(
      this.__wbg_ptr,
      isLikeNone(request) ? 0 : addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Adds a peer to the Kaspa node's list of known peers.
   * Returned information: None.
   * @see {@link IAddPeerRequest}, {@link IAddPeerResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IAddPeerRequest} request
   * @returns {Promise<IAddPeerResponse>}
   */
  addPeer(request) {
    const ret = wasm.rpcclient_addPeer(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * Bans a peer from connecting to the Kaspa node for a specified duration.
   * Returned information: None.
   * @see {@link IBanRequest}, {@link IBanResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IBanRequest} request
   * @returns {Promise<IBanResponse>}
   */
  ban(request) {
    const ret = wasm.rpcclient_ban(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * Estimates the network's current hash rate in hashes per second.
   * Returned information: Estimated network hashes per second.
   * @see {@link IEstimateNetworkHashesPerSecondRequest}, {@link IEstimateNetworkHashesPerSecondResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IEstimateNetworkHashesPerSecondRequest} request
   * @returns {Promise<IEstimateNetworkHashesPerSecondResponse>}
   */
  estimateNetworkHashesPerSecond(request) {
    const ret = wasm.rpcclient_estimateNetworkHashesPerSecond(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves the balance of a specific address in the Kaspa BlockDAG.
   * Returned information: Balance of the address.
   * @see {@link IGetBalanceByAddressRequest}, {@link IGetBalanceByAddressResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetBalanceByAddressRequest} request
   * @returns {Promise<IGetBalanceByAddressResponse>}
   */
  getBalanceByAddress(request) {
    const ret = wasm.rpcclient_getBalanceByAddress(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves balances for multiple addresses in the Kaspa BlockDAG.
   * Returned information: Balances of the addresses.
   * @see {@link IGetBalancesByAddressesRequest}, {@link IGetBalancesByAddressesResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetBalancesByAddressesRequest | Address[] | string[]} request
   * @returns {Promise<IGetBalancesByAddressesResponse>}
   */
  getBalancesByAddresses(request) {
    const ret = wasm.rpcclient_getBalancesByAddresses(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves a specific block from the Kaspa BlockDAG.
   * Returned information: Block information.
   * @see {@link IGetBlockRequest}, {@link IGetBlockResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetBlockRequest} request
   * @returns {Promise<IGetBlockResponse>}
   */
  getBlock(request) {
    const ret = wasm.rpcclient_getBlock(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * Retrieves multiple blocks from the Kaspa BlockDAG.
   * Returned information: List of block information.
   * @see {@link IGetBlocksRequest}, {@link IGetBlocksResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetBlocksRequest} request
   * @returns {Promise<IGetBlocksResponse>}
   */
  getBlocks(request) {
    const ret = wasm.rpcclient_getBlocks(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Generates a new block template for mining.
   * Returned information: Block template information.
   * @see {@link IGetBlockTemplateRequest}, {@link IGetBlockTemplateResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetBlockTemplateRequest} request
   * @returns {Promise<IGetBlockTemplateResponse>}
   */
  getBlockTemplate(request) {
    const ret = wasm.rpcclient_getBlockTemplate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Checks if block is blue or not.
   * Returned information: Block blueness.
   * @see {@link IGetCurrentBlockColorRequest}, {@link IGetCurrentBlockColorResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetCurrentBlockColorRequest} request
   * @returns {Promise<IGetCurrentBlockColorResponse>}
   */
  getCurrentBlockColor(request) {
    const ret = wasm.rpcclient_getCurrentBlockColor(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves the estimated DAA (Difficulty Adjustment Algorithm)
   * score timestamp estimate.
   * Returned information: DAA score timestamp estimate.
   * @see {@link IGetDaaScoreTimestampEstimateRequest}, {@link IGetDaaScoreTimestampEstimateResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetDaaScoreTimestampEstimateRequest} request
   * @returns {Promise<IGetDaaScoreTimestampEstimateResponse>}
   */
  getDaaScoreTimestampEstimate(request) {
    const ret = wasm.rpcclient_getDaaScoreTimestampEstimate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Feerate estimates (experimental)
   * @see {@link IGetFeeEstimateExperimentalRequest}, {@link IGetFeeEstimateExperimentalResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetFeeEstimateExperimentalRequest} request
   * @returns {Promise<IGetFeeEstimateExperimentalResponse>}
   */
  getFeeEstimateExperimental(request) {
    const ret = wasm.rpcclient_getFeeEstimateExperimental(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves block headers from the Kaspa BlockDAG.
   * Returned information: List of block headers.
   * @see {@link IGetHeadersRequest}, {@link IGetHeadersResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetHeadersRequest} request
   * @returns {Promise<IGetHeadersResponse>}
   */
  getHeaders(request) {
    const ret = wasm.rpcclient_getHeaders(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves mempool entries from the Kaspa node's mempool.
   * Returned information: List of mempool entries.
   * @see {@link IGetMempoolEntriesRequest}, {@link IGetMempoolEntriesResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetMempoolEntriesRequest} request
   * @returns {Promise<IGetMempoolEntriesResponse>}
   */
  getMempoolEntries(request) {
    const ret = wasm.rpcclient_getMempoolEntries(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves mempool entries associated with specific addresses.
   * Returned information: List of mempool entries.
   * @see {@link IGetMempoolEntriesByAddressesRequest}, {@link IGetMempoolEntriesByAddressesResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetMempoolEntriesByAddressesRequest} request
   * @returns {Promise<IGetMempoolEntriesByAddressesResponse>}
   */
  getMempoolEntriesByAddresses(request) {
    const ret = wasm.rpcclient_getMempoolEntriesByAddresses(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves a specific mempool entry by transaction ID.
   * Returned information: Mempool entry information.
   * @see {@link IGetMempoolEntryRequest}, {@link IGetMempoolEntryResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetMempoolEntryRequest} request
   * @returns {Promise<IGetMempoolEntryResponse>}
   */
  getMempoolEntry(request) {
    const ret = wasm.rpcclient_getMempoolEntry(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves information about a subnetwork in the Kaspa BlockDAG.
   * Returned information: Subnetwork information.
   * @see {@link IGetSubnetworkRequest}, {@link IGetSubnetworkResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetSubnetworkRequest} request
   * @returns {Promise<IGetSubnetworkResponse>}
   */
  getSubnetwork(request) {
    const ret = wasm.rpcclient_getSubnetwork(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves unspent transaction outputs (UTXOs) associated with
   * specific addresses.
   * Returned information: List of UTXOs.
   * @see {@link IGetUtxosByAddressesRequest}, {@link IGetUtxosByAddressesResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetUtxosByAddressesRequest | Address[] | string[]} request
   * @returns {Promise<IGetUtxosByAddressesResponse>}
   */
  getUtxosByAddresses(request) {
    const ret = wasm.rpcclient_getUtxosByAddresses(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Retrieves the virtual chain corresponding to a specified block hash.
   * Returned information: Virtual chain information.
   * @see {@link IGetVirtualChainFromBlockRequest}, {@link IGetVirtualChainFromBlockResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IGetVirtualChainFromBlockRequest} request
   * @returns {Promise<IGetVirtualChainFromBlockResponse>}
   */
  getVirtualChainFromBlock(request) {
    const ret = wasm.rpcclient_getVirtualChainFromBlock(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Resolves a finality conflict in the Kaspa BlockDAG.
   * Returned information: None.
   * @see {@link IResolveFinalityConflictRequest}, {@link IResolveFinalityConflictResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IResolveFinalityConflictRequest} request
   * @returns {Promise<IResolveFinalityConflictResponse>}
   */
  resolveFinalityConflict(request) {
    const ret = wasm.rpcclient_resolveFinalityConflict(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Submits a block to the Kaspa network.
   * Returned information: None.
   * @see {@link ISubmitBlockRequest}, {@link ISubmitBlockResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {ISubmitBlockRequest} request
   * @returns {Promise<ISubmitBlockResponse>}
   */
  submitBlock(request) {
    const ret = wasm.rpcclient_submitBlock(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Submits a transaction to the Kaspa network.
   * Returned information: Submitted Transaction Id.
   * @see {@link ISubmitTransactionRequest}, {@link ISubmitTransactionResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {ISubmitTransactionRequest} request
   * @returns {Promise<ISubmitTransactionResponse>}
   */
  submitTransaction(request) {
    const ret = wasm.rpcclient_submitTransaction(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Submits an RBF transaction to the Kaspa network.
   * Returned information: Submitted Transaction Id, Transaction that was replaced.
   * @see {@link ISubmitTransactionReplacementRequest}, {@link ISubmitTransactionReplacementResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {ISubmitTransactionReplacementRequest} request
   * @returns {Promise<ISubmitTransactionReplacementResponse>}
   */
  submitTransactionReplacement(request) {
    const ret = wasm.rpcclient_submitTransactionReplacement(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * Unbans a previously banned peer, allowing it to connect
   * to the Kaspa node again.
   * Returned information: None.
   * @see {@link IUnbanRequest}, {@link IUnbanResponse}
   * @throws `string` on an RPC error, a server-side error or when supplying incorrect arguments.
   * @param {IUnbanRequest} request
   * @returns {Promise<IUnbanResponse>}
   */
  unban(request) {
    const ret = wasm.rpcclient_unban(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * Manage subscription for a block added notification event.
   * Block added notification event is produced when a new
   * block is added to the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribeBlockAdded() {
    const ret = wasm.rpcclient_subscribeBlockAdded(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribeBlockAdded() {
    const ret = wasm.rpcclient_unsubscribeBlockAdded(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Manage subscription for a finality conflict notification event.
   * Finality conflict notification event is produced when a finality
   * conflict occurs in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribeFinalityConflict() {
    const ret = wasm.rpcclient_subscribeFinalityConflict(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribeFinalityConflict() {
    const ret = wasm.rpcclient_unsubscribeFinalityConflict(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Manage subscription for a finality conflict resolved notification event.
   * Finality conflict resolved notification event is produced when a finality
   * conflict in the Kaspa BlockDAG is resolved.
   * @returns {Promise<void>}
   */
  subscribeFinalityConflictResolved() {
    const ret = wasm.rpcclient_subscribeFinalityConflictResolved(
      this.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribeFinalityConflictResolved() {
    const ret = wasm.rpcclient_unsubscribeFinalityConflictResolved(
      this.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * Manage subscription for a sink blue score changed notification event.
   * Sink blue score changed notification event is produced when the blue
   * score of the sink block changes in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribeSinkBlueScoreChanged() {
    const ret = wasm.rpcclient_subscribeSinkBlueScoreChanged(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribeSinkBlueScoreChanged() {
    const ret = wasm.rpcclient_unsubscribeSinkBlueScoreChanged(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Manage subscription for a pruning point UTXO set override notification event.
   * Pruning point UTXO set override notification event is produced when the
   * UTXO set override for the pruning point changes in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribePruningPointUtxoSetOverride() {
    const ret = wasm.rpcclient_subscribePruningPointUtxoSetOverride(
      this.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribePruningPointUtxoSetOverride() {
    const ret = wasm.rpcclient_unsubscribePruningPointUtxoSetOverride(
      this.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * Manage subscription for a new block template notification event.
   * New block template notification event is produced when a new block
   * template is generated for mining in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribeNewBlockTemplate() {
    const ret = wasm.rpcclient_subscribeNewBlockTemplate(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  unsubscribeNewBlockTemplate() {
    const ret = wasm.rpcclient_unsubscribeNewBlockTemplate(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Manage subscription for a virtual DAA score changed notification event.
   * Virtual DAA score changed notification event is produced when the virtual
   * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  subscribeVirtualDaaScoreChanged() {
    const ret = wasm.rpcclient_subscribeVirtualDaaScoreChanged(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Manage subscription for a virtual DAA score changed notification event.
   * Virtual DAA score changed notification event is produced when the virtual
   * Difficulty Adjustment Algorithm (DAA) score changes in the Kaspa BlockDAG.
   * @returns {Promise<void>}
   */
  unsubscribeVirtualDaaScoreChanged() {
    const ret = wasm.rpcclient_unsubscribeVirtualDaaScoreChanged(
      this.__wbg_ptr
    );
    return takeObject(ret);
  }
  /**
   * Subscribe for a UTXOs changed notification event.
   * UTXOs changed notification event is produced when the set
   * of unspent transaction outputs (UTXOs) changes in the
   * Kaspa BlockDAG. The event notification will be scoped to the
   * provided list of addresses.
   * @param {(Address | string)[]} addresses
   * @returns {Promise<void>}
   */
  subscribeUtxosChanged(addresses) {
    const ret = wasm.rpcclient_subscribeUtxosChanged(
      this.__wbg_ptr,
      addHeapObject(addresses)
    );
    return takeObject(ret);
  }
  /**
   * Unsubscribe from UTXOs changed notification event
   * for a specific set of addresses.
   * @param {(Address | string)[]} addresses
   * @returns {Promise<void>}
   */
  unsubscribeUtxosChanged(addresses) {
    const ret = wasm.rpcclient_unsubscribeUtxosChanged(
      this.__wbg_ptr,
      addHeapObject(addresses)
    );
    return takeObject(ret);
  }
  /**
   * Manage subscription for a virtual chain changed notification event.
   * Virtual chain changed notification event is produced when the virtual
   * chain changes in the Kaspa BlockDAG.
   * @param {boolean} include_accepted_transaction_ids
   * @returns {Promise<void>}
   */
  subscribeVirtualChainChanged(include_accepted_transaction_ids) {
    const ret = wasm.rpcclient_subscribeVirtualChainChanged(
      this.__wbg_ptr,
      include_accepted_transaction_ids
    );
    return takeObject(ret);
  }
  /**
   * Manage subscription for a virtual chain changed notification event.
   * Virtual chain changed notification event is produced when the virtual
   * chain changes in the Kaspa BlockDAG.
   * @param {boolean} include_accepted_transaction_ids
   * @returns {Promise<void>}
   */
  unsubscribeVirtualChainChanged(include_accepted_transaction_ids) {
    const ret = wasm.rpcclient_unsubscribeVirtualChainChanged(
      this.__wbg_ptr,
      include_accepted_transaction_ids
    );
    return takeObject(ret);
  }
  /**
   * @param {Encoding} encoding
   * @param {NetworkType | NetworkId | string} network
   * @returns {number}
   */
  static defaultPort(encoding, network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_defaultPort(retptr, encoding, addBorrowedObject(network));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return r0;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Constructs an WebSocket RPC URL given the partial URL or an IP, RPC encoding
   * and a network type.
   *
   * # Arguments
   *
   * * `url` - Partial URL or an IP address
   * * `encoding` - RPC encoding
   * * `network_type` - Network type
   * @param {string} url
   * @param {Encoding} encoding
   * @param {NetworkId} network
   * @returns {string}
   */
  static parseUrl(url, encoding, network) {
    let deferred4_0;
    let deferred4_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        url,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      _assertClass(network, NetworkId);
      var ptr1 = network.__destroy_into_raw();
      wasm.rpcclient_parseUrl(retptr, ptr0, len0, encoding, ptr1);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr3 = r0;
      var len3 = r1;
      if (r3) {
        ptr3 = 0;
        len3 = 0;
        throw takeObject(r2);
      }
      deferred4_0 = ptr3;
      deferred4_1 = len3;
      return getStringFromWasm0(ptr3, len3);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred4_0, deferred4_1, 1);
    }
  }
  /**
   *
   * Create a new RPC client with optional {@link Encoding} and a `url`.
   *
   * @see {@link IRpcConfig} interface for more details.
   * @param {IRpcConfig | null} [config]
   */
  constructor(config) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_ctor(
        retptr,
        isLikeNone(config) ? 0 : addHeapObject(config)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      RpcClientFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * The current URL of the RPC client.
   * @returns {string | undefined}
   */
  get url() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_url(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Current rpc resolver
   * @returns {Resolver | undefined}
   */
  get resolver() {
    const ret = wasm.rpcclient_resolver(this.__wbg_ptr);
    return ret === 0 ? void 0 : Resolver.__wrap(ret);
  }
  /**
   * Set the resolver for the RPC client.
   * This setting will take effect on the next connection.
   * @param {Resolver} resolver
   */
  setResolver(resolver) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(resolver, Resolver);
      var ptr0 = resolver.__destroy_into_raw();
      wasm.rpcclient_setResolver(retptr, this.__wbg_ptr, ptr0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Set the network id for the RPC client.
   * This setting will take effect on the next connection.
   * @param {NetworkId | string} network_id
   */
  setNetworkId(network_id) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_setNetworkId(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network_id)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * The current connection status of the RPC client.
   * @returns {boolean}
   */
  get isConnected() {
    const ret = wasm.rpcclient_isConnected(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * The current protocol encoding.
   * @returns {string}
   */
  get encoding() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_encoding(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Optional: Resolver node id.
   * @returns {string | undefined}
   */
  get nodeId() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_nodeId(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Connect to the Kaspa RPC server. This function starts a background
   * task that connects and reconnects to the server if the connection
   * is terminated.  Use [`disconnect()`](Self::disconnect()) to
   * terminate the connection.
   * @see {@link IConnectOptions} interface for more details.
   * @param {IConnectOptions | undefined | null} [args]
   * @returns {Promise<void>}
   */
  connect(args) {
    const ret = wasm.rpcclient_connect(
      this.__wbg_ptr,
      isLikeNone(args) ? 0 : addHeapObject(args)
    );
    return takeObject(ret);
  }
  /**
   * Disconnect from the Kaspa RPC server.
   * @returns {Promise<void>}
   */
  disconnect() {
    const ret = wasm.rpcclient_disconnect(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Start background RPC services (automatically started when invoking {@link RpcClient.connect}).
   * @returns {Promise<void>}
   */
  start() {
    const ret = wasm.rpcclient_start(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Stop background RPC services (automatically stopped when invoking {@link RpcClient.disconnect}).
   * @returns {Promise<void>}
   */
  stop() {
    const ret = wasm.rpcclient_stop(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Triggers a disconnection on the underlying WebSocket
   * if the WebSocket is in connected state.
   * This is intended for debug purposes only.
   * Can be used to test application reconnection logic.
   */
  triggerAbort() {
    wasm.rpcclient_triggerAbort(this.__wbg_ptr);
  }
  /**
   *
   * Register an event listener callback.
   *
   * Registers a callback function to be executed when a specific event occurs.
   * The callback function will receive an {@link RpcEvent} object with the event `type` and `data`.
   *
   * **RPC Subscriptions vs Event Listeners**
   *
   * Subscriptions are used to receive notifications from the RPC client.
   * Event listeners are client-side application registrations that are
   * triggered when notifications are received.
   *
   * If node is disconnected, upon reconnection you do not need to re-register event listeners,
   * however, you have to re-subscribe for Kaspa node notifications. As such, it is recommended
   * to register event listeners when the RPC `open` event is received.
   *
   * ```javascript
   * rpc.addEventListener("connect", async (event) => {
   *     console.log("Connected to", rpc.url);
   *     await rpc.subscribeDaaScore();
   *     // ... perform wallet address subscriptions
   * });
   * ```
   *
   * **Multiple events and listeners**
   *
   * `addEventListener` can be used to register multiple event listeners for the same event
   * as well as the same event listener for multiple events.
   *
   * ```javascript
   * // Registering a single event listener for multiple events:
   * rpc.addEventListener(["connect", "disconnect"], (event) => {
   *     console.log(event);
   * });
   *
   * // Registering event listener for all events:
   * // (by omitting the event type)
   * rpc.addEventListener((event) => {
   *     console.log(event);
   * });
   *
   * // Registering multiple event listeners for the same event:
   * rpc.addEventListener("connect", (event) => { // first listener
   *     console.log(event);
   * });
   * rpc.addEventListener("connect", (event) => { // second listener
   *     console.log(event);
   * });
   * ```
   *
   * **Use of context objects**
   *
   * You can also register an event with a `context` object. When the event is triggered,
   * the `handleEvent` method of the `context` object will be called while `this` value
   * will be set to the `context` object.
   * ```javascript
   * // Registering events with a context object:
   *
   * const context = {
   *     someProperty: "someValue",
   *     handleEvent: (event) => {
   *         // the following will log "someValue"
   *         console.log(this.someProperty);
   *         console.log(event);
   *     }
   * };
   * rpc.addEventListener(["connect","disconnect"], context);
   *
   * ```
   *
   * **General use examples**
   *
   * In TypeScript you can use {@link RpcEventType} enum (such as `RpcEventType.Connect`)
   * or `string` (such as "connect") to register event listeners.
   * In JavaScript you can only use `string`.
   *
   * ```typescript
   * // Example usage (TypeScript):
   *
   * rpc.addEventListener(RpcEventType.Connect, (event) => {
   *     console.log("Connected to", rpc.url);
   * });
   *
   * rpc.addEventListener(RpcEventType.VirtualDaaScoreChanged, (event) => {
   *     console.log(event.type,event.data);
   * });
   * await rpc.subscribeDaaScore();
   *
   * rpc.addEventListener(RpcEventType.BlockAdded, (event) => {
   *     console.log(event.type,event.data);
   * });
   * await rpc.subscribeBlockAdded();
   *
   * // Example usage (JavaScript):
   *
   * rpc.addEventListener("virtual-daa-score-changed", (event) => {
   *     console.log(event.type,event.data);
   * });
   *
   * await rpc.subscribeDaaScore();
   * rpc.addEventListener("block-added", (event) => {
   *     console.log(event.type,event.data);
   * });
   * await rpc.subscribeBlockAdded();
   * ```
   *
   * @see {@link RpcEventType} for a list of supported events.
   * @see {@link RpcEventData} for the event data interface specification.
   * @see {@link RpcClient.removeEventListener}, {@link RpcClient.removeAllEventListeners}
   * @param {RpcEventType | string | RpcEventCallback} event
   * @param {RpcEventCallback | null} [callback]
   */
  addEventListener(event, callback) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_addEventListener(
        retptr,
        this.__wbg_ptr,
        addHeapObject(event),
        isLikeNone(callback) ? 0 : addHeapObject(callback)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   *
   * Unregister an event listener.
   * This function will remove the callback for the specified event.
   * If the `callback` is not supplied, all callbacks will be
   * removed for the specified event.
   *
   * @see {@link RpcClient.addEventListener}
   * @param {RpcEventType | string} event
   * @param {RpcEventCallback | null} [callback]
   */
  removeEventListener(event, callback) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_removeEventListener(
        retptr,
        this.__wbg_ptr,
        addHeapObject(event),
        isLikeNone(callback) ? 0 : addHeapObject(callback)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   *
   * Unregister a single event listener callback from all events.
   *
   *
   * @param {RpcEventCallback} callback
   */
  clearEventListener(callback) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_clearEventListener(
        retptr,
        this.__wbg_ptr,
        addHeapObject(callback)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   *
   * Unregister all notification callbacks for all events.
   */
  removeAllEventListeners() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rpcclient_removeAllEventListeners(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_RpcClient, "RpcClient");
var RpcClient = _RpcClient;
var ScriptBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_scriptbuilder_free(ptr >>> 0, 1)
);
var ScriptPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_scriptpublickey_free(ptr >>> 0, 1)
);
var _ScriptPublicKey = class _ScriptPublicKey {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_ScriptPublicKey.prototype);
    obj.__wbg_ptr = ptr;
    ScriptPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      version: this.version,
      script: this.script
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptPublicKeyFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_scriptpublickey_free(ptr, 0);
  }
  /**
   * @returns {number}
   */
  get version() {
    const ret = wasm.__wbg_get_scriptpublickey_version(this.__wbg_ptr);
    return ret;
  }
  /**
   * @param {number} arg0
   */
  set version(arg0) {
    wasm.__wbg_set_scriptpublickey_version(this.__wbg_ptr, arg0);
  }
  /**
   * @param {number} version
   * @param {any} script
   */
  constructor(version, script) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.scriptpublickey_constructor(retptr, version, addHeapObject(script));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      ScriptPublicKeyFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  get script() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.scriptpublickey_script_as_hex(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_ScriptPublicKey, "ScriptPublicKey");
var ScriptPublicKey = _ScriptPublicKey;
var SetAadOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_setaadoptions_free(ptr >>> 0, 1)
);
var SigHashTypeFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_sighashtype_free(ptr >>> 0, 1)
);
var StorageFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_storage_free(ptr >>> 0, 1));
var StreamTransformOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_streamtransformoptions_free(ptr >>> 0, 1)
);
var TransactionFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transaction_free(ptr >>> 0, 1)
);
var _Transaction = class _Transaction {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Transaction.prototype);
    obj.__wbg_ptr = ptr;
    TransactionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      id: this.id,
      inputs: this.inputs,
      outputs: this.outputs,
      version: this.version,
      lockTime: this.lockTime,
      gas: this.gas,
      subnetworkId: this.subnetworkId,
      payload: this.payload,
      mass: this.mass
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transaction_free(ptr, 0);
  }
  /**
   * Determines whether or not a transaction is a coinbase transaction. A coinbase
   * transaction is a special transaction created by miners that distributes fees and block subsidy
   * to the previous blocks' miners, and specifies the script_pub_key that will be used to pay the current
   * miner in future blocks.
   * @returns {boolean}
   */
  is_coinbase() {
    const ret = wasm.transaction_is_coinbase(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * Recompute and finalize the tx id based on updated tx fields
   * @returns {Hash}
   */
  finalize() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_finalize(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Hash2.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Returns the transaction ID
   * @returns {string}
   */
  get id() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_id(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {ITransaction | Transaction} js_value
   */
  constructor(js_value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_constructor(retptr, addBorrowedObject(js_value));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      TransactionFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {TransactionInput[]}
   */
  get inputs() {
    const ret = wasm.transaction_get_inputs_as_js_array(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * Returns a list of unique addresses used by transaction inputs.
   * This method can be used to determine addresses used by transaction inputs
   * in order to select private keys needed for transaction signing.
   * @param {NetworkType | NetworkId | string} network_type
   * @returns {Address[]}
   */
  addresses(network_type) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_addresses(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network_type)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @param {(ITransactionInput | TransactionInput)[]} js_value
   */
  set inputs(js_value) {
    try {
      wasm.transaction_set_inputs_from_js_array(
        this.__wbg_ptr,
        addBorrowedObject(js_value)
      );
    } finally {
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {TransactionOutput[]}
   */
  get outputs() {
    const ret = wasm.transaction_get_outputs_as_js_array(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @param {(ITransactionOutput | TransactionOutput)[]} js_value
   */
  set outputs(js_value) {
    try {
      wasm.transaction_set_outputs_from_js_array(
        this.__wbg_ptr,
        addBorrowedObject(js_value)
      );
    } finally {
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {number}
   */
  get version() {
    const ret = wasm.transaction_version(this.__wbg_ptr);
    return ret;
  }
  /**
   * @param {number} v
   */
  set version(v) {
    wasm.transaction_set_version(this.__wbg_ptr, v);
  }
  /**
   * @returns {bigint}
   */
  get lockTime() {
    const ret = wasm.transaction_lockTime(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} v
   */
  set lockTime(v) {
    wasm.transaction_set_lockTime(this.__wbg_ptr, v);
  }
  /**
   * @returns {bigint}
   */
  get gas() {
    const ret = wasm.transaction_gas(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} v
   */
  set gas(v) {
    wasm.transaction_set_gas(this.__wbg_ptr, v);
  }
  /**
   * @returns {string}
   */
  get subnetworkId() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_get_subnetwork_id_as_hex(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {any} js_value
   */
  set subnetworkId(js_value) {
    wasm.transaction_set_subnetwork_id_from_js_value(
      this.__wbg_ptr,
      addHeapObject(js_value)
    );
  }
  /**
   * @returns {string}
   */
  get payload() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_get_payload_as_hex_string(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {any} js_value
   */
  set payload(js_value) {
    wasm.transaction_set_payload_from_js_value(
      this.__wbg_ptr,
      addHeapObject(js_value)
    );
  }
  /**
   * @returns {bigint}
   */
  get mass() {
    const ret = wasm.transaction_get_mass(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} v
   */
  set mass(v) {
    wasm.transaction_set_mass(this.__wbg_ptr, v);
  }
  /**
   * Serializes the transaction to a pure JavaScript Object.
   * The schema of the JavaScript object is defined by {@link ISerializableTransaction}.
   * @see {@link ISerializableTransaction}
   * @returns {ISerializableTransaction}
   */
  serializeToObject() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_serializeToObject(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Serializes the transaction to a JSON string.
   * The schema of the JSON is defined by {@link ISerializableTransaction}.
   * @returns {string}
   */
  serializeToJSON() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_serializeToJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * Serializes the transaction to a "Safe" JSON schema where it converts all `bigint` values to `string` to avoid potential client-side precision loss.
   * @returns {string}
   */
  serializeToSafeJSON() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_serializeToSafeJSON(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * Deserialize the {@link Transaction} Object from a pure JavaScript Object.
   * @param {any} js_value
   * @returns {Transaction}
   */
  static deserializeFromObject(js_value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transaction_deserializeFromObject(
        retptr,
        addBorrowedObject(js_value)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Transaction.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Deserialize the {@link Transaction} Object from a JSON string.
   * @param {string} json
   * @returns {Transaction}
   */
  static deserializeFromJSON(json) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        json,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.transaction_deserializeFromJSON(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Transaction.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Deserialize the {@link Transaction} Object from a "Safe" JSON schema where all `bigint` values are represented as `string`.
   * @param {string} json
   * @returns {Transaction}
   */
  static deserializeFromSafeJSON(json) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        json,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.transaction_deserializeFromSafeJSON(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _Transaction.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_Transaction, "Transaction");
var Transaction = _Transaction;
var TransactionInputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactioninput_free(ptr >>> 0, 1)
);
var _TransactionInput = class _TransactionInput {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TransactionInput.prototype);
    obj.__wbg_ptr = ptr;
    TransactionInputFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      previousOutpoint: this.previousOutpoint,
      signatureScript: this.signatureScript,
      sequence: this.sequence,
      sigOpCount: this.sigOpCount,
      utxo: this.utxo
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionInputFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transactioninput_free(ptr, 0);
  }
  /**
   * @param {ITransactionInput | TransactionInput} value
   */
  constructor(value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactioninput_constructor(retptr, addBorrowedObject(value));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      TransactionInputFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {TransactionOutpoint}
   */
  get previousOutpoint() {
    const ret = wasm.transactioninput_get_previous_outpoint(this.__wbg_ptr);
    return TransactionOutpoint.__wrap(ret);
  }
  /**
   * @param {any} js_value
   */
  set previousOutpoint(js_value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactioninput_set_previous_outpoint(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(js_value)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @returns {string | undefined}
   */
  get signatureScript() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactioninput_get_signature_script_as_hex(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} js_value
   */
  set signatureScript(js_value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactioninput_set_signature_script_from_js_value(
        retptr,
        this.__wbg_ptr,
        addHeapObject(js_value)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {bigint}
   */
  get sequence() {
    const ret = wasm.transactioninput_get_sequence(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} sequence
   */
  set sequence(sequence) {
    wasm.transactioninput_set_sequence(this.__wbg_ptr, sequence);
  }
  /**
   * @returns {number}
   */
  get sigOpCount() {
    const ret = wasm.transactioninput_get_sig_op_count(this.__wbg_ptr);
    return ret;
  }
  /**
   * @param {number} sig_op_count
   */
  set sigOpCount(sig_op_count) {
    wasm.transactioninput_set_sig_op_count(this.__wbg_ptr, sig_op_count);
  }
  /**
   * @returns {UtxoEntryReference | undefined}
   */
  get utxo() {
    const ret = wasm.transactioninput_get_utxo(this.__wbg_ptr);
    return ret === 0 ? void 0 : UtxoEntryReference.__wrap(ret);
  }
};
__name(_TransactionInput, "TransactionInput");
var TransactionInput = _TransactionInput;
var TransactionOutpointFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionoutpoint_free(ptr >>> 0, 1)
);
var _TransactionOutpoint = class _TransactionOutpoint {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TransactionOutpoint.prototype);
    obj.__wbg_ptr = ptr;
    TransactionOutpointFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      transactionId: this.transactionId,
      index: this.index
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionOutpointFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transactionoutpoint_free(ptr, 0);
  }
  /**
   * @param {Hash} transaction_id
   * @param {number} index
   */
  constructor(transaction_id, index) {
    _assertClass(transaction_id, Hash2);
    var ptr0 = transaction_id.__destroy_into_raw();
    const ret = wasm.transactionoutpoint_ctor(ptr0, index);
    this.__wbg_ptr = ret >>> 0;
    TransactionOutpointFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {string}
   */
  getId() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactionoutpoint_getId(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  get transactionId() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactionoutpoint_transactionId(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {number}
   */
  get index() {
    const ret = wasm.transactionoutpoint_index(this.__wbg_ptr);
    return ret >>> 0;
  }
};
__name(_TransactionOutpoint, "TransactionOutpoint");
var TransactionOutpoint = _TransactionOutpoint;
var TransactionOutputFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionoutput_free(ptr >>> 0, 1)
);
var _TransactionOutput = class _TransactionOutput {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TransactionOutput.prototype);
    obj.__wbg_ptr = ptr;
    TransactionOutputFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      value: this.value,
      scriptPublicKey: this.scriptPublicKey
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionOutputFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transactionoutput_free(ptr, 0);
  }
  /**
   * TransactionOutput constructor
   * @param {bigint} value
   * @param {ScriptPublicKey} script_public_key
   */
  constructor(value, script_public_key) {
    _assertClass(script_public_key, ScriptPublicKey);
    const ret = wasm.transactionoutput_ctor(value, script_public_key.__wbg_ptr);
    this.__wbg_ptr = ret >>> 0;
    TransactionOutputFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {bigint}
   */
  get value() {
    const ret = wasm.transactionoutput_value(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} v
   */
  set value(v) {
    wasm.transactionoutput_set_value(this.__wbg_ptr, v);
  }
  /**
   * @returns {ScriptPublicKey}
   */
  get scriptPublicKey() {
    const ret = wasm.transactionoutput_scriptPublicKey(this.__wbg_ptr);
    return ScriptPublicKey.__wrap(ret);
  }
  /**
   * @param {ScriptPublicKey} v
   */
  set scriptPublicKey(v) {
    _assertClass(v, ScriptPublicKey);
    wasm.transactionoutput_set_scriptPublicKey(this.__wbg_ptr, v.__wbg_ptr);
  }
};
__name(_TransactionOutput, "TransactionOutput");
var TransactionOutput = _TransactionOutput;
var TransactionRecordFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionrecord_free(ptr >>> 0, 1)
);
var _TransactionRecord = class _TransactionRecord {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TransactionRecord.prototype);
    obj.__wbg_ptr = ptr;
    TransactionRecordFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      id: this.id,
      unixtimeMsec: this.unixtimeMsec,
      network: this.network,
      note: this.note,
      metadata: this.metadata,
      value: this.value,
      blockDaaScore: this.blockDaaScore,
      binding: this.binding,
      data: this.data,
      type: this.type
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionRecordFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transactionrecord_free(ptr, 0);
  }
  /**
   * @returns {Hash}
   */
  get id() {
    const ret = wasm.__wbg_get_transactionrecord_id(this.__wbg_ptr);
    return Hash2.__wrap(ret);
  }
  /**
   * @param {Hash} arg0
   */
  set id(arg0) {
    _assertClass(arg0, Hash2);
    var ptr0 = arg0.__destroy_into_raw();
    wasm.__wbg_set_transactionrecord_id(this.__wbg_ptr, ptr0);
  }
  /**
   * Unix time in milliseconds
   * @returns {bigint | undefined}
   */
  get unixtimeMsec() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_transactionrecord_unixtimeMsec(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r2 = getDataViewMemory0().getBigInt64(retptr + 8 * 1, true);
      return r0 === 0 ? void 0 : BigInt.asUintN(64, r2);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Unix time in milliseconds
   * @param {bigint | null} [arg0]
   */
  set unixtimeMsec(arg0) {
    wasm.__wbg_set_transactionrecord_unixtimeMsec(
      this.__wbg_ptr,
      !isLikeNone(arg0),
      isLikeNone(arg0) ? BigInt(0) : arg0
    );
  }
  /**
   * @returns {NetworkId}
   */
  get network() {
    const ret = wasm.__wbg_get_transactionrecord_network(this.__wbg_ptr);
    return NetworkId.__wrap(ret);
  }
  /**
   * @param {NetworkId} arg0
   */
  set network(arg0) {
    _assertClass(arg0, NetworkId);
    var ptr0 = arg0.__destroy_into_raw();
    wasm.__wbg_set_transactionrecord_network(this.__wbg_ptr, ptr0);
  }
  /**
   * @returns {string | undefined}
   */
  get note() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_transactionrecord_note(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [arg0]
   */
  set note(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionrecord_note(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string | undefined}
   */
  get metadata() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_transactionrecord_metadata(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [arg0]
   */
  set metadata(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionrecord_metadata(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @param {bigint} currentDaaScore
   * @returns {string}
   */
  maturityProgress(currentDaaScore) {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactionrecord_maturityProgress(
        retptr,
        this.__wbg_ptr,
        addHeapObject(currentDaaScore)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {bigint}
   */
  get value() {
    const ret = wasm.transactionrecord_value(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {bigint}
   */
  get blockDaaScore() {
    const ret = wasm.transactionrecord_blockDaaScore(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {IBinding}
   */
  get binding() {
    const ret = wasm.transactionrecord_binding(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {ITransactionData}
   */
  get data() {
    const ret = wasm.transactionrecord_data(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {string}
   */
  get type() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.transactionrecord_type(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Check if the transaction record has the given address within the associated UTXO set.
   * @param {Address} address
   * @returns {boolean}
   */
  hasAddress(address) {
    _assertClass(address, Address);
    const ret = wasm.transactionrecord_hasAddress(
      this.__wbg_ptr,
      address.__wbg_ptr
    );
    return ret !== 0;
  }
  /**
   * Serialize the transaction record to a JavaScript object.
   * @returns {any}
   */
  serialize() {
    const ret = wasm.transactionrecord_serialize(this.__wbg_ptr);
    return takeObject(ret);
  }
};
__name(_TransactionRecord, "TransactionRecord");
var TransactionRecord = _TransactionRecord;
var TransactionRecordNotificationFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionrecordnotification_free(ptr >>> 0, 1)
);
var _TransactionRecordNotification = class _TransactionRecordNotification {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_TransactionRecordNotification.prototype);
    obj.__wbg_ptr = ptr;
    TransactionRecordNotificationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      type: this.type,
      data: this.data
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionRecordNotificationFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_transactionrecordnotification_free(ptr, 0);
  }
  /**
   * @returns {string}
   */
  get type() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_transactionrecordnotification_type(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} arg0
   */
  set type(arg0) {
    const ptr0 = passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_transactionrecordnotification_type(
      this.__wbg_ptr,
      ptr0,
      len0
    );
  }
  /**
   * @returns {TransactionRecord}
   */
  get data() {
    const ret = wasm.__wbg_get_transactionrecordnotification_data(
      this.__wbg_ptr
    );
    return TransactionRecord.__wrap(ret);
  }
  /**
   * @param {TransactionRecord} arg0
   */
  set data(arg0) {
    _assertClass(arg0, TransactionRecord);
    var ptr0 = arg0.__destroy_into_raw();
    wasm.__wbg_set_transactionrecordnotification_data(this.__wbg_ptr, ptr0);
  }
};
__name(_TransactionRecordNotification, "TransactionRecordNotification");
var TransactionRecordNotification = _TransactionRecordNotification;
var TransactionSigningHashFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionsigninghash_free(ptr >>> 0, 1)
);
var TransactionSigningHashECDSAFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionsigninghashecdsa_free(ptr >>> 0, 1)
);
var TransactionUtxoEntryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_transactionutxoentry_free(ptr >>> 0, 1)
);
var UserInfoOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_userinfooptions_free(ptr >>> 0, 1)
);
var UtxoContextFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_utxocontext_free(ptr >>> 0, 1)
);
var UtxoEntriesFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_utxoentries_free(ptr >>> 0, 1)
);
var _UtxoEntries = class _UtxoEntries {
  toJSON() {
    return {
      items: this.items
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UtxoEntriesFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_utxoentries_free(ptr, 0);
  }
  /**
   * Create a new `UtxoEntries` struct with a set of entries.
   * @param {any} js_value
   */
  constructor(js_value) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.utxoentries_js_ctor(retptr, addHeapObject(js_value));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      UtxoEntriesFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {any}
   */
  get items() {
    const ret = wasm.utxoentries_get_items_as_js_array(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @param {any} js_value
   */
  set items(js_value) {
    try {
      wasm.utxoentries_set_items_from_js_array(
        this.__wbg_ptr,
        addBorrowedObject(js_value)
      );
    } finally {
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Sort the contained entries by amount. Please note that
   * this function is not intended for use with large UTXO sets
   * as it duplicates the whole contained UTXO set while sorting.
   */
  sort() {
    wasm.utxoentries_sort(this.__wbg_ptr);
  }
  /**
   * @returns {bigint}
   */
  amount() {
    const ret = wasm.utxoentries_amount(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
};
__name(_UtxoEntries, "UtxoEntries");
var UtxoEntries = _UtxoEntries;
var UtxoEntryFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_utxoentry_free(ptr >>> 0, 1)
);
var _UtxoEntry = class _UtxoEntry {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_UtxoEntry.prototype);
    obj.__wbg_ptr = ptr;
    UtxoEntryFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      address: this.address,
      outpoint: this.outpoint,
      amount: this.amount,
      scriptPublicKey: this.scriptPublicKey,
      blockDaaScore: this.blockDaaScore,
      isCoinbase: this.isCoinbase
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UtxoEntryFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_utxoentry_free(ptr, 0);
  }
  /**
   * @returns {Address | undefined}
   */
  get address() {
    const ret = wasm.__wbg_get_utxoentry_address(this.__wbg_ptr);
    return ret === 0 ? void 0 : Address.__wrap(ret);
  }
  /**
   * @param {Address | null} [arg0]
   */
  set address(arg0) {
    let ptr0 = 0;
    if (!isLikeNone(arg0)) {
      _assertClass(arg0, Address);
      ptr0 = arg0.__destroy_into_raw();
    }
    wasm.__wbg_set_utxoentry_address(this.__wbg_ptr, ptr0);
  }
  /**
   * @returns {TransactionOutpoint}
   */
  get outpoint() {
    const ret = wasm.__wbg_get_utxoentry_outpoint(this.__wbg_ptr);
    return TransactionOutpoint.__wrap(ret);
  }
  /**
   * @param {TransactionOutpoint} arg0
   */
  set outpoint(arg0) {
    _assertClass(arg0, TransactionOutpoint);
    var ptr0 = arg0.__destroy_into_raw();
    wasm.__wbg_set_utxoentry_outpoint(this.__wbg_ptr, ptr0);
  }
  /**
   * @returns {bigint}
   */
  get amount() {
    const ret = wasm.__wbg_get_utxoentry_amount(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} arg0
   */
  set amount(arg0) {
    wasm.__wbg_set_utxoentry_amount(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {ScriptPublicKey}
   */
  get scriptPublicKey() {
    const ret = wasm.__wbg_get_utxoentry_scriptPublicKey(this.__wbg_ptr);
    return ScriptPublicKey.__wrap(ret);
  }
  /**
   * @param {ScriptPublicKey} arg0
   */
  set scriptPublicKey(arg0) {
    _assertClass(arg0, ScriptPublicKey);
    var ptr0 = arg0.__destroy_into_raw();
    wasm.__wbg_set_utxoentry_scriptPublicKey(this.__wbg_ptr, ptr0);
  }
  /**
   * @returns {bigint}
   */
  get blockDaaScore() {
    const ret = wasm.__wbg_get_utxoentry_blockDaaScore(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @param {bigint} arg0
   */
  set blockDaaScore(arg0) {
    wasm.__wbg_set_utxoentry_blockDaaScore(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {boolean}
   */
  get isCoinbase() {
    const ret = wasm.__wbg_get_utxoentry_isCoinbase(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {boolean} arg0
   */
  set isCoinbase(arg0) {
    wasm.__wbg_set_utxoentry_isCoinbase(this.__wbg_ptr, arg0);
  }
  /**
   * @returns {string}
   */
  toString() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.utxoentry_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_UtxoEntry, "UtxoEntry");
var UtxoEntry = _UtxoEntry;
var UtxoEntryReferenceFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_utxoentryreference_free(ptr >>> 0, 1)
);
var _UtxoEntryReference = class _UtxoEntryReference {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_UtxoEntryReference.prototype);
    obj.__wbg_ptr = ptr;
    UtxoEntryReferenceFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      entry: this.entry,
      outpoint: this.outpoint,
      address: this.address,
      amount: this.amount,
      isCoinbase: this.isCoinbase,
      blockDaaScore: this.blockDaaScore,
      scriptPublicKey: this.scriptPublicKey
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UtxoEntryReferenceFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_utxoentryreference_free(ptr, 0);
  }
  /**
   * @returns {string}
   */
  toString() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.utxoentryreference_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {UtxoEntry}
   */
  get entry() {
    const ret = wasm.utxoentryreference_entry(this.__wbg_ptr);
    return UtxoEntry.__wrap(ret);
  }
  /**
   * @returns {TransactionOutpoint}
   */
  get outpoint() {
    const ret = wasm.utxoentryreference_outpoint(this.__wbg_ptr);
    return TransactionOutpoint.__wrap(ret);
  }
  /**
   * @returns {Address | undefined}
   */
  get address() {
    const ret = wasm.utxoentryreference_address(this.__wbg_ptr);
    return ret === 0 ? void 0 : Address.__wrap(ret);
  }
  /**
   * @returns {bigint}
   */
  get amount() {
    const ret = wasm.utxoentryreference_amount(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @returns {boolean}
   */
  get isCoinbase() {
    const ret = wasm.utxoentryreference_isCoinbase(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {bigint}
   */
  get blockDaaScore() {
    const ret = wasm.utxoentryreference_blockDaaScore(this.__wbg_ptr);
    return BigInt.asUintN(64, ret);
  }
  /**
   * @returns {ScriptPublicKey}
   */
  get scriptPublicKey() {
    const ret = wasm.utxoentryreference_scriptPublicKey(this.__wbg_ptr);
    return ScriptPublicKey.__wrap(ret);
  }
};
__name(_UtxoEntryReference, "UtxoEntryReference");
var UtxoEntryReference = _UtxoEntryReference;
var UtxoProcessorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_utxoprocessor_free(ptr >>> 0, 1)
);
var WalletFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_wallet_free(ptr >>> 0, 1));
var _Wallet = class _Wallet {
  toJSON() {
    return {
      rpc: this.rpc,
      isOpen: this.isOpen,
      isSynced: this.isSynced,
      descriptor: this.descriptor
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WalletFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_wallet_free(ptr, 0);
  }
  /**
   * @param {IWalletConfig} config
   */
  constructor(config) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.wallet_constructor(retptr, addHeapObject(config));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      WalletFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {RpcClient}
   */
  get rpc() {
    const ret = wasm.wallet_rpc(this.__wbg_ptr);
    return RpcClient.__wrap(ret);
  }
  /**
   * @remarks This is a local property indicating
   * if the wallet is currently open.
   * @returns {boolean}
   */
  get isOpen() {
    const ret = wasm.wallet_isOpen(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @remarks This is a local property indicating
   * if the node is currently synced.
   * @returns {boolean}
   */
  get isSynced() {
    const ret = wasm.wallet_isSynced(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {WalletDescriptor | undefined}
   */
  get descriptor() {
    const ret = wasm.wallet_descriptor(this.__wbg_ptr);
    return ret === 0 ? void 0 : WalletDescriptor.__wrap(ret);
  }
  /**
   * Check if a wallet with a given name exists.
   * @param {string | null} [name]
   * @returns {Promise<boolean>}
   */
  exists(name) {
    var ptr0 = isLikeNone(name) ? 0 : passStringToWasm0(
      name,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    var len0 = WASM_VECTOR_LEN;
    const ret = wasm.wallet_exists(this.__wbg_ptr, ptr0, len0);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  start() {
    const ret = wasm.wallet_start(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  stop() {
    const ret = wasm.wallet_stop(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @param {IConnectOptions | undefined | null} [args]
   * @returns {Promise<void>}
   */
  connect(args) {
    const ret = wasm.wallet_connect(
      this.__wbg_ptr,
      isLikeNone(args) ? 0 : addHeapObject(args)
    );
    return takeObject(ret);
  }
  /**
   * @returns {Promise<void>}
   */
  disconnect() {
    const ret = wasm.wallet_disconnect(this.__wbg_ptr);
    return takeObject(ret);
  }
  /**
   * @param {string | WalletNotificationCallback} event
   * @param {WalletNotificationCallback | null} [callback]
   */
  addEventListener(event, callback) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.wallet_addEventListener(
        retptr,
        this.__wbg_ptr,
        addHeapObject(event),
        isLikeNone(callback) ? 0 : addHeapObject(callback)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {WalletEventType | WalletEventType[] | string | string[]} event
   * @param {WalletNotificationCallback | null} [callback]
   */
  removeEventListener(event, callback) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.wallet_removeEventListener(
        retptr,
        this.__wbg_ptr,
        addHeapObject(event),
        isLikeNone(callback) ? 0 : addHeapObject(callback)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {NetworkId | string} network_id
   */
  setNetworkId(network_id) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.wallet_setNetworkId(
        retptr,
        this.__wbg_ptr,
        addHeapObject(network_id)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Ping backend
   * @see {@link IBatchRequest} {@link IBatchResponse}
   * @throws `string` in case of an error.
   * @param {IBatchRequest} request
   * @returns {Promise<IBatchResponse>}
   */
  batch(request) {
    const ret = wasm.wallet_batch(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IFlushRequest} {@link IFlushResponse}
   * @throws `string` in case of an error.
   * @param {IFlushRequest} request
   * @returns {Promise<IFlushResponse>}
   */
  flush(request) {
    const ret = wasm.wallet_flush(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IRetainContextRequest} {@link IRetainContextResponse}
   * @throws `string` in case of an error.
   * @param {IRetainContextRequest} request
   * @returns {Promise<IRetainContextResponse>}
   */
  retainContext(request) {
    const ret = wasm.wallet_retainContext(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IGetStatusRequest} {@link IGetStatusResponse}
   * @throws `string` in case of an error.
   * @param {IGetStatusRequest} request
   * @returns {Promise<IGetStatusResponse>}
   */
  getStatus(request) {
    const ret = wasm.wallet_getStatus(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletEnumerateRequest} {@link IWalletEnumerateResponse}
   * @throws `string` in case of an error.
   * @param {IWalletEnumerateRequest} request
   * @returns {Promise<IWalletEnumerateResponse>}
   */
  walletEnumerate(request) {
    const ret = wasm.wallet_walletEnumerate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletCreateRequest} {@link IWalletCreateResponse}
   * @throws `string` in case of an error.
   * @param {IWalletCreateRequest} request
   * @returns {Promise<IWalletCreateResponse>}
   */
  walletCreate(request) {
    const ret = wasm.wallet_walletCreate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletOpenRequest} {@link IWalletOpenResponse}
   * @throws `string` in case of an error.
   * @param {IWalletOpenRequest} request
   * @returns {Promise<IWalletOpenResponse>}
   */
  walletOpen(request) {
    const ret = wasm.wallet_walletOpen(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletReloadRequest} {@link IWalletReloadResponse}
   * @throws `string` in case of an error.
   * @param {IWalletReloadRequest} request
   * @returns {Promise<IWalletReloadResponse>}
   */
  walletReload(request) {
    const ret = wasm.wallet_walletReload(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletCloseRequest} {@link IWalletCloseResponse}
   * @throws `string` in case of an error.
   * @param {IWalletCloseRequest} request
   * @returns {Promise<IWalletCloseResponse>}
   */
  walletClose(request) {
    const ret = wasm.wallet_walletClose(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletChangeSecretRequest} {@link IWalletChangeSecretResponse}
   * @throws `string` in case of an error.
   * @param {IWalletChangeSecretRequest} request
   * @returns {Promise<IWalletChangeSecretResponse>}
   */
  walletChangeSecret(request) {
    const ret = wasm.wallet_walletChangeSecret(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletExportRequest} {@link IWalletExportResponse}
   * @throws `string` in case of an error.
   * @param {IWalletExportRequest} request
   * @returns {Promise<IWalletExportResponse>}
   */
  walletExport(request) {
    const ret = wasm.wallet_walletExport(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IWalletImportRequest} {@link IWalletImportResponse}
   * @throws `string` in case of an error.
   * @param {IWalletImportRequest} request
   * @returns {Promise<IWalletImportResponse>}
   */
  walletImport(request) {
    const ret = wasm.wallet_walletImport(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IPrvKeyDataEnumerateRequest} {@link IPrvKeyDataEnumerateResponse}
   * @throws `string` in case of an error.
   * @param {IPrvKeyDataEnumerateRequest} request
   * @returns {Promise<IPrvKeyDataEnumerateResponse>}
   */
  prvKeyDataEnumerate(request) {
    const ret = wasm.wallet_prvKeyDataEnumerate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IPrvKeyDataCreateRequest} {@link IPrvKeyDataCreateResponse}
   * @throws `string` in case of an error.
   * @param {IPrvKeyDataCreateRequest} request
   * @returns {Promise<IPrvKeyDataCreateResponse>}
   */
  prvKeyDataCreate(request) {
    const ret = wasm.wallet_prvKeyDataCreate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IPrvKeyDataRemoveRequest} {@link IPrvKeyDataRemoveResponse}
   * @throws `string` in case of an error.
   * @param {IPrvKeyDataRemoveRequest} request
   * @returns {Promise<IPrvKeyDataRemoveResponse>}
   */
  prvKeyDataRemove(request) {
    const ret = wasm.wallet_prvKeyDataRemove(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IPrvKeyDataGetRequest} {@link IPrvKeyDataGetResponse}
   * @throws `string` in case of an error.
   * @param {IPrvKeyDataGetRequest} request
   * @returns {Promise<IPrvKeyDataGetResponse>}
   */
  prvKeyDataGet(request) {
    const ret = wasm.wallet_prvKeyDataGet(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsEnumerateRequest} {@link IAccountsEnumerateResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsEnumerateRequest} request
   * @returns {Promise<IAccountsEnumerateResponse>}
   */
  accountsEnumerate(request) {
    const ret = wasm.wallet_accountsEnumerate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsRenameRequest} {@link IAccountsRenameResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsRenameRequest} request
   * @returns {Promise<IAccountsRenameResponse>}
   */
  accountsRename(request) {
    const ret = wasm.wallet_accountsRename(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsDiscoveryRequest} {@link IAccountsDiscoveryResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsDiscoveryRequest} request
   * @returns {Promise<IAccountsDiscoveryResponse>}
   */
  accountsDiscovery(request) {
    const ret = wasm.wallet_accountsDiscovery(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsCreateRequest} {@link IAccountsCreateResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsCreateRequest} request
   * @returns {Promise<IAccountsCreateResponse>}
   */
  accountsCreate(request) {
    const ret = wasm.wallet_accountsCreate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsEnsureDefaultRequest} {@link IAccountsEnsureDefaultResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsEnsureDefaultRequest} request
   * @returns {Promise<IAccountsEnsureDefaultResponse>}
   */
  accountsEnsureDefault(request) {
    const ret = wasm.wallet_accountsEnsureDefault(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsImportRequest} {@link IAccountsImportResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsImportRequest} request
   * @returns {Promise<IAccountsImportResponse>}
   */
  accountsImport(request) {
    const ret = wasm.wallet_accountsImport(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsActivateRequest} {@link IAccountsActivateResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsActivateRequest} request
   * @returns {Promise<IAccountsActivateResponse>}
   */
  accountsActivate(request) {
    const ret = wasm.wallet_accountsActivate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsDeactivateRequest} {@link IAccountsDeactivateResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsDeactivateRequest} request
   * @returns {Promise<IAccountsDeactivateResponse>}
   */
  accountsDeactivate(request) {
    const ret = wasm.wallet_accountsDeactivate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsGetRequest} {@link IAccountsGetResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsGetRequest} request
   * @returns {Promise<IAccountsGetResponse>}
   */
  accountsGet(request) {
    const ret = wasm.wallet_accountsGet(this.__wbg_ptr, addHeapObject(request));
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsCreateNewAddressRequest} {@link IAccountsCreateNewAddressResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsCreateNewAddressRequest} request
   * @returns {Promise<IAccountsCreateNewAddressResponse>}
   */
  accountsCreateNewAddress(request) {
    const ret = wasm.wallet_accountsCreateNewAddress(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsSendRequest} {@link IAccountsSendResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsSendRequest} request
   * @returns {Promise<IAccountsSendResponse>}
   */
  accountsSend(request) {
    const ret = wasm.wallet_accountsSend(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsPskbSignRequest} {@link IAccountsPskbSignResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsPskbSignRequest} request
   * @returns {Promise<IAccountsPskbSignResponse>}
   */
  accountsPskbSign(request) {
    const ret = wasm.wallet_accountsPskbSign(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsPskbBroadcastRequest} {@link IAccountsPskbBroadcastResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsPskbBroadcastRequest} request
   * @returns {Promise<IAccountsPskbBroadcastResponse>}
   */
  accountsPskbBroadcast(request) {
    const ret = wasm.wallet_accountsPskbBroadcast(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsPskbSendRequest} {@link IAccountsPskbSendResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsPskbSendRequest} request
   * @returns {Promise<IAccountsPskbSendResponse>}
   */
  accountsPskbSend(request) {
    const ret = wasm.wallet_accountsPskbSend(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsGetUtxosRequest} {@link IAccountsGetUtxosResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsGetUtxosRequest} request
   * @returns {Promise<IAccountsGetUtxosResponse>}
   */
  accountsGetUtxos(request) {
    const ret = wasm.wallet_accountsGetUtxos(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsTransferRequest} {@link IAccountsTransferResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsTransferRequest} request
   * @returns {Promise<IAccountsTransferResponse>}
   */
  accountsTransfer(request) {
    const ret = wasm.wallet_accountsTransfer(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsEstimateRequest} {@link IAccountsEstimateResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsEstimateRequest} request
   * @returns {Promise<IAccountsEstimateResponse>}
   */
  accountsEstimate(request) {
    const ret = wasm.wallet_accountsEstimate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link ITransactionsDataGetRequest} {@link ITransactionsDataGetResponse}
   * @throws `string` in case of an error.
   * @param {ITransactionsDataGetRequest} request
   * @returns {Promise<ITransactionsDataGetResponse>}
   */
  transactionsDataGet(request) {
    const ret = wasm.wallet_transactionsDataGet(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link ITransactionsReplaceNoteRequest} {@link ITransactionsReplaceNoteResponse}
   * @throws `string` in case of an error.
   * @param {ITransactionsReplaceNoteRequest} request
   * @returns {Promise<ITransactionsReplaceNoteResponse>}
   */
  transactionsReplaceNote(request) {
    const ret = wasm.wallet_transactionsReplaceNote(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link ITransactionsReplaceMetadataRequest} {@link ITransactionsReplaceMetadataResponse}
   * @throws `string` in case of an error.
   * @param {ITransactionsReplaceMetadataRequest} request
   * @returns {Promise<ITransactionsReplaceMetadataResponse>}
   */
  transactionsReplaceMetadata(request) {
    const ret = wasm.wallet_transactionsReplaceMetadata(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAddressBookEnumerateRequest} {@link IAddressBookEnumerateResponse}
   * @throws `string` in case of an error.
   * @param {IAddressBookEnumerateRequest} request
   * @returns {Promise<IAddressBookEnumerateResponse>}
   */
  addressBookEnumerate(request) {
    const ret = wasm.wallet_addressBookEnumerate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IFeeRateEstimateRequest} {@link IFeeRateEstimateResponse}
   * @throws `string` in case of an error.
   * @param {IFeeRateEstimateRequest} request
   * @returns {Promise<IFeeRateEstimateResponse>}
   */
  feeRateEstimate(request) {
    const ret = wasm.wallet_feeRateEstimate(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IFeeRatePollerEnableRequest} {@link IFeeRatePollerEnableResponse}
   * @throws `string` in case of an error.
   * @param {IFeeRatePollerEnableRequest} request
   * @returns {Promise<IFeeRatePollerEnableResponse>}
   */
  feeRatePollerEnable(request) {
    const ret = wasm.wallet_feeRatePollerEnable(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IFeeRatePollerDisableRequest} {@link IFeeRatePollerDisableResponse}
   * @throws `string` in case of an error.
   * @param {IFeeRatePollerDisableRequest} request
   * @returns {Promise<IFeeRatePollerDisableResponse>}
   */
  feeRatePollerDisable(request) {
    const ret = wasm.wallet_feeRatePollerDisable(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsCommitRevealRequest} {@link IAccountsCommitRevealResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsCommitRevealRequest} request
   * @returns {Promise<IAccountsCommitRevealResponse>}
   */
  accountsCommitReveal(request) {
    const ret = wasm.wallet_accountsCommitReveal(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
  /**
   * @see {@link IAccountsCommitRevealManualRequest} {@link IAccountsCommitRevealManualResponse}
   * @throws `string` in case of an error.
   * @param {IAccountsCommitRevealManualRequest} request
   * @returns {Promise<IAccountsCommitRevealManualResponse>}
   */
  accountsCommitRevealManual(request) {
    const ret = wasm.wallet_accountsCommitRevealManual(
      this.__wbg_ptr,
      addHeapObject(request)
    );
    return takeObject(ret);
  }
};
__name(_Wallet, "Wallet");
var Wallet = _Wallet;
var WalletDescriptorFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_walletdescriptor_free(ptr >>> 0, 1)
);
var _WalletDescriptor = class _WalletDescriptor {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_WalletDescriptor.prototype);
    obj.__wbg_ptr = ptr;
    WalletDescriptorFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      title: this.title,
      filename: this.filename
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WalletDescriptorFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_walletdescriptor_free(ptr, 0);
  }
  /**
   * @returns {string | undefined}
   */
  get title() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_walletdescriptor_title(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | null} [arg0]
   */
  set title(arg0) {
    var ptr0 = isLikeNone(arg0) ? 0 : passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    var len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_walletdescriptor_title(this.__wbg_ptr, ptr0, len0);
  }
  /**
   * @returns {string}
   */
  get filename() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.__wbg_get_walletdescriptor_filename(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} arg0
   */
  set filename(arg0) {
    const ptr0 = passStringToWasm0(
      arg0,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len0 = WASM_VECTOR_LEN;
    wasm.__wbg_set_walletdescriptor_filename(this.__wbg_ptr, ptr0, len0);
  }
};
__name(_WalletDescriptor, "WalletDescriptor");
var WalletDescriptor = _WalletDescriptor;
var WasiOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_wasioptions_free(ptr >>> 0, 1)
);
var WriteFileSyncOptionsFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_writefilesyncoptions_free(ptr >>> 0, 1)
);
var WriteStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_writestream_free(ptr >>> 0, 1)
);
var XOnlyPublicKeyFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry(
  (ptr) => wasm.__wbg_xonlypublickey_free(ptr >>> 0, 1)
);
var _XOnlyPublicKey = class _XOnlyPublicKey {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_XOnlyPublicKey.prototype);
    obj.__wbg_ptr = ptr;
    XOnlyPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    XOnlyPublicKeyFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_xonlypublickey_free(ptr, 0);
  }
  /**
   * @param {string} key
   */
  constructor(key) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        key,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.xonlypublickey_try_new(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      XOnlyPublicKeyFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xonlypublickey_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get the [`Address`] of this XOnlyPublicKey.
   * Receives a [`NetworkType`] to determine the prefix of the address.
   * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddress(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xonlypublickey_toAddress(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * Get `ECDSA` [`Address`] of this XOnlyPublicKey.
   * Receives a [`NetworkType`] to determine the prefix of the address.
   * JavaScript: `let address = xOnlyPublicKey.toAddress(NetworkType.MAINNET);`.
   * @param {NetworkType | NetworkId | string} network
   * @returns {Address}
   */
  toAddressECDSA(network) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xonlypublickey_toAddressECDSA(
        retptr,
        this.__wbg_ptr,
        addBorrowedObject(network)
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @param {Address} address
   * @returns {XOnlyPublicKey}
   */
  static fromAddress(address) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(address, Address);
      wasm.xonlypublickey_fromAddress(retptr, address.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XOnlyPublicKey.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
__name(_XOnlyPublicKey, "XOnlyPublicKey");
var XOnlyPublicKey = _XOnlyPublicKey;
var XPrvFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_xprv_free(ptr >>> 0, 1));
var _XPrv = class _XPrv {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_XPrv.prototype);
    obj.__wbg_ptr = ptr;
    XPrvFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      xprv: this.xprv,
      privateKey: this.privateKey,
      depth: this.depth,
      parentFingerprint: this.parentFingerprint,
      childNumber: this.childNumber,
      chainCode: this.chainCode
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    XPrvFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_xprv_free(ptr, 0);
  }
  /**
   * @param {HexString} seed
   */
  constructor(seed) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_try_new(retptr, addHeapObject(seed));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      XPrvFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Create {@link XPrv} from `xprvxxxx..` string
   * @param {string} xprv
   * @returns {XPrv}
   */
  static fromXPrv(xprv) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        xprv,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.xprv_fromXPrv(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XPrv.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} child_number
   * @param {boolean | null} [hardened]
   * @returns {XPrv}
   */
  deriveChild(child_number, hardened) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_deriveChild(
        retptr,
        this.__wbg_ptr,
        child_number,
        isLikeNone(hardened) ? 16777215 : hardened ? 1 : 0
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XPrv.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} path
   * @returns {XPrv}
   */
  derivePath(path) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_derivePath(retptr, this.__wbg_ptr, addBorrowedObject(path));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XPrv.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  intoString(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        prefix,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.xprv_intoString(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0;
        len2 = 0;
        throw takeObject(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0(ptr2, len2);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  toString() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {XPub}
   */
  toXPub() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_toXPub(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return XPub.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PrivateKey}
   */
  toPrivateKey() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_toPrivateKey(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  get xprv() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_toString(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  get privateKey() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_privateKey(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {number}
   */
  get depth() {
    const ret = wasm.xprv_depth(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {string}
   */
  get parentFingerprint() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_parentFingerprint(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {number}
   */
  get childNumber() {
    const ret = wasm.xprv_childNumber(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {string}
   */
  get chainCode() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xprv_chainCode(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_XPrv, "XPrv");
var XPrv = _XPrv;
var XPubFinalization = typeof FinalizationRegistry === "undefined" ? { register: /* @__PURE__ */ __name(() => {
}, "register"), unregister: /* @__PURE__ */ __name(() => {
}, "unregister") } : new FinalizationRegistry((ptr) => wasm.__wbg_xpub_free(ptr >>> 0, 1));
var _XPub = class _XPub {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_XPub.prototype);
    obj.__wbg_ptr = ptr;
    XPubFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  toJSON() {
    return {
      xpub: this.xpub,
      depth: this.depth,
      parentFingerprint: this.parentFingerprint,
      childNumber: this.childNumber,
      chainCode: this.chainCode
    };
  }
  toString() {
    return JSON.stringify(this);
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    XPubFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_xpub_free(ptr, 0);
  }
  /**
   * @param {string} xpub
   */
  constructor(xpub) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        xpub,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.xpub_try_new(retptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      this.__wbg_ptr = r0 >>> 0;
      XPubFinalization.register(this, this.__wbg_ptr, this);
      return this;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} child_number
   * @param {boolean | null} [hardened]
   * @returns {XPub}
   */
  deriveChild(child_number, hardened) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xpub_deriveChild(
        retptr,
        this.__wbg_ptr,
        child_number,
        isLikeNone(hardened) ? 16777215 : hardened ? 1 : 0
      );
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XPub.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {any} path
   * @returns {XPub}
   */
  derivePath(path) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xpub_derivePath(retptr, this.__wbg_ptr, addBorrowedObject(path));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return _XPub.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      heap[stack_pointer++] = void 0;
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  intoString(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(
        prefix,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len0 = WASM_VECTOR_LEN;
      wasm.xpub_intoString(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0;
        len2 = 0;
        throw takeObject(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0(ptr2, len2);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @returns {PublicKey}
   */
  toPublicKey() {
    const ret = wasm.xpub_toPublicKey(this.__wbg_ptr);
    return PublicKey.__wrap(ret);
  }
  /**
   * @returns {string}
   */
  get xpub() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xpub_xpub(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0;
        len1 = 0;
        throw takeObject(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0(ptr1, len1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {number}
   */
  get depth() {
    const ret = wasm.xpub_depth(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {string}
   */
  get parentFingerprint() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xpub_parentFingerprint(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {number}
   */
  get childNumber() {
    const ret = wasm.xpub_childNumber(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {string}
   */
  get chainCode() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.xpub_chainCode(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_export_3(deferred1_0, deferred1_1, 1);
    }
  }
};
__name(_XPub, "XPub");
var XPub = _XPub;
async function __wbg_load(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e
          );
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
__name(__wbg_load, "__wbg_load");
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_BigInt_470dd987b8190f8e = function(arg0) {
    const ret = BigInt(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_BigInt_ddea6d2f55558acb = function() {
    return handleError(function(arg0) {
      const ret = BigInt(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_Window_b0044ac7db258535 = function(arg0) {
    const ret = getObject(arg0).Window;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_WorkerGlobalScope_b74cefefc62a37da = function(arg0) {
    const ret = getObject(arg0).WorkerGlobalScope;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_abort_775ef1d17fc65868 = function(arg0) {
    getObject(arg0).abort();
  };
  imports.wbg.__wbg_aborted_new = function(arg0) {
    const ret = Aborted.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_accountkind_new = function(arg0) {
    const ret = AccountKind.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_addListener_d78339dd4535b756 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).addListener(
      getStringFromWasm0(arg1, arg2),
      getObject(arg3)
    );
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_address_new = function(arg0) {
    const ret = Address.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_advance_b3ccc91b80962d79 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).advance(arg1 >>> 0);
    }, arguments);
  };
  imports.wbg.__wbg_appendChild_8204974b7328bf98 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).appendChild(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_append_8c7dd8d641a5f01b = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).append(
        getStringFromWasm0(arg1, arg2),
        getStringFromWasm0(arg3, arg4)
      );
    }, arguments);
  };
  imports.wbg.__wbg_body_942ea927546a04ba = function(arg0) {
    const ret = getObject(arg0).body;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_672a4d21634d4a24 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_cancelAnimationFrame_032049cb190240a7 = function(arg0) {
    cancelAnimationFrame(takeObject(arg0));
  };
  imports.wbg.__wbg_clearInterval_d472232e2fb5e5e4 = function() {
    return handleError(function(arg0) {
      clearInterval(getObject(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_clearTimeout_c5ac0f4b6a07b59e = function() {
    return handleError(function(arg0) {
      clearTimeout(getObject(arg0));
    }, arguments);
  };
  imports.wbg.__wbg_close_0880036443561527 = function() {
    return handleError(function(arg0) {
      getObject(arg0).close();
    }, arguments);
  };
  imports.wbg.__wbg_continue_c46c11d3dbe1b030 = function() {
    return handleError(function(arg0) {
      getObject(arg0).continue();
    }, arguments);
  };
  imports.wbg.__wbg_count_613cb921d67a4f26 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).count();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createElement_8c9931a732ee2fea = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createIndex_873ac48adc772309 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      const ret = getObject(arg0).createIndex(
        getStringFromWasm0(arg1, arg2),
        getObject(arg3),
        getObject(arg4)
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectStore_e566459f7161f82f = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).createObjectStore(
        getStringFromWasm0(arg1, arg2)
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_6e98d2f9c7bd9764 = function() {
    return handleError(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject(arg1));
      const ptr1 = passStringToWasm0(
        ret,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_data_432d9c3df2630942 = function(arg0) {
    const ret = getObject(arg0).data;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_delete_200677093b4cf756 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).delete(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_delete_36c8630e530a2a1a = function(arg0, arg1) {
    const ret = getObject(arg0).delete(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_document_d249400bd7bd996d = function(arg0) {
    const ret = getObject(arg0).document;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_done_769e5ede4b31c67b = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_entries_3265d4158b33e5dc = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_entries_c8a90a7ed73e84ce = function(arg0) {
    const ret = getObject(arg0).entries();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_error_5edc95999c70d386 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbg_error_b5d62a6100a65a3b = function(arg0, arg1) {
    console.error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_error_ff4ddaabdfc5dbb3 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).error;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_existsSync_6b2031627aea3e5a = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).existsSync(getStringFromWasm0(arg1, arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_fetch_509096533071c657 = function(arg0, arg1) {
    const ret = getObject(arg0).fetch(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fetch_7bb58c5ed3c31810 = function(arg0) {
    const ret = fetch(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_fromCodePoint_f37c25c172f2e8b5 = function() {
    return handleError(function(arg0) {
      const ret = String.fromCodePoint(arg0 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_from_2a5d3e218e67aa85 = function(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_from_d608a04300bfd9ac = function(arg0) {
    const ret = Buffer.from(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_generatorsummary_new = function(arg0) {
    const ret = GeneratorSummary.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getItem_17f98dee3b43fa7e = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg1).getItem(getStringFromWasm0(arg2, arg3));
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(
        ret,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).getRandomValues(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_get_13495dac72693ecc = function(arg0, arg1) {
    const ret = getObject(arg0).get(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_67b2ba62fc30de12 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_8da03f81f6a1111e = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).get(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_get_a8e28596722a45ff = function() {
    return handleError(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.get(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      } finally {
        wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_get_b9b93047fe3cf45b = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_f1f75752f252b231 = function() {
    return handleError(function() {
      const ret = chrome.storage.local.get();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
    const ret = getObject(arg0)[getObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_global_b6f5c73312f62313 = function(arg0) {
    const ret = getObject(arg0).global;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_has_a5ea9117f258a0ec = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.has(getObject(arg0), getObject(arg1));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_hash_new = function(arg0) {
    const ret = Hash2.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_headers_9cb51cfd2ac780a4 = function(arg0) {
    const ret = getObject(arg0).headers;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_index_e00ca5fff206ee3e = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).index(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_601ec26c63e333de = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_b1f49280282046f8 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_indexedDB_f6b47b0dc333fd2f = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).indexedDB;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_innerHTML_e1553352fe93921a = function(arg0, arg1) {
    const ret = getObject(arg1).innerHTML;
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Map_f3469ce2244d2430 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Map;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Object_7f2dcef8f78644a4 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Object;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Response_f2cc20d9f7dfd644 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Response;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Window;
    } catch (_) {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_isArray_a1eab7e0d067391b = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_isSafeInteger_343e2beeeece1bb0 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_is_c7481c65e7e5df9e = function(arg0, arg1) {
    const ret = Object.is(getObject(arg0), getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_iterator_9a24c88df860dc65 = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_key_c5e0a01cf450dca2 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg1).key(arg2 >>> 0);
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(
        ret,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      var len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_keys_5c77a08ddc2fb8a6 = function(arg0) {
    const ret = Object.keys(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_a446193dc22c12f8 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_e2d2a49132c1b256 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_length_ed4a84b02b798bda = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_localStorage_1406c99c39728187 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).localStorage;
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_location_350d99456c2f3693 = function(arg0) {
    const ret = getObject(arg0).location;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_log_6c164928aa7b57f4 = function(arg0, arg1) {
    console.log(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_mkdirSync_29d1fd92bf140bd0 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      getObject(arg0).mkdirSync(
        getStringFromWasm0(arg1, arg2),
        takeObject(arg3)
      );
    }, arguments);
  };
  imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_navigator_1577371c070c8947 = function(arg0) {
    const ret = getObject(arg0).navigator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_networkid_new = function(arg0) {
    const ret = NetworkId.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
    const ret = /* @__PURE__ */ new Date();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_018dcc2d6c8c2f6a = function() {
    return handleError(function() {
      const ret = new Headers();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_0b790fd655ff1a97 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new WebSocket(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_23a2665fac83c611 = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = /* @__PURE__ */ __name((arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_199(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      }, "cb0");
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_new_405e22f390576ce2 = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_5e0be73521bc8c17 = function() {
    const ret = /* @__PURE__ */ new Map();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_757fd34d47ff40d2 = function(arg0) {
    const ret = new ArrayBuffer(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_78feb108b6472713 = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b1a33e5095abf678 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Worker(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_e25e5aab09ff45db = function() {
    return handleError(function() {
      const ret = new AbortController();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_f5f8a7325e1cb479 = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithnodejsconfigimpl_b0a2d4e5b0763676 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      const ret = new WebSocket(
        getStringFromWasm0(arg0, arg1),
        takeObject(arg2),
        takeObject(arg3),
        takeObject(arg4),
        takeObject(arg5),
        takeObject(arg6)
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrandinit_06c535e0a867c635 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_newwithstrsequenceandoptions_aaff55b467c81b63 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Blob(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_next_25feadfc0913fea9 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_next_6574e1a8a62d1055 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_nodedescriptor_new = function(arg0) {
    const ret = NodeDescriptor.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_now_807e54c39636c349 = function() {
    const ret = Date.now();
    return ret;
  };
  imports.wbg.__wbg_now_d18023d54d4e5500 = function(arg0) {
    const ret = getObject(arg0).now();
    return ret;
  };
  imports.wbg.__wbg_objectStore_21878d46d25b64b6 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_oldVersion_e8337811e52861c6 = function(arg0) {
    const ret = getObject(arg0).oldVersion;
    return ret;
  };
  imports.wbg.__wbg_on_9ef8de87725b93b5 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).on(
      getStringFromWasm0(arg1, arg2),
      getObject(arg3)
    );
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_once_8901720a31f56808 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).once(
      getStringFromWasm0(arg1, arg2),
      getObject(arg3)
    );
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_openCursor_d8ea5d621ec422f8 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).openCursor(
        getObject(arg1),
        __wbindgen_enum_IdbCursorDirection[arg2]
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_open_e0c0b2993eb596e1 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).open(
        getStringFromWasm0(arg1, arg2),
        arg3 >>> 0
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_pendingtransaction_new = function(arg0) {
    const ret = PendingTransaction.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_postMessage_6edafa8f7b9c2f52 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).postMessage(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_prependListener_dc1e8b094d0f731e = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).prependListener(
      getStringFromWasm0(arg1, arg2),
      getObject(arg3)
    );
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_prependOnceListener_93873dc17dd2fcad = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).prependOnceListener(
      getStringFromWasm0(arg1, arg2),
      getObject(arg3)
    );
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_protocol_faa0494a9b2554cb = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg1).protocol;
      const ptr1 = passStringToWasm0(
        ret,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_publickey_new = function(arg0) {
    const ret = PublicKey.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_push_737cfc8c1432c2c6 = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_put_066faa31a6a88f5b = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_queueMicrotask_97d92b4fcc8a61c5 = function(arg0) {
    queueMicrotask(getObject(arg0));
  };
  imports.wbg.__wbg_queueMicrotask_d3219def82552485 = function(arg0) {
    const ret = getObject(arg0).queueMicrotask;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).randomFillSync(takeObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_readFileSync_42b340d959241f2b = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).readFileSync(
        getStringFromWasm0(arg1, arg2),
        takeObject(arg3)
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readdir_319d9b13a44c9af9 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).readdir(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_readyState_4013cfdf4f22afb0 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return (__wbindgen_enum_IdbRequestReadyState.indexOf(ret) + 1 || 3) - 1;
  };
  imports.wbg.__wbg_readyState_6c28968f3e6c1e47 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return ret;
  };
  imports.wbg.__wbg_removeAttribute_e419cd6726b4c62f = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).removeAttribute(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_removeItem_9d2669ee3bba6f7d = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).removeItem(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_remove_cb9af65ab98197c5 = function() {
    return handleError(function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        const ret = chrome.storage.local.remove(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      } finally {
        wasm.__wbindgen_export_3(deferred0_0, deferred0_1, 1);
      }
    }, arguments);
  };
  imports.wbg.__wbg_renameSync_86e78b84a05e4a0b = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).renameSync(
        getStringFromWasm0(arg1, arg2),
        getStringFromWasm0(arg3, arg4)
      );
    }, arguments);
  };
  imports.wbg.__wbg_requestAnimationFrame_63a812187303a02c = function(arg0) {
    const ret = requestAnimationFrame(takeObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_require_05f2f70e92254dbb = function(arg0, arg1) {
    return void 0;
  };
  imports.wbg.__wbg_require_11fc9008c54f5b90 = function(arg0, arg1) {
    return void 0;
  };
  imports.wbg.__wbg_require_79b1e9274cde3c87 = function() {
    return handleError(function() {
      const ret = module.require;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_resolve_4851785c9c5f573d = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_result_f29afabdf2c05826 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).result;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_rpcclient_new = function(arg0) {
    const ret = RpcClient.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_send_17f8c8c8e084cc5e = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).send(getArrayU8FromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_9a57107cc0d7eafa = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).send(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_send_afb0c27f2d9698e3 = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).send(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setAttribute_2704501201f15687 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setAttribute(
        getStringFromWasm0(arg1, arg2),
        getStringFromWasm0(arg3, arg4)
      );
    }, arguments);
  };
  imports.wbg.__wbg_setInterval_160c4baec24e25f6 = function() {
    return handleError(function(arg0, arg1) {
      const ret = setInterval(getObject(arg0), arg1 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_setItem_212ecc915942ab0a = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setItem(
        getStringFromWasm0(arg1, arg2),
        getStringFromWasm0(arg3, arg4)
      );
    }, arguments);
  };
  imports.wbg.__wbg_setTime_8afa2faa26e7eb59 = function(arg0, arg1) {
    const ret = getObject(arg0).setTime(arg1);
    return ret;
  };
  imports.wbg.__wbg_setTimeout_430dd4984e76f6c3 = function() {
    return handleError(function(arg0, arg1) {
      const ret = setTimeout(getObject(arg0), arg1 >>> 0);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_005c36bbcfafb768 = function() {
    return handleError(function(arg0) {
      const ret = chrome.storage.local.set(takeObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_37837023f3d740e8 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_3f1d0b984ed272ed = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_set_8fc6bf8a5b1071d1 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(
        getObject(arg0),
        getObject(arg1),
        getObject(arg2)
      );
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_setbinaryType_9981a6ba2bd58b94 = function(arg0, arg1) {
    getObject(arg0).binaryType = __wbindgen_enum_BinaryType[arg1];
  };
  imports.wbg.__wbg_setbody_5923b78a95eedf29 = function(arg0, arg1) {
    getObject(arg0).body = getObject(arg1);
  };
  imports.wbg.__wbg_setcredentials_c3a22f1cd105a2c6 = function(arg0, arg1) {
    getObject(arg0).credentials = __wbindgen_enum_RequestCredentials[arg1];
  };
  imports.wbg.__wbg_setheaders_834c0bdb6a8949ad = function(arg0, arg1) {
    getObject(arg0).headers = getObject(arg1);
  };
  imports.wbg.__wbg_setinnerHTML_31bde41f835786f7 = function(arg0, arg1, arg2) {
    getObject(arg0).innerHTML = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setmethod_3c5280fe5d890842 = function(arg0, arg1, arg2) {
    getObject(arg0).method = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setmode_5dc300b865044b65 = function(arg0, arg1) {
    getObject(arg0).mode = __wbindgen_enum_RequestMode[arg1];
  };
  imports.wbg.__wbg_setonabort_3bf4db6614fa98e9 = function(arg0, arg1) {
    getObject(arg0).onabort = getObject(arg1);
  };
  imports.wbg.__wbg_setonblocked_aebf64bd39f1eca8 = function(arg0, arg1) {
    getObject(arg0).onblocked = getObject(arg1);
  };
  imports.wbg.__wbg_setonclose_b15bdabd419b6357 = function(arg0, arg1) {
    getObject(arg0).onclose = getObject(arg1);
  };
  imports.wbg.__wbg_setoncomplete_4d19df0dadb7c4d4 = function(arg0, arg1) {
    getObject(arg0).oncomplete = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_b0d9d723b8fddbbb = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_d7e3056cc6e56085 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_e2c5c0fa6fbf6d99 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbg_setonmessage_007594843a0b97e8 = function(arg0, arg1) {
    getObject(arg0).onmessage = getObject(arg1);
  };
  imports.wbg.__wbg_setonmessage_5a885b16bdc6dca6 = function(arg0, arg1) {
    getObject(arg0).onmessage = getObject(arg1);
  };
  imports.wbg.__wbg_setonopen_c42cfdbb28b087c4 = function(arg0, arg1) {
    getObject(arg0).onopen = getObject(arg1);
  };
  imports.wbg.__wbg_setonsuccess_afa464ee777a396d = function(arg0, arg1) {
    getObject(arg0).onsuccess = getObject(arg1);
  };
  imports.wbg.__wbg_setonupgradeneeded_fcf7ce4f2eb0cb5f = function(arg0, arg1) {
    getObject(arg0).onupgradeneeded = getObject(arg1);
  };
  imports.wbg.__wbg_setonversionchange_6ee07fa49ee1e3a5 = function(arg0, arg1) {
    getObject(arg0).onversionchange = getObject(arg1);
  };
  imports.wbg.__wbg_setsignal_75b21ef3a81de905 = function(arg0, arg1) {
    getObject(arg0).signal = getObject(arg1);
  };
  imports.wbg.__wbg_settype_39ed370d3edd403c = function(arg0, arg1, arg2) {
    getObject(arg0).type = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setunique_dd24c422aa05df89 = function(arg0, arg1) {
    getObject(arg0).unique = arg1 !== 0;
  };
  imports.wbg.__wbg_signal_aaf9ad74119f20a4 = function(arg0) {
    const ret = getObject(arg0).signal;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_c99a96ed42647c4c = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_statSync_9a429acc496bafda = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).statSync(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
    const ret = typeof global === "undefined" ? null : global;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
    const ret = typeof globalThis === "undefined" ? null : globalThis;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
    const ret = typeof self === "undefined" ? null : self;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
    const ret = typeof window === "undefined" ? null : window;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_status_f6360336ca686bf0 = function(arg0) {
    const ret = getObject(arg0).status;
    return ret;
  };
  imports.wbg.__wbg_stringify_f7ed6987935b4a24 = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_target_0a62d9d79a2a1ede = function(arg0) {
    const ret = getObject(arg0).target;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_text_7805bea50de2af49 = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).text();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_then_44b73946d2fb3e7d = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_48b406749878a531 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_toString_2f76f493957b63da = function(arg0, arg1, arg2) {
    const ret = getObject(arg1).toString(arg2);
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_toString_b5d4438bc26b267c = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).toString(arg1);
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_babc423936946a37 = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).transaction(
        getStringFromWasm0(arg1, arg2),
        __wbindgen_enum_IdbTransactionMode[arg3]
      );
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_transaction_new = function(arg0) {
    const ret = Transaction.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactioninput_new = function(arg0) {
    const ret = TransactionInput.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactionoutput_new = function(arg0) {
    const ret = TransactionOutput.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_transactionrecordnotification_new = function(arg0) {
    const ret = TransactionRecordNotification.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_unlinkSync_656392e8d747415f = function() {
    return handleError(function(arg0, arg1, arg2) {
      getObject(arg0).unlinkSync(getStringFromWasm0(arg1, arg2));
    }, arguments);
  };
  imports.wbg.__wbg_update_acd72607f506872a = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).update(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_url_ae10c34ca209681d = function(arg0, arg1) {
    const ret = getObject(arg1).url;
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbg_userAgent_12e9d8e62297563f = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg1).userAgent;
      const ptr1 = passStringToWasm0(
        ret,
        wasm.__wbindgen_export_1,
        wasm.__wbindgen_export_2
      );
      const len1 = WASM_VECTOR_LEN;
      getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
      getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    }, arguments);
  };
  imports.wbg.__wbg_utxoentryreference_new = function(arg0) {
    const ret = UtxoEntryReference.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_value_68c4e9a54bb7fd5e = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_value_cd1ffa7b1ab794f1 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_walletdescriptor_new = function(arg0) {
    const ret = WalletDescriptor.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_warn_28319e260c89a4f8 = function(arg0, arg1) {
    console.warn(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbg_writeFileSync_6325b339950ab342 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).writeFileSync(
        getStringFromWasm0(arg1, arg2),
        takeObject(arg3),
        takeObject(arg4)
      );
    }, arguments);
  };
  imports.wbg.__wbindgen_array_new = function() {
    const ret = [];
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_array_push = function(arg0, arg1) {
    getObject(arg0).push(takeObject(arg1));
  };
  imports.wbg.__wbindgen_as_number = function(arg0) {
    const ret = +getObject(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getDataViewMemory0().setBigInt64(
      arg0 + 8 * 1,
      isLikeNone(ret) ? BigInt(0) : ret,
      true
    );
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbindgen_closure_wrapper16385 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6406, __wbg_adapter_78);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17150 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_81);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17152 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_84);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17154 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6436, __wbg_adapter_87);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17515 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6560, __wbg_adapter_90);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper17516 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 6560, __wbg_adapter_90);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper4216 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 1320, __wbg_adapter_75);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper826 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 182, __wbg_adapter_66);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper947 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 237, __wbg_adapter_69);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper949 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 237, __wbg_adapter_72);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    const len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject(arg0) in getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_is_array = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_is_falsy = function(arg0) {
    const ret = !getObject(arg0);
    return ret;
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_lt = function(arg0, arg1) {
    const ret = getObject(arg0) < getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_neg = function(arg0) {
    const ret = -getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getDataViewMemory0().setFloat64(
      arg0 + 8 * 1,
      isLikeNone(ret) ? 0 : ret,
      true
    );
    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(
      ret,
      wasm.__wbindgen_export_1,
      wasm.__wbindgen_export_2
    );
    var len1 = WASM_VECTOR_LEN;
    getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
    getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_try_into_number = function(arg0) {
    let result;
    try {
      result = +getObject(arg0);
    } catch (e) {
      result = e;
    }
    const ret = result;
    return addHeapObject(ret);
  };
  return imports;
}
__name(__wbg_get_imports, "__wbg_get_imports");
function __wbg_init_memory(imports, memory) {
}
__name(__wbg_init_memory, "__wbg_init_memory");
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedDataViewMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  return wasm;
}
__name(__wbg_finalize_init, "__wbg_finalize_init");
async function __wbg_init(module_or_path) {
  if (wasm !== void 0) return wasm;
  if (typeof module_or_path !== "undefined") {
    if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
      ({ module_or_path } = module_or_path);
    } else {
      console.warn(
        "using deprecated parameters for the initialization function; pass a single object instead"
      );
    }
  }
  if (typeof module_or_path === "undefined") {
    module_or_path = new URL("kaspa_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
    module_or_path = fetch(module_or_path);
  }
  __wbg_init_memory(imports);
  const { instance, module: module2 } = await __wbg_load(await module_or_path, imports);
  return __wbg_finalize_init(instance, module2);
}
__name(__wbg_init, "__wbg_init");
var kaspa_default = __wbg_init;

// kktp/core/logger.js
var _enabled = true;
var _modules = {};
var LogModule = Object.freeze({
  core: Object.freeze({
    root: "core",
    eventEmitter: "core.eventEmitter"
  }),
  transport: Object.freeze({
    root: "transport",
    heartbeat: "transport.heartbeat",
    kaspaClient: "transport.kaspaClient",
    rpcRunner: "transport.rpcRunner",
    transportFacade: "transport.transportFacade",
    txBuilder: "transport.txBuilder",
    utxoManager: "transport.utxoManager",
    utxoOperations: "transport.utxoOperations"
  }),
  intelligence: Object.freeze({
    root: "intelligence",
    dagWalk: "intelligence.dagWalk",
    indexer: "intelligence.indexer",
    intelligenceFacade: "intelligence.intelligenceFacade",
    scanner: "intelligence.scanner"
  }),
  identity: Object.freeze({
    root: "identity",
    identityFacade: "identity.identityFacade",
    storage: "identity.storage",
    walletService: "identity.walletService"
  }),
  crypto: Object.freeze({
    root: "crypto",
    cryptoFacade: "crypto.cryptoFacade",
    dhEncryption: "crypto.dhEncryption",
    encryption: "crypto.encryption"
  }),
  vrf: Object.freeze({
    root: "vrf",
    vrfFacade: "vrf.vrfFacade",
    core: Object.freeze({
      root: "vrf.core",
      config: "vrf.core.config",
      constants: "vrf.core.constants",
      crypto: "vrf.core.crypto",
      errors: "vrf.core.errors",
      extractor: "vrf.core.extractor",
      folding: "vrf.core.folding",
      logger: "vrf.core.logger",
      nist: "vrf.core.nist",
      nistVerifier: "vrf.core.nistVerifier",
      fetcher: Object.freeze({
        root: "vrf.core.fetcher",
        bitcoin: "vrf.core.fetcher.bitcoin",
        cache: "vrf.core.fetcher.cache",
        index: "vrf.core.fetcher.index",
        kaspa: "vrf.core.fetcher.kaspa",
        qrngFetcher: "vrf.core.fetcher.qrngFetcher",
        qrng: "vrf.core.fetcher.qrng",
        utilities: "vrf.core.fetcher.utilities"
      }),
      logs: Object.freeze({
        root: "vrf.core.logs",
        logger: "vrf.core.logs.logger"
      }),
      models: Object.freeze({
        root: "vrf.core.models",
        block: "vrf.core.models.block",
        vrfProof: "vrf.core.models.vrfProof"
      }),
      tests: Object.freeze({
        root: "vrf.core.tests",
        basic: "vrf.core.tests.basic",
        binaryMatrixRank: "vrf.core.tests.binaryMatrixRank",
        gamma: "vrf.core.tests.gamma",
        linearComplexity: "vrf.core.tests.linearComplexity",
        maurerUniversal: "vrf.core.tests.maurerUniversal",
        randomExcursions: "vrf.core.tests.randomExcursions",
        spectralDft: "vrf.core.tests.spectralDft",
        templateMatching: "vrf.core.tests.templateMatching",
        utilities: "vrf.core.tests.utilities"
      }),
      unitTests: Object.freeze({
        root: "vrf.core.unitTests",
        bitcoinUnitTest: "vrf.core.unitTests.bitcoinUnitTest",
        cachePersistUnitTest: "vrf.core.unitTests.cachePersistUnitTest",
        foldingUnitTest: "vrf.core.unitTests.foldingUnitTest",
        kaspaUnitTest: "vrf.core.unitTests.kaspaUnitTest",
        qrngUnitTest: "vrf.core.unitTests.qrngUnitTest",
        testDashboard: "vrf.core.unitTests.testDashboard",
        vrfTests: "vrf.core.unitTests.vrfTests"
      })
    })
  }),
  kktp: Object.freeze({
    root: "kktp",
    kkGameEngine: "kktp.kkGameEngine",
    kaspaPortal: "kktp.kaspaPortal"
  }),
  protocol: Object.freeze({
    root: "protocol",
    sessions: Object.freeze({
      root: "protocol.sessions",
      sessionFacade: "protocol.sessions.sessionFacade",
      sessionVault: "protocol.sessions.sessionVault",
      keyDeriver: "protocol.sessions.keyDeriver"
    })
  }),
  lobby: Object.freeze({
    root: "lobby",
    lobbyManager: "lobby.lobbyManager",
    lobbyMessageHandler: "lobby.lobbyMessageHandler",
    index: "lobby.index",
    lobbyCodec: "lobby.lobbyCodec",
    lobbyFacade: "lobby.lobbyFacade",
    lobbySchemas: "lobby.lobbySchemas",
    parts: Object.freeze({
      root: "lobby.parts",
      index: "lobby.parts.index",
      lobbyContext: "lobby.parts.lobbyContext",
      lobbyDiscovery: "lobby.parts.lobbyDiscovery",
      lobbyDmBuffer: "lobby.parts.lobbyDmBuffer",
      lobbyJoins: "lobby.parts.lobbyJoins",
      lobbyKeys: "lobby.parts.lobbyKeys",
      lobbyMessaging: "lobby.parts.lobbyMessaging",
      lobbyPersistence: "lobby.parts.lobbyPersistence",
      lobbyRoster: "lobby.parts.lobbyRoster",
      lobbyRouting: "lobby.parts.lobbyRouting",
      lobbySessionEnd: "lobby.parts.lobbySessionEnd",
      lobbySubscriptions: "lobby.parts.lobbySubscriptions",
      lobbyUtils: "lobby.parts.lobbyUtils",
      lobbyUtxo: "lobby.parts.lobbyUtxo"
    })
  }),
  anchor: Object.freeze({
    root: "anchor",
    anchorFinal: "anchor.anchorFinal",
    anchorGenesis: "anchor.anchorGenesis",
    anchorHeartbeat: "anchor.anchorHeartbeat",
    auditTrail: "anchor.auditTrail",
    binaryPacking: "anchor.binaryPacking",
    hashing: "anchor.hashing",
    kaspaAnchorFacade: "anchor.kaspaAnchorFacade",
    moveProcessor: "anchor.moveProcessor",
    stateSerializer: "anchor.stateSerializer",
    utxoManager: "anchor.utxoManager",
    utxoPool: "anchor.utxoPool",
    vrfOperations: "anchor.vrfOperations"
  })
});
var Logger = {
  setEnabled: /* @__PURE__ */ __name((val) => {
    _enabled = !!val;
  }, "setEnabled"),
  resetModules: /* @__PURE__ */ __name(() => {
    for (const key of Object.keys(_modules)) {
      delete _modules[key];
    }
  }, "resetModules"),
  setModuleEnabled: /* @__PURE__ */ __name((name, enabled) => {
    _modules[name] = !!enabled;
  }, "setModuleEnabled"),
  isModuleEnabled: /* @__PURE__ */ __name((name) => {
    if (!name) return _enabled;
    if (name in _modules) return _modules[name];
    const parts = String(name).split(".");
    while (parts.length > 1) {
      parts.pop();
      const parent = parts.join(".");
      if (parent in _modules) return _modules[parent];
    }
    return _enabled;
  }, "isModuleEnabled"),
  enableModule: /* @__PURE__ */ __name((name) => {
    Logger.setModuleEnabled(name, true);
  }, "enableModule"),
  disableModule: /* @__PURE__ */ __name((name) => {
    Logger.setModuleEnabled(name, false);
  }, "disableModule"),
  enableTransportLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.transport.root), "enableTransportLogs"),
  disableTransportLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.transport.root), "disableTransportLogs"),
  enableIntelligenceLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.intelligence.root), "enableIntelligenceLogs"),
  disableIntelligenceLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.intelligence.root), "disableIntelligenceLogs"),
  enableIdentityLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.identity.root), "enableIdentityLogs"),
  disableIdentityLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.identity.root), "disableIdentityLogs"),
  enableCryptoLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.crypto.root), "enableCryptoLogs"),
  disableCryptoLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.crypto.root), "disableCryptoLogs"),
  enableVrfLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.vrf.root), "enableVrfLogs"),
  disableVrfLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.vrf.root), "disableVrfLogs"),
  enableKktpLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.kktp.root), "enableKktpLogs"),
  disableKktpLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.kktp.root), "disableKktpLogs"),
  enableLobbyLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.lobby.root), "enableLobbyLogs"),
  disableLobbyLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.lobby.root), "disableLobbyLogs"),
  enableAnchorLogs: /* @__PURE__ */ __name(() => Logger.enableModule(LogModule.anchor.root), "enableAnchorLogs"),
  disableAnchorLogs: /* @__PURE__ */ __name(() => Logger.disableModule(LogModule.anchor.root), "disableAnchorLogs"),
  create: /* @__PURE__ */ __name((name = "KKTP") => {
    const prefix = /* @__PURE__ */ __name((level) => `[${level}] ${name}:`, "prefix");
    return {
      log: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.log(prefix("LOG"), ...args);
      }, "log"),
      debug: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.debug(prefix("DEBUG"), ...args);
      }, "debug"),
      info: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.info(prefix("INFO"), ...args);
      }, "info"),
      warn: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.warn(prefix("WARN"), ...args);
      }, "warn"),
      error: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.error(prefix("ERROR"), ...args);
      }, "error"),
      trace: /* @__PURE__ */ __name((...args) => {
        if (Logger.isModuleEnabled(name)) console.trace(prefix("TRACE"), ...args);
      }, "trace")
    };
  }, "create")
};

// kktp/engine/kaspa/transport/kaspa_client.js
var log = Logger.create(LogModule.transport.kaspaClient);
var client = null;
var currentRpcUrl = null;
var currentNetworkId = null;
async function connect({
  rpcUrl,
  networkId = "testnet-10",
  onDisconnect
} = {}) {
  if (client) {
    try {
      await client.disconnect();
      client.free();
      client = null;
    } catch (e) {
      log.warn("Cleanup error:", e);
    }
    client = null;
  }
  currentRpcUrl = rpcUrl;
  currentNetworkId = networkId;
  const options = {
    networkId,
    resolver: rpcUrl ? void 0 : new Resolver(),
    url: rpcUrl || void 0
  };
  client = new RpcClient(options);
  const connectOptions = {
    blockAsyncConnect: true,
    // block until actually connected
    strategy: ConnectStrategy.Retry,
    // try nodes, don't persist-loop forever
    retryInterval: 1e3,
    timeoutDuration: 5e3
    // give up after 5s
  };
  try {
    await client.connect(connectOptions);
  } catch (err) {
    log.warn("Connect error (blockAsync):", err);
  }
  if (!client.isConnected) {
    const pollEnd = Date.now() + 5e3;
    while (!client.isConnected && Date.now() < pollEnd) {
      await new Promise((r2) => setTimeout(r2, 200));
    }
  }
  if (!client.isConnected) {
    log.error("Could not connect to any Kaspa node within timeout");
    try {
      await client.disconnect();
    } catch (_) {
    }
    try {
      client.free();
    } catch (_) {
    }
    client = null;
    throw new Error("Kaspa node connection timeout");
  }
  if (client && typeof client.on === "function") {
    client.on("disconnect", async () => {
      log.warn("Disconnected from Kaspa node");
      if (typeof onDisconnect === "function") {
        await onDisconnect();
      }
    });
  }
  if (rpcUrl) {
    log.log(
      `Connected to Kaspa node at ${rpcUrl} on network ${currentNetworkId}`
    );
  } else {
    log.log(
      `Connected to public Kaspa node via resolver on network ${currentNetworkId}`
    );
  }
  return client;
}
__name(connect, "connect");

// kktp/engine/kaspa/utilities/utilities.js
import * as secp from "https://esm.sh/@noble/secp256k1";
var MAX_PAYLOAD_BYTES = 32 * 1024;
function validateAddress(address) {
  if (address == null || address === "") {
    throw new Error("Invalid address: " + address);
  }
  if (typeof address === "string") {
    try {
      address = new Address(address);
      return address;
    } catch (err) {
      throw new Error("Invalid address format: " + address);
    }
  }
  return address;
}
__name(validateAddress, "validateAddress");
function validatePayload(payload) {
  if (typeof payload !== "string") return false;
  if (payload.length > MAX_PAYLOAD_BYTES * 2) return false;
  return true;
}
__name(validatePayload, "validatePayload");
function payloadToHex(payload) {
  if (!payload) return void 0;
  let str = String(payload).trim();
  if (str.startsWith("0x")) str = str.slice(2);
  if (/^[0-9a-fA-F]*$/.test(str) && str.length % 2 === 0)
    return str.toLowerCase();
  return stringToHex(str).toLowerCase();
}
__name(payloadToHex, "payloadToHex");
function stringToHex(str) {
  return Array.from(new TextEncoder().encode(str)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(stringToHex, "stringToHex");
function hexToString(hex2) {
  if (hex2.startsWith("0x")) hex2 = hex2.slice(2);
  const bytes = new Uint8Array(
    hex2.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
  );
  return new TextDecoder().decode(bytes);
}
__name(hexToString, "hexToString");
function bytesToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(bytesToHex, "bytesToHex");
function hexToBytes2(hex2) {
  if (hex2.startsWith("0x")) hex2 = hex2.slice(2);
  if (hex2.length !== 64 && hex2.length !== 66) {
    throw new Error(
      "Key must be 32 bytes (64 hex chars) or compressed secp256k1 public key (66 hex chars)"
    );
  }
  const arr = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < arr.length; i++) {
    arr[i] = parseInt(hex2.substr(i * 2, 2), 16);
  }
  return arr;
}
__name(hexToBytes2, "hexToBytes");
function hexToUtf8(hex2) {
  if (typeof hex2 !== "string" || hex2.length === 0) return "";
  if (hex2.length % 2 !== 0) throw new Error("Invalid hex string length");
  const bytes = new Uint8Array(hex2.length / 2);
  for (let i = 0; i < hex2.length; i += 2) {
    bytes[i / 2] = parseInt(hex2.substring(i, i + 2), 16);
  }
  return new TextDecoder().decode(bytes);
}
__name(hexToUtf8, "hexToUtf8");
function dehydrateTx({ tx, block, decodedPayload }) {
  if (!tx) {
    return null;
  }
  const txData = {
    txid: tx.verboseData.transactionId,
    timestamp: tx.verboseData.blockTime,
    payload: tx.payload
  };
  if (decodedPayload) {
    txData.decodedPayload = decodedPayload;
  }
  if (block) {
    txData.blockHash = block.header.hash;
    txData.blueScore = block.header.blueScore;
    txData.blockDaaScore = block.header.daaScore;
  }
  return txData;
}
__name(dehydrateTx, "dehydrateTx");
function dehydrateBlock(block) {
  if (!block) return null;
  const h = block.header || block;
  const result = {
    hash: (h.hash || "").toString(),
    timestamp: Number(h.timestamp || 0),
    blueScore: Number(h.blueScore || 0),
    daaScore: Number(h.daaScore || 0),
    parents: [],
    txCount: Number(
      block.txCount ?? h.transactionCount ?? (block.transactions?.length || 0)
    ),
    isChainBlock: !!(block.isChainBlock || block.verboseData?.isChainBlock)
  };
  return result;
}
__name(dehydrateBlock, "dehydrateBlock");
function getPublicKeyBytes(prvKeyHex) {
  const prvKeyBytes = hexToBytes2(prvKeyHex);
  const pubKeyBytes = secp.getPublicKey(prvKeyBytes, true);
  return pubKeyBytes;
}
__name(getPublicKeyBytes, "getPublicKeyBytes");
function getPublicKeyHex(prvKeyHex) {
  const pubKeyBytes = getPublicKeyBytes(prvKeyHex);
  return bytesToHex(pubKeyBytes);
}
__name(getPublicKeyHex, "getPublicKeyHex");
async function deriveChildKeyPair({
  xprvHex,
  network = "testnet-10",
  accountIndex = 0n,
  branch = 0,
  index = 0
}) {
  const masterXPrv = XPrv.fromXPrv(xprvHex);
  const p = masterXPrv.deriveChild(44, true);
  const c = p.deriveChild(111111, true);
  const a = c.deriveChild(Number(accountIndex), true);
  const b = a.deriveChild(branch, false);
  const leaf = b.deriveChild(index, false);
  const privKey = leaf.toPrivateKey();
  const pubKey = privKey.toPublicKey();
  const networkType = network.includes("mainnet") ? NetworkType.Mainnet : NetworkType.Testnet;
  const address = privKey.toAddress(networkType).toString();
  const result = {
    privateKey: privKey.toString(),
    publicKey: pubKey.toString(),
    address
  };
  [masterXPrv, p, c, a, b, leaf].forEach((obj) => obj.free());
  return result;
}
__name(deriveChildKeyPair, "deriveChildKeyPair");
async function signMessageWithPrivateKeyHex(privateKeyHex, message) {
  const signature = await signMessage({ privateKey: privateKeyHex, message });
  return signature;
}
__name(signMessageWithPrivateKeyHex, "signMessageWithPrivateKeyHex");
async function verifyMessageWithPublicKeyHex(publicKeyHex, message, signatureHex) {
  const isValid = await verifyMessage({
    publicKey: publicKeyHex,
    message,
    signature: signatureHex
  });
  return isValid;
}
__name(verifyMessageWithPublicKeyHex, "verifyMessageWithPublicKeyHex");

// kktp/engine/kaspa/transport/utxo_manager.js
var SOMPI_PER_KAS = 100000000n;
var DUST_THRESHOLD = 100000n;
var SMALL_THRESHOLD = 100000000n;
var MEDIUM_THRESHOLD = 10000000000n;
function normalizeUtxoEntries(utxoResult) {
  if (Array.isArray(utxoResult)) return utxoResult;
  if (Array.isArray(utxoResult?.entries)) return utxoResult.entries;
  if (Array.isArray(utxoResult?.utxoEntries)) return utxoResult.utxoEntries;
  return [];
}
__name(normalizeUtxoEntries, "normalizeUtxoEntries");
function entryAmountSompi(entry) {
  if (!entry) return 0n;
  const tryGetAmount = /* @__PURE__ */ __name((obj) => {
    if (!obj) return null;
    try {
      if (typeof obj.amount === "bigint") return obj.amount;
      if (typeof obj.amount === "number") return BigInt(Math.trunc(obj.amount));
      if (typeof obj.amount === "string" && obj.amount.trim() !== "") return BigInt(obj.amount);
    } catch {
    }
    return null;
  }, "tryGetAmount");
  let result = tryGetAmount(entry);
  if (result !== null) return result;
  try {
    if (entry.entry) {
      result = tryGetAmount(entry.entry);
      if (result !== null) return result;
    }
  } catch {
  }
  try {
    if (entry.utxoEntry) {
      result = tryGetAmount(entry.utxoEntry);
      if (result !== null) return result;
    }
  } catch {
  }
  try {
    if (entry.entry?.utxoEntry) {
      result = tryGetAmount(entry.entry.utxoEntry);
      if (result !== null) return result;
    }
  } catch {
  }
  try {
    if (entry.utxo) {
      result = tryGetAmount(entry.utxo);
      if (result !== null) return result;
    }
  } catch {
  }
  try {
    if (entry.output) {
      result = tryGetAmount(entry.output);
      if (result !== null) return result;
    }
  } catch {
  }
  return 0n;
}
__name(entryAmountSompi, "entryAmountSompi");
function getEntryOutpoint(entry) {
  const inner = entry?.entry ?? entry;
  const outpoint = inner?.outpoint || inner?.utxoEntry?.outpoint || inner?.utxo?.outpoint || null;
  if (outpoint) {
    return {
      transactionId: outpoint.transactionId || outpoint.txid || outpoint.txId,
      index: outpoint.index ?? outpoint.outputIndex ?? 0
    };
  }
  if (inner?.transactionId || inner?.txid) {
    return {
      transactionId: inner.transactionId || inner.txid || inner.txId,
      index: inner.index ?? inner.outputIndex ?? 0
    };
  }
  return null;
}
__name(getEntryOutpoint, "getEntryOutpoint");
function getEntryKey(entry) {
  const outpoint = getEntryOutpoint(entry);
  if (!outpoint) return `unknown_${Math.random().toString(36).slice(2)}`;
  return `${outpoint.transactionId}:${outpoint.index}`;
}
__name(getEntryKey, "getEntryKey");
async function getAccountUtxos({
  wallet: wallet2,
  accountDescriptor,
  logger
} = {}) {
  if (!wallet2) throw new Error("getAccountUtxos: wallet is required.");
  if (!accountDescriptor)
    throw new Error("getAccountUtxos: accountDescriptor is required.");
  if (!wallet2.rpc?.getUtxosByAddresses)
    throw new Error(
      "getAccountUtxos: wallet.rpc.getUtxosByAddresses not available."
    );
  const log14 = typeof logger === "function" ? logger : () => {
  };
  const receiveAddress = String(accountDescriptor.receiveAddress || "");
  const changeAddress = String(accountDescriptor.changeAddress || "");
  const addresses = [receiveAddress, changeAddress].filter(Boolean);
  if (addresses.length === 0)
    throw new Error("No receive/change address available for this account.");
  log14(`Fetching UTXOs for: ${addresses.join(", ")}`);
  const utxoResult = await wallet2.rpc.getUtxosByAddresses(addresses);
  const entries = normalizeUtxoEntries(utxoResult);
  return { receiveAddress, changeAddress, entries };
}
__name(getAccountUtxos, "getAccountUtxos");
async function getUtxosByAddress(client2, address) {
  if (!client2?.getUtxosByAddresses) {
    throw new Error("getUtxosByAddress: client.getUtxosByAddresses not available.");
  }
  if (!address) {
    throw new Error("getUtxosByAddress: address is required.");
  }
  const result = await client2.getUtxosByAddresses([address]);
  return normalizeUtxoEntries(result);
}
__name(getUtxosByAddress, "getUtxosByAddress");
async function getUtxosByAddresses(client2, addresses) {
  if (!client2?.getUtxosByAddresses) {
    throw new Error("getUtxosByAddresses: client.getUtxosByAddresses not available.");
  }
  if (!Array.isArray(addresses) || addresses.length === 0) {
    throw new Error("getUtxosByAddresses: addresses array is required.");
  }
  const validAddresses = addresses.filter((a) => a != null && a !== "").map((a) => String(a));
  if (validAddresses.length === 0) {
    return [];
  }
  const result = await client2.getUtxosByAddresses(validAddresses);
  const entries = normalizeUtxoEntries(result);
  const seen = /* @__PURE__ */ new Set();
  const deduplicated = [];
  for (const entry of entries) {
    const key = getEntryKey(entry);
    if (!seen.has(key)) {
      seen.add(key);
      deduplicated.push(entry);
    }
  }
  return deduplicated;
}
__name(getUtxosByAddresses, "getUtxosByAddresses");
function selectUtxosLargestFirst(entries, { targetSompi = 0n, maxInputs = 50 } = {}) {
  const sorted = [...entries || []].sort((a, b) => {
    const aa = entryAmountSompi(a);
    const bb = entryAmountSompi(b);
    return aa === bb ? 0 : aa > bb ? -1 : 1;
  });
  const selected = [];
  let total = 0n;
  for (const e of sorted) {
    if (selected.length >= maxInputs) break;
    const amt = entryAmountSompi(e);
    if (amt <= 0n) continue;
    selected.push(e);
    total += amt;
    if (total >= targetSompi) break;
  }
  return { selected, total };
}
__name(selectUtxosLargestFirst, "selectUtxosLargestFirst");
function selectUtxoForEngine(entries, engineIndex, totalEngines, minAmount = 0n) {
  const usable = (entries || []).map((e, idx) => ({ entry: e, amount: entryAmountSompi(e), originalIndex: idx })).filter((x) => x.amount >= minAmount).sort((a, b) => a.amount > b.amount ? -1 : a.amount < b.amount ? 1 : 0);
  if (usable.length === 0) {
    return { entry: null, amount: 0n };
  }
  const myUtxos = usable.filter((_, idx) => idx % totalEngines === engineIndex);
  if (myUtxos.length === 0) {
    return { entry: null, amount: 0n };
  }
  return { entry: myUtxos[0].entry, amount: myUtxos[0].amount };
}
__name(selectUtxoForEngine, "selectUtxoForEngine");
function calculateTotalBalance(entries) {
  let total = 0n;
  for (const e of entries || []) {
    total += entryAmountSompi(e);
  }
  return total;
}
__name(calculateTotalBalance, "calculateTotalBalance");
function categorizeUtxos(entries) {
  const dust = [];
  const small = [];
  const medium = [];
  const large = [];
  for (const e of entries || []) {
    const amt = entryAmountSompi(e);
    if (amt < DUST_THRESHOLD) {
      dust.push(e);
    } else if (amt < SMALL_THRESHOLD) {
      small.push(e);
    } else if (amt < MEDIUM_THRESHOLD) {
      medium.push(e);
    } else {
      large.push(e);
    }
  }
  return { dust, small, medium, large };
}
__name(categorizeUtxos, "categorizeUtxos");
function kasToSompi(amountKas) {
  return kaspaToSompi(String(amountKas));
}
__name(kasToSompi, "kasToSompi");
function sompiToKas(sompi, decimals = 8) {
  if (typeof sompi !== "bigint") {
    sompi = BigInt(sompi || 0);
  }
  const whole = sompi / SOMPI_PER_KAS;
  const frac = sompi % SOMPI_PER_KAS;
  if (frac === 0n) {
    return whole.toString();
  }
  const fracStr = frac.toString().padStart(8, "0").slice(0, decimals);
  return `${whole}.${fracStr}`.replace(/\.?0+$/, "");
}
__name(sompiToKas, "sompiToKas");

// kktp/engine/kaspa/transport/tx_builder.js
var log2 = Logger.create(LogModule.transport.txBuilder);
var MIN_OUTPUT_SOMPI = 10000n;
var ESTIMATED_FEE_PER_INPUT = 3000n;
var ESTIMATED_FEE_PER_OUTPUT = 3000n;
var ESTIMATED_BASE_FEE = 5000n;
function estimateFee(inputCount, outputCount, payloadBytes = 0) {
  const inputFee = BigInt(inputCount) * ESTIMATED_FEE_PER_INPUT;
  const outputFee = BigInt(outputCount) * ESTIMATED_FEE_PER_OUTPUT;
  const payloadFee = BigInt(payloadBytes) * 10n;
  return ESTIMATED_BASE_FEE + inputFee + outputFee + payloadFee;
}
__name(estimateFee, "estimateFee");
async function estimateTransaction({
  entries,
  outputs,
  priorityFee = 0n,
  changeAddress,
  networkId,
  payload
  // string (utf8 or hex)
} = {}) {
  if (!Array.isArray(entries) || entries.length === 0)
    throw new Error("estimateTransaction: entries required.");
  if (!Array.isArray(outputs) || outputs.length === 0)
    throw new Error("estimateTransaction: outputs required.");
  if (!changeAddress)
    throw new Error("estimateTransaction: changeAddress required.");
  if (!networkId) throw new Error("estimateTransaction: networkId required.");
  const payloadHex = payloadToHex(payload);
  let wasmEntries = entries;
  if (entries.length > 0) {
    const e = entries[0];
    const isWasmObject = e.__wbg_ptr !== void 0;
    if (!isWasmObject) {
      const utxoEntriesWrapper = new UtxoEntries(entries);
      wasmEntries = utxoEntriesWrapper.items;
    }
  }
  const settings = {
    // SDK examples commonly use utxoEntries; some wrappers also pass entries.
    utxoEntries: wasmEntries,
    entries: wasmEntries,
    outputs,
    changeAddress: String(changeAddress),
    priorityFee,
    payload: payloadHex,
    networkId
  };
  let generator;
  try {
    generator = new Generator(settings);
    const summary = await generator.estimate();
    const fees = summary?.fees ?? 0n;
    const mass = summary?.mass ?? 0n;
    const finalAmount = summary?.finalAmount;
    const txCount = summary?.transactions ?? 0;
    const utxoCount = summary?.utxos ?? 0;
    const finalTransactionId = summary?.finalTransactionId;
    try {
      summary?.free?.();
    } catch {
    }
    const baseFee = fees - (priorityFee ?? 0n);
    return {
      mass,
      fees,
      feesKas: sompiToKaspaString(fees),
      priorityFee,
      baseFee,
      baseFeeKas: sompiToKaspaString(baseFee),
      finalAmount,
      finalAmountKas: finalAmount != null ? sompiToKaspaString(finalAmount) : null,
      transactions: txCount,
      utxos: utxoCount,
      finalTransactionId: finalTransactionId ?? null,
      payloadBytes: payloadHex ? Math.floor(payloadHex.length / 2) : 0
    };
  } finally {
    try {
      generator?.free?.();
    } catch {
    }
  }
}
__name(estimateTransaction, "estimateTransaction");
async function signPendingTransaction(pendingTx, privateKeys) {
  if (!pendingTx?.sign)
    throw new Error("PendingTransaction.sign is not available.");
  const keys = Array.isArray(privateKeys) ? privateKeys : [];
  if (keys.length === 0)
    throw new Error("No private keys provided for signing.");
  try {
    const wasmKeys = keys.map(
      (k) => k instanceof PrivateKey ? k : new PrivateKey(String(k))
    );
    await pendingTx.sign(wasmKeys);
    return;
  } catch {
    await pendingTx.sign(keys.map((k) => String(k)));
  }
}
__name(signPendingTransaction, "signPendingTransaction");
async function buildPendingTransaction({
  entries,
  outputs,
  priorityFee = 0n,
  changeAddress,
  networkId,
  payload
  // string (utf8 or hex)
} = {}) {
  if (!Array.isArray(entries) || entries.length === 0)
    throw new Error("buildPendingTransaction: entries required.");
  if (!Array.isArray(outputs) || outputs.length === 0)
    throw new Error("buildPendingTransaction: outputs required.");
  if (!changeAddress)
    throw new Error("buildPendingTransaction: changeAddress required.");
  if (!networkId)
    throw new Error("buildPendingTransaction: networkId required.");
  const payloadHex = payloadToHex(payload);
  log2.log("[buildPendingTransaction] Calling SDK createTransactions with:", {
    entriesCount: entries.length,
    outputsCount: outputs.length,
    changeAddress: String(changeAddress),
    networkId,
    priorityFee,
    payloadHex: payloadHex?.slice(0, 40)
  });
  let wasmEntries;
  if (entries.length > 0) {
    const e = entries[0];
    const isWasmObject = e.__wbg_ptr !== void 0;
    const hasEntryGetter = typeof e.entry === "object" || typeof Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e) || {}, "entry")?.get === "function";
    let entryAmount, entryOutpoint, entryAddress;
    try {
      entryAmount = e.amount;
    } catch {
      entryAmount = "error";
    }
    try {
      const op = e.outpoint;
      entryOutpoint = op ? { txId: op.transactionId?.slice(0, 16), idx: op.index } : "null";
    } catch {
      entryOutpoint = "error";
    }
    try {
      entryAddress = e.address?.toString?.() || String(e.address);
    } catch {
      entryAddress = "error";
    }
    log2.log("[buildPendingTransaction] Entry analysis:", {
      isWasmObject,
      hasEntryGetter,
      hasOutpoint: typeof e.outpoint !== "undefined",
      protoName: e?.constructor?.name,
      amount: entryAmount,
      outpoint: entryOutpoint,
      address: entryAddress?.slice(0, 30)
    });
    if (isWasmObject) {
      wasmEntries = entries;
    } else {
      log2.log("[buildPendingTransaction] Converting plain JS entries to WASM UtxoEntries");
      wasmEntries = new UtxoEntries(entries);
      wasmEntries = wasmEntries.items;
    }
  } else {
    wasmEntries = entries;
  }
  log2.log("[buildPendingTransaction] Outputs:", outputs.map((o) => ({
    address: String(o.address)?.slice(0, 30),
    amount: o.amount,
    amountType: typeof o.amount
  })));
  let result;
  try {
    result = await createTransactions({
      // SDK expects 'entries' for Generator settings
      entries: wasmEntries,
      outputs,
      priorityFee,
      changeAddress: String(changeAddress),
      networkId,
      payload: payloadHex
    });
  } catch (err) {
    log2.error("[buildPendingTransaction] SDK createTransactions error:", err.message || err);
    throw err;
  }
  const { transactions } = result;
  if (!transactions || transactions.length === 0) {
    throw new Error("Failed to create transactions (empty result).");
  }
  return transactions[0];
}
__name(buildPendingTransaction, "buildPendingTransaction");
async function submitPendingTransaction({
  pendingTx,
  privateKeys,
  client: client2
} = {}) {
  if (!pendingTx)
    throw new Error("submitPendingTransaction: pendingTx required.");
  if (!client2) throw new Error("submitPendingTransaction: client required.");
  if (privateKeys && privateKeys.length > 0) {
    await signPendingTransaction(pendingTx, privateKeys);
  }
  if (typeof pendingTx.submit !== "function") {
    throw new Error(
      "PendingTransaction.submit is not available in this WASM build."
    );
  }
  const submitRes = await pendingTx.submit(client2);
  const txid = pendingTx.id ?? submitRes?.transactionId ?? submitRes?.txid ?? null;
  return { txid, submitRes, pendingTx };
}
__name(submitPendingTransaction, "submitPendingTransaction");
async function buildSignSubmitTransaction({
  entries,
  outputs,
  priorityFee = 0n,
  changeAddress,
  networkId,
  payload,
  privateKeys,
  client: client2
} = {}) {
  const pendingTx = await buildPendingTransaction({
    entries,
    outputs,
    priorityFee,
    changeAddress,
    networkId,
    payload
  });
  return await submitPendingTransaction({ pendingTx, privateKeys, client: client2 });
}
__name(buildSignSubmitTransaction, "buildSignSubmitTransaction");
async function buildManualTransaction({
  entries,
  outputs,
  changeAddress,
  networkId,
  payload,
  priorityFee = 0n,
  autoChange = true
} = {}) {
  if (!Array.isArray(entries) || entries.length === 0) {
    throw new Error("buildManualTransaction: entries required.");
  }
  if (!Array.isArray(outputs) || outputs.length === 0) {
    throw new Error("buildManualTransaction: outputs required.");
  }
  if (!changeAddress) {
    throw new Error("buildManualTransaction: changeAddress required.");
  }
  if (!networkId) {
    throw new Error("buildManualTransaction: networkId required.");
  }
  const totalInput = calculateTotalBalance(entries);
  log2.log(`[buildManualTransaction] entries=${entries.length}, totalInput=${totalInput}`);
  let totalOutput = 0n;
  for (const out of outputs) {
    const amt = typeof out.amount === "bigint" ? out.amount : kaspaToSompi(String(out.amount));
    totalOutput += amt;
  }
  const payloadBytes = payload ? new TextEncoder().encode(payload).length : 0;
  const outputCount = autoChange ? outputs.length + 1 : outputs.length;
  const estimatedFee = estimateFee(entries.length, outputCount, payloadBytes) + priorityFee;
  const change = totalInput - totalOutput - estimatedFee;
  log2.log(`[buildManualTransaction] totalOutput=${totalOutput}, estimatedFee=${estimatedFee}, change=${change}`);
  if (change < 0n) {
    throw new Error(
      `Insufficient funds: input=${totalInput}, output=${totalOutput}, fee=${estimatedFee}, shortfall=${-change}`
    );
  }
  const finalOutputs = outputs.map((out) => ({
    address: String(out.address),
    amount: typeof out.amount === "bigint" ? out.amount : kaspaToSompi(String(out.amount))
  }));
  const pendingTx = await buildPendingTransaction({
    entries,
    outputs: finalOutputs,
    changeAddress,
    networkId,
    payload,
    priorityFee
  });
  return {
    pendingTx,
    totalInput,
    totalOutput,
    estimatedFee,
    change: autoChange ? change : 0n,
    outputs: finalOutputs,
    inputCount: entries.length,
    outputCount: finalOutputs.length
  };
}
__name(buildManualTransaction, "buildManualTransaction");
async function buildSplitUtxoTransaction({
  entries,
  address,
  splitCount,
  networkId,
  priorityFee = 0n
} = {}) {
  if (!Array.isArray(entries) || entries.length === 0) {
    throw new Error("buildSplitUtxoTransaction: entries required.");
  }
  if (!address) {
    throw new Error("buildSplitUtxoTransaction: address required.");
  }
  if (!splitCount || splitCount < 2 || splitCount > 100) {
    throw new Error("buildSplitUtxoTransaction: splitCount must be 2-100.");
  }
  if (!networkId) {
    throw new Error("buildSplitUtxoTransaction: networkId required.");
  }
  const totalInput = calculateTotalBalance(entries);
  const estimatedFee = estimateFee(entries.length, splitCount, 0) + priorityFee;
  const availableBalance = totalInput - estimatedFee;
  if (availableBalance < MIN_OUTPUT_SOMPI * BigInt(splitCount)) {
    throw new Error(
      `Insufficient funds to split into ${splitCount} outputs. Available: ${availableBalance}, minimum needed: ${MIN_OUTPUT_SOMPI * BigInt(splitCount)}`
    );
  }
  const splitAmount = availableBalance / BigInt(splitCount);
  const remainder = availableBalance % BigInt(splitCount);
  const outputs = [];
  for (let i = 0; i < splitCount; i++) {
    outputs.push({
      address: String(address),
      amount: i === 0 ? splitAmount + remainder : splitAmount
    });
  }
  const pendingTx = await buildPendingTransaction({
    entries,
    outputs,
    changeAddress: address,
    // Required but won't create extra output
    networkId,
    priorityFee
  });
  return {
    pendingTx,
    totalInput,
    estimatedFee,
    splitAmount,
    remainder,
    outputs,
    inputCount: entries.length,
    outputCount: splitCount
  };
}
__name(buildSplitUtxoTransaction, "buildSplitUtxoTransaction");

// kktp/engine/kaspa/transport/utxo_operations.js
var log3 = Logger.create(LogModule.transport.utxoOperations);
var DEFAULT_SMALL_THRESHOLD = 100000000n;
var DEFAULT_MAX_SMALL_SWEEP = 5;
var DEFAULT_MAX_INPUTS_PER_TX = 80;
var MIN_OUTPUT_AMOUNT = 50000000n;
async function manualSend({
  client: client2,
  networkId,
  fromAddress,
  toAddress,
  amountSompi,
  payload,
  privateKeys,
  priorityFee = 0n,
  engineIndex,
  totalEngines,
  utxoEntries,
  janitorMode = true,
  smallThreshold = DEFAULT_SMALL_THRESHOLD,
  maxSmallSweep = DEFAULT_MAX_SMALL_SWEEP
} = {}) {
  if (!client2) throw new Error("manualSend: client required.");
  if (!networkId) throw new Error("manualSend: networkId required.");
  if (!fromAddress) throw new Error("manualSend: fromAddress required.");
  if (!toAddress) throw new Error("manualSend: toAddress required.");
  if (amountSompi === void 0 || amountSompi === null) {
    throw new Error("manualSend: amountSompi required.");
  }
  const allEntries = utxoEntries || [];
  const logPrefix = `[manualSend E${engineIndex ?? "?"}]`;
  const utxoCount = allEntries.length;
  if (utxoCount === 0) {
    throw new Error("No UTXOs available (all may be pending).");
  }
  const { smallUtxos, largeUtxos } = categorizeByThreshold(allEntries, smallThreshold);
  log3.log(
    `${logPrefix} UTXOs: ${largeUtxos.length} large, ${smallUtxos.length} small, total=${utxoCount}`
  );
  const selection = selectUtxosForSend({
    largeUtxos,
    smallUtxos,
    amountSompi,
    engineIndex,
    totalEngines,
    janitorMode,
    maxSmallSweep,
    logPrefix
  });
  const { selectedEntries, selectedTotal, isJanitorRun, consolidatedCount } = selection;
  const payloadBytes = payload ? new TextEncoder().encode(payload).length : 0;
  const estimatedFee = estimateFee(selectedEntries.length, 2, payloadBytes) + priorityFee;
  const requiredTotal = amountSompi + estimatedFee;
  if (selectedTotal < requiredTotal) {
    throw new Error(
      `Insufficient funds: have ${sompiToKas(selectedTotal)} KAS, need ${sompiToKas(requiredTotal)} KAS (send: ${sompiToKas(amountSompi)}, fee: ~${sompiToKas(estimatedFee)})`
    );
  }
  const outputs = [{ address: toAddress, amount: amountSompi }];
  log3.log(
    `${logPrefix} Building tx: inputs=${selectedEntries.length}, total=${sompiToKas(selectedTotal)} KAS, sending=${sompiToKas(amountSompi)} KAS` + (isJanitorRun ? `, swept=${consolidatedCount} dust` : "")
  );
  const pendingTx = await buildPendingTransaction({
    entries: selectedEntries,
    outputs,
    changeAddress: fromAddress,
    networkId,
    payload,
    priorityFee
  });
  const result = await submitPendingTransaction({
    pendingTx,
    privateKeys,
    client: client2
  });
  const estimatedChange = selectedTotal - amountSompi - estimatedFee;
  return {
    transactionId: result.txid,
    submitRes: result.submitRes,
    inputCount: selectedEntries.length,
    outputCount: 2,
    // send + change (SDK creates change)
    totalInput: selectedTotal,
    totalOutput: amountSompi,
    estimatedFee,
    change: estimatedChange,
    usedEntries: selectedEntries,
    isJanitorRun,
    consolidatedCount,
    utxoCount
  };
}
__name(manualSend, "manualSend");
async function consolidateUtxos({
  client: client2,
  networkId,
  address,
  privateKeys,
  entries,
  targetCount = 5,
  priorityFee = 0n,
  maxInputsPerTx = DEFAULT_MAX_INPUTS_PER_TX,
  onProgress
} = {}) {
  if (!client2) throw new Error("consolidateUtxos: client required.");
  if (!networkId) throw new Error("consolidateUtxos: networkId required.");
  if (!address) throw new Error("consolidateUtxos: address required.");
  if (!privateKeys?.length) throw new Error("consolidateUtxos: privateKeys required.");
  if (!entries?.length) throw new Error("No UTXOs available to consolidate.");
  if (targetCount < 1 || targetCount > 100) {
    throw new Error("consolidateUtxos: targetCount must be 1-100.");
  }
  const initialCount = entries.length;
  if (initialCount <= targetCount) {
    log3.log(
      `[consolidateUtxos] Already have ${initialCount} UTXOs (<= target ${targetCount}). No consolidation needed.`
    );
    return {
      transactionIds: [],
      rounds: 0,
      totalConsolidated: 0,
      previousUtxoCount: initialCount,
      finalUtxoCount: initialCount,
      spentKeys: [],
      noOpReason: "already_at_or_below_target"
    };
  }
  const txids = [];
  let totalConsolidated = 0;
  let round = 0;
  let currentMaxInputs = maxInputsPerTx;
  const spentInSession = /* @__PURE__ */ new Set();
  const filterAvailable = /* @__PURE__ */ __name((utxos) => {
    return utxos.filter((entry) => {
      const key = getEntryKey(entry);
      return key && !spentInSession.has(key);
    });
  }, "filterAvailable");
  const estimatedRounds = Math.ceil(
    Math.log(entries.length / targetCount) / Math.log(currentMaxInputs)
  );
  log3.log(
    `[consolidateUtxos] Starting: ${entries.length} UTXOs \u2192 ${targetCount} target, ~${estimatedRounds} rounds estimated`
  );
  let availableEntries = filterAvailable(entries);
  while (availableEntries.length > targetCount) {
    round++;
    const inputCount = Math.min(availableEntries.length, currentMaxInputs);
    const remainingAfterBatch = availableEntries.length - inputCount + 1;
    const isLastRound = remainingAfterBatch <= targetCount;
    const outputCount = isLastRound ? targetCount : 1;
    const sortedEntries = [...availableEntries].sort((a, b) => {
      const aa = entryAmountSompi(a);
      const bb = entryAmountSompi(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
    const batchEntries = sortedEntries.slice(0, inputCount);
    const batchTotal = calculateTotalBalance(batchEntries);
    const estimatedFee = estimateFee(inputCount, outputCount, 0) + priorityFee;
    const availableBalance = batchTotal - estimatedFee;
    if (availableBalance < MIN_OUTPUT_AMOUNT * BigInt(outputCount)) {
      log3.warn(
        `[consolidateUtxos] Round ${round}: Insufficient funds after fees. Batch: ${sompiToKas(batchTotal)} KAS, Fee: ${sompiToKas(estimatedFee)} KAS`
      );
      for (const entry of batchEntries) {
        const key = getEntryKey(entry);
        if (key) spentInSession.add(key);
      }
      availableEntries = filterAvailable(entries);
      if (availableEntries.length === 0) break;
      continue;
    }
    const outputs = buildConsolidationOutputs(address, availableBalance, outputCount);
    log3.log(
      `[consolidateUtxos] Round ${round}: Merging ${inputCount} \u2192 ${outputCount} output(s) (~${sompiToKas(availableBalance / BigInt(outputCount))} KAS each)`
    );
    try {
      const pendingTx = await buildPendingTransaction({
        entries: batchEntries,
        outputs,
        changeAddress: address,
        networkId,
        priorityFee
      });
      const result = await submitPendingTransaction({
        pendingTx,
        privateKeys,
        client: client2
      });
      txids.push(result.txid);
      totalConsolidated += inputCount;
      for (const entry of batchEntries) {
        const key = getEntryKey(entry);
        if (key) spentInSession.add(key);
      }
      log3.log(`[consolidateUtxos] Round ${round} complete: txid=${result.txid?.slice(0, 16)}\u2026`);
      if (typeof onProgress === "function") {
        onProgress({ round, estimatedRounds, txid: result.txid, inputCount, outputCount });
      }
      if (isLastRound) break;
      availableEntries = filterAvailable(entries);
      if (availableEntries.length === 0 || round > 50) {
        log3.warn(`[consolidateUtxos] Stopping: no progress or too many rounds.`);
        break;
      }
    } catch (err) {
      log3.error(`[consolidateUtxos] Round ${round} failed:`, err.message);
      if (err.message?.includes("mass exceeds") && currentMaxInputs > 20) {
        currentMaxInputs = Math.floor(currentMaxInputs * 0.6);
        log3.log(`[consolidateUtxos] Reducing batch size to ${currentMaxInputs}`);
        continue;
      }
      throw err;
    }
  }
  return {
    transactionId: txids[txids.length - 1],
    transactionIds: txids,
    rounds: round,
    inputCount: totalConsolidated,
    previousUtxoCount: initialCount,
    spentKeys: spentInSession
  };
}
__name(consolidateUtxos, "consolidateUtxos");
async function splitUtxos({
  client: client2,
  networkId,
  address,
  privateKeys,
  entries,
  splitCount,
  priorityFee = 0n
} = {}) {
  if (!client2) throw new Error("splitUtxos: client required.");
  if (!networkId) throw new Error("splitUtxos: networkId required.");
  if (!address) throw new Error("splitUtxos: address required.");
  if (!privateKeys?.length) throw new Error("splitUtxos: privateKeys required.");
  if (!entries?.length) throw new Error("No UTXOs available to split.");
  if (!splitCount || splitCount < 2 || splitCount > 100) {
    throw new Error("splitUtxos: splitCount must be 2-100.");
  }
  const txDetails = await buildSplitUtxoTransaction({
    entries,
    address,
    splitCount,
    networkId,
    priorityFee
  });
  const result = await submitPendingTransaction({
    pendingTx: txDetails.pendingTx,
    privateKeys,
    client: client2
  });
  return {
    transactionId: result.txid,
    submitRes: result.submitRes,
    splitCount,
    totalInput: txDetails.totalInput,
    splitAmount: txDetails.splitAmount,
    amountPerOutput: sompiToKas(txDetails.splitAmount),
    estimatedFee: txDetails.estimatedFee,
    outputCount: txDetails.outputCount,
    outputs: txDetails.outputs,
    previousUtxoCount: entries.length
  };
}
__name(splitUtxos, "splitUtxos");
function categorizeByThreshold(entries, threshold) {
  const smallUtxos = [];
  const largeUtxos = [];
  for (const entry of entries) {
    const amt = entryAmountSompi(entry);
    if (amt < threshold) {
      smallUtxos.push({ entry, amount: amt });
    } else {
      largeUtxos.push({ entry, amount: amt });
    }
  }
  largeUtxos.sort((a, b) => a.amount > b.amount ? -1 : 1);
  smallUtxos.sort((a, b) => a.amount > b.amount ? -1 : 1);
  return { smallUtxos, largeUtxos };
}
__name(categorizeByThreshold, "categorizeByThreshold");
function getUtxoSlot(utxoWithEntry, totalEngines) {
  const outpoint = getEntryOutpoint(utxoWithEntry.entry);
  if (!outpoint?.transactionId) return 0;
  const txid = outpoint.transactionId;
  let hash = 0;
  for (let i = 0; i < txid.length; i++) {
    hash = hash * 31 + txid.charCodeAt(i) >>> 0;
  }
  hash = hash * 31 + (outpoint.index || 0) >>> 0;
  return hash % totalEngines;
}
__name(getUtxoSlot, "getUtxoSlot");
function selectUtxosForSend({
  largeUtxos,
  smallUtxos,
  amountSompi,
  engineIndex,
  totalEngines,
  janitorMode,
  maxSmallSweep,
  logPrefix
}) {
  const selectedEntries = [];
  let selectedTotal = 0n;
  let isJanitorRun = false;
  let consolidatedCount = 0;
  if (typeof engineIndex === "number" && typeof totalEngines === "number") {
    const myLargeUtxos = largeUtxos.filter(
      (u) => getUtxoSlot(u, totalEngines) === engineIndex
    );
    const mySmallUtxos = janitorMode ? smallUtxos.filter((u) => getUtxoSlot(u, totalEngines) === engineIndex).slice(0, maxSmallSweep) : [];
    const minRequired = amountSompi + 100000n;
    if (myLargeUtxos.length === 0) {
      throw new Error(
        `Engine ${engineIndex}: No large UTXO in my slot. Total large: ${largeUtxos.length}, need more UTXOs (try splitting).`
      );
    }
    const primaryUtxo = myLargeUtxos.reduce(
      (best, curr) => curr.amount > best.amount ? curr : best
    );
    if (primaryUtxo.amount < minRequired) {
      throw new Error(
        `Engine ${engineIndex}: Primary UTXO too small. Need ${sompiToKas(minRequired)} KAS, have ${sompiToKas(primaryUtxo.amount)} KAS.`
      );
    }
    selectedEntries.push(primaryUtxo.entry);
    selectedTotal = primaryUtxo.amount;
    if (mySmallUtxos.length > 0) {
      isJanitorRun = true;
      let smallTotal = 0n;
      for (const small of mySmallUtxos) {
        selectedEntries.push(small.entry);
        selectedTotal += small.amount;
        smallTotal += small.amount;
        consolidatedCount++;
      }
      log3.log(
        `${logPrefix} \u{1F9F9} SMART JANITOR: Swept ${mySmallUtxos.length} dust in my slot (+${sompiToKas(smallTotal)} KAS)`
      );
    }
  } else {
    if (janitorMode && smallUtxos.length > 0 && largeUtxos.length > 0) {
      isJanitorRun = true;
      const primaryUtxo = largeUtxos.reduce(
        (best, curr) => curr.amount > best.amount ? curr : best
      );
      selectedEntries.push(primaryUtxo.entry);
      selectedTotal = primaryUtxo.amount;
      const toSweep = smallUtxos.slice(0, maxSmallSweep);
      let smallTotal = 0n;
      for (const small of toSweep) {
        selectedEntries.push(small.entry);
        selectedTotal += small.amount;
        smallTotal += small.amount;
        consolidatedCount++;
      }
      log3.log(
        `${logPrefix} \u{1F9F9} JANITOR: Sweeping ${toSweep.length} small UTXO(s) (${sompiToKas(smallTotal)} KAS)`
      );
    } else if (largeUtxos.length > 0) {
      const primaryUtxo = largeUtxos.reduce(
        (best, curr) => curr.amount > best.amount ? curr : best
      );
      selectedEntries.push(primaryUtxo.entry);
      selectedTotal = primaryUtxo.amount;
    } else if (smallUtxos.length > 0) {
      log3.log(
        `${logPrefix} No large UTXOs, combining ${smallUtxos.length} small UTXO(s)`
      );
      const minRequired = amountSompi + 100000n;
      for (const small of smallUtxos) {
        selectedEntries.push(small.entry);
        selectedTotal += small.amount;
        consolidatedCount++;
        if (selectedTotal >= minRequired) break;
      }
    } else {
      throw new Error("No UTXOs available.");
    }
  }
  return { selectedEntries, selectedTotal, isJanitorRun, consolidatedCount };
}
__name(selectUtxosForSend, "selectUtxosForSend");
function buildConsolidationOutputs(address, availableBalance, outputCount) {
  const outputs = [];
  if (outputCount === 1) {
    outputs.push({ address: String(address), amount: availableBalance });
  } else {
    const splitAmount = availableBalance / BigInt(outputCount);
    const remainder = availableBalance % BigInt(outputCount);
    for (let i = 0; i < outputCount; i++) {
      outputs.push({
        address: String(address),
        amount: i === 0 ? splitAmount + remainder : splitAmount
      });
    }
  }
  return outputs;
}
__name(buildConsolidationOutputs, "buildConsolidationOutputs");

// kktp/engine/kaspa/transport/rpc_runner.js
var log4 = Logger.create(LogModule.transport.rpcRunner);
async function runRpcCommand(client2, cmdText) {
  if (!client2 || !client2.isConnected) {
    return "Not connected to any RPC";
  }
  try {
    if (!cmdText) return "No command provided";
    const cmd = JSON.parse(cmdText);
    const methodName = cmd.method;
    const params = cmd.params || {};
    if (typeof client2[methodName] !== "function") {
      return `Method ${methodName} not found on RpcClient`;
    }
    const result = await client2[methodName](params);
    if (typeof result === "object") {
      return Object.entries(result).map(([k, v]) => `${k}: ${v}`).join("\n");
    } else {
      return String(result);
    }
  } catch (err) {
    log4.error("[RpcRunner] Error running RPC command:", err);
    return "Error: " + err;
  }
}
__name(runRpcCommand, "runRpcCommand");

// kktp/engine/kaspa/transport/heartbeat.js
var log5 = Logger.create(LogModule.transport.heartbeat);
var DEFAULT_USABLE_THRESHOLD = 100000000n;
var _HeartbeatMonitor = class _HeartbeatMonitor {
  /**
   * @param {Object} facade - TransportFacade instance for UTXO operations
   */
  constructor(facade) {
    this._facade = facade;
    this._timer = null;
    this._config = null;
    this._checkInProgress = false;
  }
  /**
   * Start the heartbeat monitor.
   *
   * @param {Object} options
   * @param {string} [options.address] - Primary address to monitor (receive address)
   * @param {string} [options.changeAddress] - Change address to also monitor
   * @param {string[]} [options.addresses] - Alternative: array of all addresses to monitor
   * @param {Array} options.privateKeys - Private keys for splitting/consolidating
   * @param {number} [options.intervalMs=15000] - Check interval (default 15s for fast response)
   * @param {number} [options.targetUtxoCount=10] - Minimum USABLE UTXO count threshold
   * @param {number} [options.splitCount=15] - Number of UTXOs to create when splitting
   * @param {bigint} [options.priorityFee=0n] - Priority fee for transactions
   * @param {bigint} [options.usableThreshold=1 KAS] - Minimum amount for a UTXO to be "usable"
   * @param {boolean} [options.autoConsolidate=true] - Auto-consolidate when too many small UTXOs
   * @param {number} [options.maxSmallUtxos=50] - Trigger consolidation when small count exceeds this
   * @param {function} [options.onCheck] - Callback on each check
   * @param {function} [options.onSplit] - Callback when split is triggered
   * @param {function} [options.onConsolidate] - Callback when consolidation is triggered
   * @param {function} [options.onError] - Callback on error
   */
  start({
    address,
    changeAddress,
    addresses,
    privateKeys,
    intervalMs = 15e3,
    targetUtxoCount = 10,
    splitCount = 15,
    priorityFee = 0n,
    usableThreshold = DEFAULT_USABLE_THRESHOLD,
    autoConsolidate = true,
    maxSmallUtxos = 50,
    onCheck,
    onSplit,
    onConsolidate,
    onError
  } = {}) {
    let allAddresses = [];
    if (Array.isArray(addresses) && addresses.length > 0) {
      allAddresses = addresses.filter((a) => a != null && a !== "").map((a) => String(a));
    } else {
      if (address) allAddresses.push(String(address));
      if (changeAddress && String(changeAddress) !== String(address)) {
        allAddresses.push(String(changeAddress));
      }
    }
    if (allAddresses.length === 0) {
      throw new Error("HeartbeatMonitor: at least one address required.");
    }
    if (!privateKeys?.length) {
      throw new Error("HeartbeatMonitor: privateKeys required.");
    }
    this.stop();
    this._config = {
      addresses: allAddresses,
      address: allAddresses[0],
      // Primary address for operations
      privateKeys,
      intervalMs,
      targetUtxoCount,
      splitCount,
      priorityFee,
      usableThreshold,
      autoConsolidate,
      maxSmallUtxos,
      onCheck,
      onSplit,
      onConsolidate,
      onError
    };
    const usableKas = sompiToKas(usableThreshold);
    const addrDisplay = allAddresses.length > 1 ? `${allAddresses.length} addresses (${allAddresses[0].slice(0, 16)}... + ${allAddresses.length - 1} more)` : allAddresses[0].slice(0, 24) + "...";
    log5.log(
      `[Heartbeat] Starting: check every ${intervalMs / 1e3}s, monitoring ${addrDisplay}, threshold=${targetUtxoCount} USABLE UTXOs (>= ${usableKas} KAS), split into ${splitCount}, autoConsolidate=${autoConsolidate} (max ${maxSmallUtxos} small)`
    );
    this._runCheck();
    this._timer = setInterval(() => this._runCheck(), intervalMs);
  }
  /**
   * Stop the heartbeat monitor.
   */
  stop() {
    if (this._timer) {
      clearInterval(this._timer);
      this._timer = null;
      log5.log("[Heartbeat] Stopped.");
    }
    this._config = null;
  }
  /**
   * Check if heartbeat is currently running.
   * @returns {boolean}
   */
  get isRunning() {
    return this._timer !== null;
  }
  /**
   * Get current heartbeat configuration (safe copy).
   * @returns {Object|null}
   */
  get config() {
    if (!this._config) return null;
    const { privateKeys, ...safeConfig } = this._config;
    return { ...safeConfig, hasPrivateKeys: !!privateKeys?.length };
  }
  /**
   * Manually trigger a heartbeat check.
   * @returns {Promise<void>}
   */
  async trigger() {
    if (!this._config) {
      throw new Error("Heartbeat not configured. Call start() first.");
    }
    await this._runCheck();
  }
  /**
   * Internal: Run a single heartbeat check.
   * @private
   */
  async _runCheck() {
    if (!this._config || this._checkInProgress) return;
    if (!this._facade.isConnected) {
      log5.warn("[Heartbeat] Skipping check - not connected.");
      return;
    }
    const {
      addresses,
      address,
      // Primary address for operations
      privateKeys,
      targetUtxoCount,
      splitCount,
      priorityFee,
      usableThreshold,
      autoConsolidate,
      maxSmallUtxos,
      onCheck,
      onSplit,
      onConsolidate,
      onError
    } = this._config;
    this._checkInProgress = true;
    try {
      let entries;
      if (addresses.length > 1) {
        entries = await this._facade.getUtxosForAddresses(addresses, {
          useCache: false,
          excludeSpent: true
        });
      } else {
        entries = await this._facade.getUtxos(addresses[0], {
          useCache: false,
          excludeSpent: true
        });
      }
      const totalCount = entries.length;
      const totalBalance = this._facade.calculateTotalBalance(entries);
      let usableCount = 0;
      let usableBalance = 0n;
      let smallCount = 0;
      let smallBalance = 0n;
      for (const entry of entries) {
        const amt = entryAmountSompi(entry);
        if (amt >= usableThreshold) {
          usableCount++;
          usableBalance += amt;
        } else {
          smallCount++;
          smallBalance += amt;
        }
      }
      const addrInfo = addresses.length > 1 ? ` (across ${addresses.length} addresses)` : "";
      log5.log(
        `[Heartbeat] Check: ${usableCount} usable (>= ${sompiToKas(usableThreshold)} KAS), ${smallCount} small, total: ${sompiToKas(totalBalance)} KAS${addrInfo}`
      );
      if (typeof onCheck === "function") {
        try {
          onCheck({
            totalCount,
            usableCount,
            smallCount,
            targetUtxoCount,
            totalBalance,
            usableBalance,
            smallBalance,
            entries,
            addresses
          });
        } catch (cbErr) {
          log5.warn("[Heartbeat] onCheck callback error:", cbErr);
        }
      }
      if (usableCount === 0 && totalCount > 0) {
        log5.warn(
          `[Heartbeat] \u{1F6A8} CRITICAL: No usable UTXOs! Have ${totalCount} small UTXOs (${sompiToKas(totalBalance)} KAS). Checking options...`
        );
        if (totalCount >= 2 && autoConsolidate) {
          log5.log(`[Heartbeat] \u{1F527} Attempting emergency consolidation: ${totalCount} UTXOs \u2192 1`);
          await this._doConsolidate({
            address,
            addresses,
            // Multi-address support
            privateKeys,
            targetCount: 1,
            // Merge ALL into 1 to maximize the single output
            priorityFee,
            onConsolidate,
            onError,
            emergency: true
          });
        } else if (totalCount === 1) {
          log5.warn(
            `[Heartbeat] \u26A0\uFE0F Only 1 small UTXO (${sompiToKas(totalBalance)} KAS). Cannot consolidate or split. Need more funds or wait for confirmations.`
          );
          this._invokeErrorCallback(onError, "insufficient_utxos", new Error(
            `Only 1 small UTXO (${sompiToKas(totalBalance)} KAS). Need more funds.`
          ), true);
        }
        this._checkInProgress = false;
        return;
      }
      if (autoConsolidate && smallCount > maxSmallUtxos) {
        log5.log(
          `[Heartbeat] \u26A0\uFE0F Fragmentation detected: ${smallCount} small UTXOs (> ${maxSmallUtxos}). Consolidating to prevent wallet degradation...`
        );
        await this._doConsolidate({
          address,
          addresses,
          // Multi-address support
          privateKeys,
          targetCount: splitCount,
          priorityFee,
          onConsolidate,
          onError,
          emergency: false
        });
        this._checkInProgress = false;
        return;
      }
      if (usableCount > 0 && usableCount < targetUtxoCount) {
        const feePerOutput = 1000000n;
        const totalFees = feePerOutput * BigInt(targetUtxoCount);
        const availableForSplit = usableBalance - totalFees;
        const maxPossibleOutputs = availableForSplit > 0n ? Number(availableForSplit / usableThreshold) : 0;
        const desiredOutputs = Math.min(targetUtxoCount, maxPossibleOutputs);
        const wouldIncreaseCount = desiredOutputs > usableCount;
        const amountPerOutput = desiredOutputs > 0 ? (usableBalance - totalFees) / BigInt(desiredOutputs) : 0n;
        const outputsWillBeUsable = amountPerOutput >= usableThreshold;
        if (wouldIncreaseCount && outputsWillBeUsable && desiredOutputs >= 2) {
          log5.log(
            `[Heartbeat] \u26A1 Low usable UTXO count (${usableCount} < ${targetUtxoCount}). Splitting ${usableCount} UTXOs into ${desiredOutputs} @ ~${sompiToKas(amountPerOutput)} KAS each...`
          );
          await this._doSplit({
            address,
            addresses,
            // Multi-address support
            privateKeys,
            splitCount: desiredOutputs,
            // Use calculated count, not config splitCount
            priorityFee,
            minUtxoAmount: usableThreshold,
            // Only split usable UTXOs
            previousCount: usableCount,
            onSplit,
            onError
          });
        } else if (!wouldIncreaseCount) {
          log5.log(
            `[Heartbeat] \u2139\uFE0F Have ${usableCount} usable UTXOs (target: ${targetUtxoCount}). Can only create ${maxPossibleOutputs} from current balance - skipping split.`
          );
        } else if (!outputsWillBeUsable) {
          log5.log(
            `[Heartbeat] \u2139\uFE0F Have ${usableCount} usable UTXOs (target: ${targetUtxoCount}). Splitting would create outputs of ${sompiToKas(amountPerOutput)} KAS (below ${sompiToKas(usableThreshold)} KAS threshold) - skipping.`
          );
        } else {
          log5.log(
            `[Heartbeat] \u2139\uFE0F Have ${usableCount} usable UTXOs (target: ${targetUtxoCount}). Insufficient balance to split further.`
          );
        }
      }
    } catch (err) {
      log5.error(`[Heartbeat] Check failed: ${err?.message || err}`);
      this._invokeErrorCallback(onError, "check", err);
    } finally {
      this._checkInProgress = false;
    }
  }
  /**
   * Internal: Perform UTXO consolidation.
   * @private
   */
  async _doConsolidate({
    address,
    addresses,
    privateKeys,
    targetCount,
    priorityFee,
    onConsolidate,
    onError,
    emergency = false
  }) {
    const prefix = emergency ? "\u{1F6A8} EMERGENCY" : "\u{1F9F9}";
    try {
      const result = await this._facade.consolidateUtxos({
        address,
        addresses,
        // Pass addresses array for multi-address fetching
        privateKeys,
        targetCount,
        priorityFee
      });
      if (result.noOpReason) {
        log5.log(`[Heartbeat] ${prefix} Consolidation skipped: ${result.noOpReason}`);
        if (typeof onConsolidate === "function") {
          try {
            onConsolidate({
              previousCount: result.previousUtxoCount,
              newCount: result.finalUtxoCount,
              transactionId: null,
              result,
              emergency,
              noOpReason: result.noOpReason
            });
          } catch (cbErr) {
            log5.warn("[Heartbeat] onConsolidate callback error:", cbErr);
          }
        }
        return;
      }
      log5.log(
        `[Heartbeat] ${prefix} Consolidation complete: ${result.previousUtxoCount} \u2192 ${result.finalUtxoCount} UTXOs`
      );
      if (typeof onConsolidate === "function") {
        try {
          onConsolidate({
            previousCount: result.previousUtxoCount,
            newCount: result.finalUtxoCount,
            transactionId: result.transactionId,
            result,
            emergency
          });
        } catch (cbErr) {
          log5.warn("[Heartbeat] onConsolidate callback error:", cbErr);
        }
      }
    } catch (err) {
      log5.error(`[Heartbeat] ${prefix} Consolidation failed: ${err?.message || err}`);
      this._invokeErrorCallback(onError, "consolidate", err, emergency);
    }
  }
  /**
   * Internal: Perform UTXO split.
   * @private
   */
  async _doSplit({
    address,
    addresses,
    privateKeys,
    splitCount,
    priorityFee,
    minUtxoAmount,
    previousCount,
    onSplit,
    onError
  }) {
    try {
      const result = await this._facade.splitUtxos({
        address,
        addresses,
        // Pass addresses array for multi-address fetching
        splitCount,
        privateKeys,
        priorityFee,
        minUtxoAmount
        // Filter to only usable UTXOs
      });
      log5.log(
        `[Heartbeat] \u2713 Split complete: txid=${result.transactionId?.slice(0, 16)}\u2026, created ${result.splitCount} UTXOs @ ${result.amountPerOutput} KAS each`
      );
      if (typeof onSplit === "function") {
        try {
          onSplit({
            previousCount,
            newCount: splitCount,
            transactionId: result.transactionId,
            result
          });
        } catch (cbErr) {
          log5.warn("[Heartbeat] onSplit callback error:", cbErr);
        }
      }
    } catch (err) {
      log5.error(`[Heartbeat] Split failed: ${err?.message || err}`);
      this._invokeErrorCallback(onError, "split", err);
    }
  }
  /**
   * Internal: Safely invoke error callback.
   * @private
   */
  _invokeErrorCallback(onError, type, error, emergency = false) {
    if (typeof onError === "function") {
      try {
        onError({ type, error, emergency });
      } catch (cbErr) {
        log5.warn("[Heartbeat] onError callback error:", cbErr);
      }
    }
  }
};
__name(_HeartbeatMonitor, "HeartbeatMonitor");
var HeartbeatMonitor = _HeartbeatMonitor;

// kktp/engine/kaspa/transport/transportFacade.js
var _TransportFacade = class _TransportFacade {
  constructor() {
    this.client = null;
    this.networkId = null;
    this._utxoCache = /* @__PURE__ */ new Map();
    this._utxoCacheTtlMs = 500;
    this._spentUtxos = /* @__PURE__ */ new Set();
    this._heartbeat = new HeartbeatMonitor(this);
  }
  // 
  // Connection
  // 
  async connect(options = {}) {
    const { rpcUrl, networkId = "testnet-10", onDisconnect } = options || {};
    this.client = await connect({ rpcUrl, networkId, onDisconnect });
    this.networkId = networkId;
    return this.client;
  }
  async disconnect() {
    this._heartbeat.stop();
    if (this.client) {
      await this.client.disconnect();
      this.client = null;
    }
    this._utxoCache.clear();
    this._spentUtxos.clear();
  }
  get isConnected() {
    return !!(this.client && this.client.isConnected);
  }
  // 
  // UTXO Cache & Tracking
  // 
  async getUtxos(address, { useCache = false, excludeSpent = true } = {}) {
    this._checkConnected();
    if (useCache) {
      const cached = this._utxoCache.get(address);
      if (cached && Date.now() - cached.timestamp < this._utxoCacheTtlMs) {
        return excludeSpent ? this._filterSpentUtxos(cached.entries) : cached.entries;
      }
    }
    const entries = await getUtxosByAddress(this.client, address);
    this._utxoCache.set(address, { entries, timestamp: Date.now() });
    return excludeSpent ? this._filterSpentUtxos(entries) : entries;
  }
  /**
   * Fetch UTXOs for multiple addresses (e.g., receive + change).
   * Results are deduplicated and cached per-address.
   * @param {string[]} addresses - Array of addresses to query
   * @param {Object} [options] - { useCache, excludeSpent }
   * @returns {Promise<Array>} Deduplicated UTXO entries
   */
  async getUtxosForAddresses(addresses, { useCache = false, excludeSpent = true } = {}) {
    this._checkConnected();
    const validAddresses = (addresses || []).filter((a) => a != null && a !== "").map((a) => String(a));
    if (validAddresses.length === 0) {
      return [];
    }
    if (validAddresses.length === 1) {
      return this.getUtxos(validAddresses[0], { useCache, excludeSpent });
    }
    if (useCache) {
      const now3 = Date.now();
      const allCached = validAddresses.every((addr) => {
        const cached = this._utxoCache.get(addr);
        return cached && now3 - cached.timestamp < this._utxoCacheTtlMs;
      });
      if (allCached) {
        const allEntries = [];
        const seen = /* @__PURE__ */ new Set();
        for (const addr of validAddresses) {
          const cached = this._utxoCache.get(addr);
          for (const entry of cached.entries) {
            const key = getEntryKey(entry);
            if (!seen.has(key)) {
              seen.add(key);
              allEntries.push(entry);
            }
          }
        }
        return excludeSpent ? this._filterSpentUtxos(allEntries) : allEntries;
      }
    }
    const entries = await getUtxosByAddresses(this.client, validAddresses);
    const now2 = Date.now();
    const compositeKey = validAddresses.sort().join("|");
    this._utxoCache.set(compositeKey, { entries, timestamp: now2 });
    for (const addr of validAddresses) {
      this._utxoCache.delete(addr);
    }
    return excludeSpent ? this._filterSpentUtxos(entries) : entries;
  }
  _filterSpentUtxos(entries) {
    return entries.filter((e) => !this._spentUtxos.has(getEntryKey(e)));
  }
  markUtxosAsSpent(entries) {
    for (const e of entries || []) {
      this._spentUtxos.add(getEntryKey(e));
    }
  }
  clearSpentUtxos(entries) {
    if (entries) {
      for (const e of entries) {
        this._spentUtxos.delete(getEntryKey(e));
      }
    } else {
      this._spentUtxos.clear();
    }
  }
  invalidateUtxoCache(address) {
    if (!address) {
      this._utxoCache.clear();
    } else if (Array.isArray(address)) {
      for (const addr of address) {
        this._utxoCache.delete(String(addr));
      }
      for (const key of this._utxoCache.keys()) {
        if (key.includes("|") && address.some((a) => key.includes(String(a)))) {
          this._utxoCache.delete(key);
        }
      }
    } else {
      this._utxoCache.delete(String(address));
      for (const key of this._utxoCache.keys()) {
        if (key.includes("|") && key.includes(String(address))) {
          this._utxoCache.delete(key);
        }
      }
    }
  }
  // 
  // UTXO Manager Proxies
  // 
  async getAccountUtxos(accountDescriptor) {
    this._checkConnected();
    return getAccountUtxos({ wallet: { rpc: this.client }, accountDescriptor });
  }
  selectUtxosLargestFirst(entries, options) {
    return selectUtxosLargestFirst(entries, options);
  }
  selectUtxoForEngine(entries, engineIndex, totalEngines, minAmount) {
    return selectUtxoForEngine(entries, engineIndex, totalEngines, minAmount);
  }
  calculateTotalBalance(entries) {
    return calculateTotalBalance(entries);
  }
  categorizeUtxos(entries) {
    return categorizeUtxos(entries);
  }
  getEntryAmount(entry) {
    return entryAmountSompi(entry);
  }
  // 
  // TX Builder Proxies
  // 
  async estimateTransaction(args) {
    return estimateTransaction(args);
  }
  estimateFee(inputCount, outputCount, payloadBytes = 0) {
    return estimateFee(inputCount, outputCount, payloadBytes);
  }
  async buildPendingTransaction(args) {
    return buildPendingTransaction(args);
  }
  async buildManualTransaction(options) {
    this._checkConnected();
    return buildManualTransaction({ ...options, networkId: this.networkId });
  }
  async buildSplitUtxoTransaction(options) {
    this._checkConnected();
    return buildSplitUtxoTransaction({ ...options, networkId: this.networkId });
  }
  async signPendingTransaction(pendingTx, privateKeys) {
    return signPendingTransaction(pendingTx, privateKeys);
  }
  async submitPendingTransaction(pendingTx, privateKeys = []) {
    this._checkConnected();
    return submitPendingTransaction({ pendingTx, privateKeys, client: this.client });
  }
  async buildSignSubmitTransaction(args) {
    this._checkConnected();
    return buildSignSubmitTransaction({ ...args, client: this.client });
  }
  // 
  // High-Level UTXO Operations (Delegate to utxo_operations.js)
  // 
  /**
   * Manually build and send a transaction with full control.
   * Supports janitor mode (dust sweeping).
   */
  async manualSend({
    fromAddress,
    toAddress,
    amount,
    payload,
    privateKeys,
    priorityFee = 0n,
    engineIndex,
    totalEngines,
    optimisticSpend = true,
    janitorMode = true,
    smallThreshold = 100000000n,
    maxSmallSweep = 5,
    addresses
  } = {}) {
    this._checkConnected();
    if (!fromAddress) throw new Error("manualSend: fromAddress required.");
    if (!toAddress) throw new Error("manualSend: toAddress required.");
    if (amount === void 0 || amount === null) throw new Error("manualSend: amount required.");
    const amountSompi = typeof amount === "bigint" ? amount : kasToSompi(amount);
    const allAddresses = Array.isArray(addresses) && addresses.length > 0 ? addresses.filter((a) => a != null && a !== "").map((a) => String(a)) : null;
    let utxoEntries;
    if (allAddresses && allAddresses.length > 1) {
      utxoEntries = await this.getUtxosForAddresses(allAddresses, {
        useCache: true,
        excludeSpent: optimisticSpend
      });
    } else {
      utxoEntries = await this.getUtxos(fromAddress, {
        useCache: true,
        excludeSpent: optimisticSpend
      });
    }
    const result = await manualSend({
      client: this.client,
      networkId: this.networkId,
      fromAddress,
      toAddress,
      amountSompi,
      payload,
      privateKeys,
      priorityFee,
      engineIndex,
      totalEngines,
      utxoEntries,
      janitorMode,
      smallThreshold,
      maxSmallSweep
    });
    if (optimisticSpend && result.usedEntries) {
      this.markUtxosAsSpent(result.usedEntries);
    }
    return result;
  }
  /**
   * Split UTXOs into multiple equal outputs for parallel transactions.
   * Supports multi-address mode: pass `addresses` array to fetch from all addresses.
   * @param {Object} options
   * @param {string} [options.address] - Primary address (for single-address mode)
   * @param {string[]} [options.addresses] - Array of addresses (for multi-address mode)
   * @param {number} options.splitCount - Number of outputs to create
   * @param {Array} options.privateKeys - Private keys for signing
   * @param {bigint} [options.priorityFee=0n] - Priority fee
   * @param {bigint} [options.minUtxoAmount] - Minimum UTXO amount to include (filters small UTXOs)
   */
  async splitUtxos({ address, addresses, splitCount, privateKeys, priorityFee = 0n, minUtxoAmount = 0n } = {}) {
    this._checkConnected();
    const allAddresses = Array.isArray(addresses) && addresses.length > 0 ? addresses.filter((a) => a != null && a !== "").map((a) => String(a)) : address ? [String(address)] : [];
    if (allAddresses.length === 0) throw new Error("splitUtxos: address or addresses required.");
    if (!splitCount || splitCount < 2 || splitCount > 100) {
      throw new Error("splitUtxos: splitCount must be 2-100.");
    }
    if (!privateKeys?.length) throw new Error("splitUtxos: privateKeys required.");
    const primaryAddress = allAddresses[0];
    this.clearSpentUtxos();
    this.invalidateUtxoCache(allAddresses);
    let entries;
    if (allAddresses.length > 1) {
      entries = await this.getUtxosForAddresses(allAddresses, { useCache: false, excludeSpent: false });
    } else {
      entries = await this.getUtxos(primaryAddress, { useCache: false, excludeSpent: false });
    }
    if (entries.length === 0) throw new Error("No UTXOs available to split.");
    let usableEntries = entries;
    if (minUtxoAmount > 0n) {
      usableEntries = entries.filter((e) => entryAmountSompi(e) >= minUtxoAmount);
      if (usableEntries.length === 0) {
        const totalBalance = this.calculateTotalBalance(entries);
        throw new Error(
          `No usable UTXOs (>= ${sompiToKas(minUtxoAmount)} KAS). Have ${entries.length} UTXOs totaling ${sompiToKas(totalBalance)} KAS but all are too small.`
        );
      }
    }
    const totalUsable = this.calculateTotalBalance(usableEntries);
    const feeEstimate = 1000000n * BigInt(splitCount);
    const amountPerOutput = (totalUsable - feeEstimate) / BigInt(splitCount);
    if (amountPerOutput < 50000000n) {
      throw new Error(
        `Split would create outputs too small (${sompiToKas(amountPerOutput)} KAS each). Need more funds or fewer splits.`
      );
    }
    const result = await splitUtxos({
      client: this.client,
      networkId: this.networkId,
      address: primaryAddress,
      privateKeys,
      entries: usableEntries,
      splitCount,
      priorityFee
    });
    this.clearSpentUtxos();
    this.invalidateUtxoCache(allAddresses);
    return result;
  }
  /**
   * Consolidate all UTXOs into a target number of equal outputs.
   * Supports multi-address mode: pass `addresses` array to fetch from all addresses.
   * @param {Object} options
   * @param {string} [options.address] - Primary address (for single-address mode)
   * @param {string[]} [options.addresses] - Array of addresses (for multi-address mode)
   * @param {Array} options.privateKeys - Private keys for signing
   * @param {number} [options.targetCount=5] - Target number of output UTXOs
   * @param {bigint} [options.priorityFee=0n] - Priority fee
   * @param {number} [options.maxInputsPerTx=80] - Maximum inputs per transaction
   * @param {function} [options.onProgress] - Progress callback
   */
  async consolidateUtxos({
    address,
    addresses,
    privateKeys,
    targetCount = 5,
    priorityFee = 0n,
    maxInputsPerTx = 80,
    onProgress
  } = {}) {
    this._checkConnected();
    const allAddresses = Array.isArray(addresses) && addresses.length > 0 ? addresses.filter((a) => a != null && a !== "").map((a) => String(a)) : address ? [String(address)] : [];
    if (allAddresses.length === 0) throw new Error("consolidateUtxos: address or addresses required.");
    if (!privateKeys?.length) throw new Error("consolidateUtxos: privateKeys required.");
    if (targetCount < 1 || targetCount > 100) {
      throw new Error("consolidateUtxos: targetCount must be 1-100.");
    }
    const primaryAddress = allAddresses[0];
    this.clearSpentUtxos();
    this.invalidateUtxoCache(allAddresses);
    let entries;
    if (allAddresses.length > 1) {
      entries = await this.getUtxosForAddresses(allAddresses, { useCache: false, excludeSpent: false });
    } else {
      entries = await this.getUtxos(primaryAddress, { useCache: false, excludeSpent: false });
    }
    if (entries.length === 0) throw new Error("No UTXOs available to consolidate.");
    const result = await consolidateUtxos({
      client: this.client,
      networkId: this.networkId,
      address: primaryAddress,
      privateKeys,
      entries,
      targetCount,
      priorityFee,
      maxInputsPerTx,
      onProgress
    });
    if (result.spentKeys) {
      for (const key of result.spentKeys) {
        this._spentUtxos.add(key);
      }
    }
    this.clearSpentUtxos();
    this.invalidateUtxoCache(allAddresses);
    await new Promise((resolve) => setTimeout(resolve, 2e3));
    let finalEntries;
    if (allAddresses.length > 1) {
      finalEntries = await this.getUtxosForAddresses(allAddresses, { useCache: false, excludeSpent: false });
    } else {
      finalEntries = await this.getUtxos(primaryAddress, { useCache: false, excludeSpent: false });
    }
    const finalBalance = this.calculateTotalBalance(finalEntries);
    return {
      ...result,
      outputCount: finalEntries.length,
      finalUtxoCount: finalEntries.length,
      totalInput: finalBalance,
      totalInputKas: sompiToKas(finalBalance),
      amountPerOutput: sompiToKas(
        finalBalance / BigInt(Math.max(1, finalEntries.length))
      )
    };
  }
  /**
   * Get UTXO analysis for an address.
   */
  async analyzeUtxos(address) {
    this._checkConnected();
    const entries = await this.getUtxos(address, { useCache: false, excludeSpent: false });
    const categories = this.categorizeUtxos(entries);
    const totalBalance = this.calculateTotalBalance(entries);
    return {
      address,
      totalBalance,
      totalBalanceKas: sompiToKas(totalBalance),
      utxoCount: entries.length,
      pendingSpent: this._spentUtxos.size,
      categories: {
        dust: { count: categories.dust.length, total: this.calculateTotalBalance(categories.dust) },
        small: { count: categories.small.length, total: this.calculateTotalBalance(categories.small) },
        medium: { count: categories.medium.length, total: this.calculateTotalBalance(categories.medium) },
        large: { count: categories.large.length, total: this.calculateTotalBalance(categories.large) }
      },
      entries
    };
  }
  // 
  // RPC
  // 
  async runRpcCommand(cmdText) {
    return runRpcCommand(this.client, cmdText);
  }
  // 
  // Heartbeat Proxies (delegates to HeartbeatMonitor)
  // 
  startHeartbeat(options) {
    return this._heartbeat.start(options);
  }
  stopHeartbeat() {
    return this._heartbeat.stop();
  }
  get isHeartbeatRunning() {
    return this._heartbeat.isRunning;
  }
  get heartbeatConfig() {
    return this._heartbeat.config;
  }
  async triggerHeartbeat() {
    return await this._heartbeat.trigger();
  }
  _checkConnected() {
    if (!this.client) throw new Error("TransportFacade: Not connected to Kaspa node.");
  }
};
__name(_TransportFacade, "TransportFacade");
var TransportFacade = _TransportFacade;

// kktp/engine/kaspa/identity/wallet_service.js
var wallet_service_exports = {};
__export(wallet_service_exports, {
  activateAccount: () => activateAccount,
  closeWallet: () => closeWallet,
  createWallet: () => createWallet,
  deleteWalletData: () => deleteWalletData2,
  estimateTransactionFee: () => estimateTransactionFee,
  generateNewAddress: () => generateNewAddress,
  getActiveAccountAddresses: () => getActiveAccountAddresses,
  getAllWallets: () => getAllWallets,
  getMnemonic: () => getMnemonic,
  getPrivateKeys: () => getPrivateKeys,
  getReceivingAddress: () => getReceivingAddress,
  getSpendableBalance: () => getSpendableBalance,
  getWalletContext: () => getWalletContext,
  getWalletSecret: () => getWalletSecret,
  getXprv: () => getXprv,
  init: () => init,
  send: () => send,
  setOnBalanceChange: () => setOnBalanceChange
});

// kktp/engine/kaspa/identity/storage.js
var storage_exports = {};
__export(storage_exports, {
  deleteWalletData: () => deleteWalletData,
  loadWalletData: () => loadWalletData,
  storeWalletData: () => storeWalletData
});

// kktp/engine/kaspa/crypto/encryption.js
function encryptMessage(plaintext, password) {
  if (typeof plaintext !== "string" || typeof password !== "string") {
    throw new TypeError("encryptMessage requires string inputs");
  }
  try {
    const cipherText = encryptXChaCha20Poly1305(plaintext, password);
    return {
      version: 1,
      // bump if you change format later
      cipherText
    };
  } catch (err) {
    throw new Error(`Encryption failed: ${err.message}`);
  }
}
__name(encryptMessage, "encryptMessage");
function decryptMessage(payload, password) {
  if (!password || typeof password !== "string") {
    throw new TypeError("decryptMessage requires a string password");
  }
  let cipherText;
  if (typeof payload === "string") {
    cipherText = payload;
  } else if (payload && typeof payload === "object" && payload.cipherText) {
    if (payload.version !== 1) {
      throw new Error(`Unsupported payload version: ${payload.version}`);
    }
    cipherText = payload.cipherText;
  } else {
    throw new TypeError(
      "decryptMessage requires a cipherText string or payload object"
    );
  }
  try {
    return decryptXChaCha20Poly1305(cipherText, password);
  } catch (err) {
    let msg = err && err.message ? err.message : String(err);
    if (msg.includes("Unable to decrypt")) {
      msg += " (likely due to the wrong password or corrupted data)";
    }
    throw new Error(`Decryption failed: ${msg}`);
  }
}
__name(decryptMessage, "decryptMessage");

// kktp/engine/kaspa/identity/storage.js
var DB_NAME = "KaspaWalletDB";
var STORE_NAME = "MetaDataStore";
var DB_VERSION = 2;
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: "filename" });
      }
    };
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}
__name(openDB, "openDB");
async function storeWalletData(walletData, masterPassword) {
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, "readwrite");
  const store = tx.objectStore(STORE_NAME);
  const encryptedPayload = encryptMessage(
    JSON.stringify(walletData),
    masterPassword
  );
  store.put({
    filename: walletData.filename,
    payload: encryptedPayload
  });
  return tx.complete;
}
__name(storeWalletData, "storeWalletData");
async function loadWalletData(filename2, masterPassword) {
  const db = await openDB();
  const tx = db.transaction(STORE_NAME, "readonly");
  const store = tx.objectStore(STORE_NAME);
  return new Promise((resolve, reject) => {
    const request = store.get(filename2);
    request.onsuccess = () => {
      const record = request.result;
      if (!record) {
        return reject(new Error(`No wallet found for filename: ${filename2}`));
      }
      try {
        const plaintext = decryptMessage(record.payload, masterPassword);
        resolve(JSON.parse(plaintext));
      } catch (err) {
        reject(new Error(`Failed to decrypt wallet data: ${err.message}`));
      }
    };
    request.onerror = () => reject(request.error);
  });
}
__name(loadWalletData, "loadWalletData");
async function deleteWalletData(filename2) {
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.includes(filename2)) {
      localStorage.removeItem(key);
    }
  }
  return new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase("kaspa_wallet_db");
    req.onsuccess = () => resolve();
    req.onerror = () => reject(req.error);
    req.onblocked = () => reject(new Error("Delete blocked"));
  });
}
__name(deleteWalletData, "deleteWalletData");

// kktp/engine/kaspa/identity/wallet_service.js
var DEFAULT_FILENAME = "default_wallet";
var defaultLogger = Logger.create(LogModule.identity.walletService);
var wallet = null;
var walletInitialized = false;
var walletSecret = null;
var accountId = null;
var filename = DEFAULT_FILENAME;
var currentNetworkId2 = null;
var currentAccountIndex = 0;
var currentReceivingAddress = null;
var log6 = /* @__PURE__ */ __name((...args) => defaultLogger.log(...args), "log");
var warn = /* @__PURE__ */ __name((...args) => defaultLogger.warn(...args), "warn");
var _onBalanceChange = null;
var walletOpened = false;
var walletConnected = false;
var walletStarted = false;
function getWalletContext() {
  if (!wallet) return null;
  return {
    ...wallet,
    // Spread all properties/methods from the Wallet instance
    walletInitialized,
    accountId,
    filename,
    currentNetworkId: currentNetworkId2,
    currentAccountIndex,
    currentReceivingAddress,
    log: log6
  };
}
__name(getWalletContext, "getWalletContext");
function getReceivingAddress() {
  return currentReceivingAddress;
}
__name(getReceivingAddress, "getReceivingAddress");
async function getActiveAccountAddresses() {
  if (!walletInitialized || !wallet) {
    return { receiveAddress: currentReceivingAddress || null, changeAddress: null };
  }
  try {
    const accounts = await wallet.accountsEnumerate({});
    if (!accounts?.accountDescriptors?.length) {
      return { receiveAddress: currentReceivingAddress || null, changeAddress: null };
    }
    const activeAccount = accounts.accountDescriptors[currentAccountIndex || 0];
    return {
      receiveAddress: activeAccount.receiveAddress ? String(activeAccount.receiveAddress) : null,
      changeAddress: activeAccount.changeAddress ? String(activeAccount.changeAddress) : null
    };
  } catch (err) {
    warn("[WalletService] getActiveAccountAddresses failed:", err.message);
    return { receiveAddress: currentReceivingAddress || null, changeAddress: null };
  }
}
__name(getActiveAccountAddresses, "getActiveAccountAddresses");
function getWalletSecret() {
  return walletSecret;
}
__name(getWalletSecret, "getWalletSecret");
async function getAllWallets() {
  if (!wallet) {
    throw new Error("Wallet not initialized. Call init() first.");
  }
  try {
    const result = await wallet.walletEnumerate({});
    return result.walletDescriptors || [];
  } catch (err) {
    throw new Error(
      "Failed to enumerate wallets: " + (err && err.message ? err.message : err)
    );
  }
}
__name(getAllWallets, "getAllWallets");
async function getMnemonic({ theFilename = "", password = "" } = {}) {
  if (theFilename.length === 0) {
    theFilename = filename;
  }
  if (password.length === 0) {
    password = walletSecret;
  }
  const walletData = await loadWalletData(theFilename, password);
  return walletData.mnemonic;
}
__name(getMnemonic, "getMnemonic");
async function getXprv() {
  if (!walletInitialized || !wallet) {
    throw new Error("Wallet not initialized. Call init() first.");
  }
  const walletData = await loadWalletData(filename, walletSecret);
  const xPrv = XPrv.fromXPrv(walletData.xprv);
  return xPrv.toString();
}
__name(getXprv, "getXprv");
async function getPrivateKeys({ keyCount = 10, changeKeyCount = 5 } = {}) {
  if (!walletInitialized || !wallet) {
    throw new Error("Wallet not initialized. Call init() first.");
  }
  const walletData = await loadWalletData(filename, walletSecret);
  if (!walletData?.xprv) {
    throw new Error("No xprv found in wallet data. Cannot derive private keys.");
  }
  const xPrv = XPrv.fromXPrv(walletData.xprv);
  const keyGen = new PrivateKeyGenerator(xPrv, false, BigInt(currentAccountIndex), null);
  const keys = [];
  for (let i = 0; i < keyCount; i++) {
    keys.push(keyGen.receiveKey(i));
  }
  for (let i = 0; i < changeKeyCount; i++) {
    keys.push(keyGen.changeKey(i));
  }
  return keys;
}
__name(getPrivateKeys, "getPrivateKeys");
async function getSpendableBalance() {
  const res = await wallet.accountsGet({ accountId });
  let bal = null;
  if (res.account?.balance) {
    bal = res.account.balance;
  } else if (res.accounts?.[0]?.balance) {
    bal = res.accounts[0].balance;
  } else if (res.accountDescriptor?.balance) {
    bal = res.accountDescriptor.balance;
  }
  if (!bal || !bal.mature) {
    return 0n;
  }
  return BigInt(bal.mature);
}
__name(getSpendableBalance, "getSpendableBalance");
function init({
  rpcClient,
  networkId,
  balanceElementId = null,
  onBalanceChange = null,
  logger = null
} = {}) {
  if (walletInitialized) return walletInitialized;
  if (typeof logger === "function") {
    log6 = logger;
    warn = logger;
  } else {
    log6 = /* @__PURE__ */ __name((...args) => defaultLogger.log(...args), "log");
    warn = /* @__PURE__ */ __name((...args) => defaultLogger.warn(...args), "warn");
  }
  if (typeof onBalanceChange === "function") {
    _onBalanceChange = onBalanceChange;
  }
  currentNetworkId2 = networkId;
  wallet = new Wallet({
    resident: false,
    networkId,
    url: rpcClient?.url || void 0,
    resolver: rpcClient?.url ? void 0 : new Resolver()
  });
  if (rpcClient?.url) {
    log6("Initializing wallet with direct connect to RPC URL:", rpcClient.url);
  } else {
    log6("Initializing wallet with public node using RPC resolver.");
  }
  wallet.addEventListener("balance", (event) => {
    const bal = event?.data?.balance;
    if (bal && typeof bal.mature !== "undefined") {
      const matureBalance = sompiToKaspaString(bal.mature);
      log6("Balance changed:", matureBalance, "KAS");
      try {
        let balanceResult = null;
        if (balanceElementId) {
          balanceResult = document.getElementById(balanceElementId);
          balanceResult.textContent = `Balance:
${matureBalance} KAS`;
        }
      } catch (err) {
        log6("Error updating balance element:", err);
      }
      if (typeof _onBalanceChange === "function") {
        _onBalanceChange(matureBalance);
      }
    }
  });
  walletInitialized = true;
  return walletInitialized;
}
__name(init, "init");
function setOnBalanceChange(cb) {
  _onBalanceChange = typeof cb === "function" ? cb : null;
}
__name(setOnBalanceChange, "setOnBalanceChange");
async function closeWallet() {
  try {
    await wallet.walletClose();
  } catch (err) {
    log6("Error closing wallet:", err);
    throw err;
  }
  wallet = null;
  walletInitialized = false;
  walletSecret = null;
  accountId = null;
  currentAccountIndex = 0;
  filename = DEFAULT_FILENAME;
  log6 = /* @__PURE__ */ __name(() => {
  }, "log");
  walletOpened = false;
  walletConnected = false;
  walletStarted = false;
}
__name(closeWallet, "closeWallet");
async function createWallet({
  password,
  walletFilename = DEFAULT_FILENAME,
  userHint = "",
  mnemonic = null,
  storeMnemonic = false,
  discoverAddresses = true
}) {
  if (!walletInitialized) {
    throw new Error("Wallet not initialized. Call init() first.");
  }
  walletSecret = password;
  filename = walletFilename || DEFAULT_FILENAME;
  try {
    if (!walletOpened) {
      log6("Opening wallet...");
      const descriptors = await wallet.walletOpen({
        accountDescriptors: true,
        filename,
        walletSecret
      });
      log6("Wallet accounts:", descriptors);
      if (descriptors) {
        walletOpened = true;
        log6("Wallet opened.");
      }
    }
    if (!walletConnected) {
      log6("Connecting wallet...");
      await wallet.connect();
      walletConnected = true;
      log6("Wallet connected.");
    }
    if (!walletStarted) {
      log6("Starting wallet...");
      await wallet.start();
      walletStarted = true;
      log6("Wallet started.");
    }
    const address = await activateAccount();
    return { address: address.toString() };
  } catch (err) {
    return await _createNewWallet({
      password,
      walletFilename,
      userHint,
      mnemonic,
      storeMnemonic,
      discoverAddresses
    });
  }
}
__name(createWallet, "createWallet");
async function _createNewWallet({
  password,
  walletFilename = DEFAULT_FILENAME,
  userHint = "",
  mnemonic = null,
  storeMnemonic = false,
  discoverAddresses = true
}) {
  log6("Creating new wallet...");
  const mnemonicPhrase = mnemonic || _generateMnemonic(24);
  filename = walletFilename;
  try {
    const descriptor = await wallet.walletCreate({
      filename,
      overwriteWalletStorage: false,
      title: filename,
      userHint,
      walletSecret: password
    });
  } catch (err) {
    const msg = err && err.message ? err.message : String(err);
    if (msg.includes("Wallet already exists")) {
    } else {
      throw new Error("Error creating wallet: " + msg);
    }
  }
  if (!walletOpened) {
    log6("Opening newly created wallet...");
    await wallet.walletOpen({ filename, walletSecret });
    walletOpened = true;
    log6("Wallet opened.");
  }
  let prvKeyData = await wallet.prvKeyDataCreate({
    walletSecret,
    kind: "mnemonic",
    mnemonic: mnemonicPhrase
  });
  let account = await wallet.accountsCreate({
    walletSecret,
    type: "bip32",
    accountName: "Account-B",
    prvKeyDataId: prvKeyData.prvKeyDataId
  });
  accountId = account.accountDescriptor.accountId;
  const xprv = await _getXPrv(mnemonicPhrase);
  const xPrvString = xprv.toString();
  if (storeMnemonic) {
    await storeWalletData(
      { filename, mnemonic: mnemonicPhrase, xprv: xPrvString },
      password
    );
  } else {
    await storeWalletData({ filename, xprv: xPrvString }, password);
  }
  if (!walletConnected) {
    log6("Connecting wallet...");
    await wallet.connect();
    walletConnected = true;
    log6("Wallet connected.");
  }
  if (!walletStarted) {
    log6("Starting wallet...");
    await wallet.start();
    walletStarted = true;
    log6("Wallet started.");
  }
  if (discoverAddresses) {
    log6("Performing accounts discovery...");
    const results = await wallet.accountsDiscovery({
      accountScanExtent: 10,
      // scan first 10 accounts
      addressScanExtent: 50,
      // scan first 50 addresses per account
      bip39_mnemonic: mnemonicPhrase,
      discoveryKind: AccountsDiscoveryKind.BIP44
    });
    log6("Accounts discovery completed.");
  }
  const address = await activateAccount();
  log6("Wallet created and data stored securely.");
  return { address: address.toString(), mnemonic: mnemonicPhrase };
}
__name(_createNewWallet, "_createNewWallet");
async function activateAccount(accountIndex = 0) {
  log6("Activating account...");
  currentAccountIndex = accountIndex;
  const accounts = await wallet.accountsEnumerate();
  accountId = accounts.accountDescriptors[accountIndex].accountId;
  const address = accounts.accountDescriptors[accountIndex].receiveAddress;
  await wallet.accountsActivate({ accountId });
  log6("Account activated. Receiving address:", address);
  currentReceivingAddress = address.toString();
  return address;
}
__name(activateAccount, "activateAccount");
async function estimateTransactionFee({
  amount,
  toAddress,
  payload,
  priorityFeeKas
}) {
  if (toAddress == null || toAddress === "") {
    throw new Error("Invalid address: " + toAddress);
  }
  if (amount == null || isNaN(Number(amount))) {
    throw new Error(amount, " Kas, Amount must be >= MIN_KAS_AMOUNT");
  }
  const accounts = await wallet.accountsEnumerate({});
  if (!accounts.accountDescriptors?.length) {
    throw new Error("No accounts found in wallet.");
  }
  const activeAccount = accounts.accountDescriptors[currentAccountIndex];
  const changeAddress = activeAccount.changeAddress;
  const receiveAddress = activeAccount.receiveAddress;
  validateAddress(changeAddress);
  validateAddress(toAddress);
  log6("Fetching UTXOs for addresses...");
  const addresses = [receiveAddress, changeAddress].filter(Boolean);
  const utxoResult = await wallet.rpc.getUtxosByAddresses(addresses);
  const utxoEntries = Array.isArray(utxoResult) ? utxoResult : Array.isArray(utxoResult?.entries) ? utxoResult.entries : [];
  if (utxoEntries.length === 0) throw new Error("No UTXOs...");
  utxoEntries.sort((a, b) => a.amount > b.amount ? 1 : -1);
  log6(`UTXOs fetched: ${utxoEntries.length} entries.`);
  const amountSompi = kaspaToSompi(amount);
  const outputs = [
    {
      // Pass as string (validated above)
      address: String(toAddress),
      amount: amountSompi
    }
  ];
  let priorityFee = 0n;
  if (priorityFeeKas != null && priorityFeeKas !== "") {
    priorityFee = kaspaToSompi(priorityFeeKas);
  }
  let payloadHex = void 0;
  if (payload) {
    if (/^[0-9a-fA-F]*$/.test(payload) && payload.length % 2 === 0) {
      payloadHex = payload;
    } else {
      payloadHex = stringToHex(payload);
    }
  }
  const settings = {
    entries: utxoEntries,
    utxoEntries,
    outputs,
    changeAddress: String(changeAddress),
    priorityFee,
    payload: payloadHex,
    networkId: currentNetworkId2
  };
  let estimate;
  try {
    const generator = new Generator(settings);
    estimate = await generator.estimate();
    try {
      generator.free();
    } catch {
    }
    log6("Generator estimate completed.");
  } catch (err) {
    throw new Error(
      "Generator estimate failed: " + (err && err.message ? err.message : String(err))
    );
  }
  const totalFees = estimate.fees ?? 0n;
  const mass = estimate.mass ?? 0n;
  const baseFee = totalFees - priorityFee;
  return {
    mass,
    fees: totalFees,
    feesKas: sompiToKaspaString(totalFees),
    priorityFee,
    baseFee,
    utxos: utxoEntries
  };
}
__name(estimateTransactionFee, "estimateTransactionFee");
async function send({ amount, toAddress, payload, priorityFeeKas }) {
  if (!walletInitialized || !wallet) {
    throw new Error("Wallet not initialized. Call init() first.");
  }
  const toAddressObj = validateAddress(toAddress);
  let priorityFeeSompi = 0n;
  if (priorityFeeKas > 0) {
    priorityFeeSompi = kaspaToSompi(priorityFeeKas);
  }
  let amountSompi;
  amountSompi = kaspaToSompi(amount.toString());
  if (amountSompi <= 0n) {
    throw new Error("Amount must be greater than zero.");
  }
  let priorityFeeSompiChecked = priorityFeeSompi;
  if (typeof priorityFeeSompiChecked !== "bigint") {
    priorityFeeSompiChecked = BigInt(priorityFeeSompiChecked);
  }
  const sendRequest = {
    walletSecret,
    accountId,
    priorityFeeSompi: priorityFeeSompiChecked,
    destination: [
      {
        address: toAddressObj,
        amount: amountSompi
      }
    ]
  };
  if (payload) {
    if (!validatePayload(payload)) {
      throw new Error("Payload must be a string and <= 32KB");
    }
    const hex2 = stringToHex(payload);
    if (hex2.length % 2 !== 0) {
      throw new Error("Invalid hex payload");
    }
    if (hex2.length / 2 > 32 * 1024) {
      throw new Error("Payload too large");
    }
    sendRequest.payload = hex2;
  }
  try {
    return await wallet.accountsSend(sendRequest);
  } catch (err) {
    const causeMsg = err && err.message ? err.message : String(err);
    throw new Error(`Transaction failed: ${causeMsg}`, { cause: err });
  }
}
__name(send, "send");
async function generateNewAddress(change = false) {
  const addr = await wallet.accountsCreateNewAddress({
    accountId,
    networkId: wallet.networkId,
    addressKind: change ? "change" : "receive"
  });
  return addr.address;
}
__name(generateNewAddress, "generateNewAddress");
async function deleteWalletData2(filename2) {
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.includes(filename2)) {
      localStorage.removeItem(key);
    }
  }
  return new Promise((resolve, reject) => {
    const req = indexedDB.deleteDatabase("kaspa_wallet_db");
    req.onsuccess = () => resolve();
    req.onerror = () => reject(req.error);
    req.onblocked = () => reject(new Error("Delete blocked"));
  });
}
__name(deleteWalletData2, "deleteWalletData");
function _generateMnemonic(wordCount = 24) {
  const mnemonic = Mnemonic.random(wordCount);
  return mnemonic.phrase;
}
__name(_generateMnemonic, "_generateMnemonic");
function _getXPrv(mnemonicPhrase, passphrase = null) {
  const seed = passphrase ? new Mnemonic(mnemonicPhrase).toSeed(passphrase) : new Mnemonic(mnemonicPhrase).toSeed();
  const xPrv = new XPrv(seed);
  return xPrv;
}
__name(_getXPrv, "_getXPrv");

// kktp/engine/kaspa/identity/identityFacade.js
var _IdentityFacade = class _IdentityFacade {
  constructor() {
    this.walletService = wallet_service_exports;
    this.storage = storage_exports;
  }
  /**
   * Initialize the wallet service with an RPC client.
   * @param {Object} options
   * @param {Object} options.client - The Kaspa RPC client.
   * @param {string} [options.networkId] - Network ID (e.g. 'testnet-10').
   * @param {string} [options.balanceElementId] - Optional DOM ID for auto-updating balance.
   * @param {function} [options.onBalanceChange] - Optional callback for balance changes.
   * @returns {Promise<void>}
   */
  async init({ client: client2, networkId, balanceElementId, onBalanceChange } = {}) {
    return await init({
      rpcClient: client2,
      networkId,
      balanceElementId,
      onBalanceChange
    });
  }
  /**
   * Update (or set) the balance-change callback after init.
   * @param {Function|null} cb
   */
  setOnBalanceChange(cb) {
    setOnBalanceChange(cb);
  }
  /**
   * Create a new wallet or open an existing one.
   * @param {Object} options
   * @param {string} options.password - Wallet password.
   * @param {string} [options.walletFilename] - Filename to save/load.
   * @param {string} [options.mnemonic] - Mnemonic to import (optional).
   * @param {boolean} [options.storeMnemonic] - Whether to store the mnemonic (default false).
   * @returns {Promise<{address: string, mnemonic: string}>}
   */
  async createOrOpenWallet(options) {
    return await createWallet(options);
  }
  /** Close the active wallet.
   * @returns {Promise<void>}
   */
  async closeWallet() {
    return await closeWallet();
  }
  /** Set the active account by index.
   * @param {number} index - Account index to activate.
   * @returns {Promise<void>}
   */
  async setActiveAccount(index) {
    return await activateAccount(index);
  }
  /** Generate a new receive address for the current wallet.
   * @returns {Promise<string>} New address.
   */
  async generateNewAddress() {
    return await generateNewAddress();
  }
  /** Estimate transaction fee.
   * @param {number|string} amount - Amount in KAS.
   * @param {string} toAddress - Recipient address.
   * @param {string} [payload] - Optional transaction payload.
   * @param {number} [priorityFeeKas] - Priority fee in KAS.
   * @returns {Promise<number>} Estimated fee in KAS.
   */
  async estimateTransactionFee(amount, toAddress, payload, priorityFeeKas) {
    return await estimateTransactionFee(
      amount,
      toAddress,
      payload,
      priorityFeeKas
    );
  }
  /**
   * Send a transaction.
   * @param {Object} options
   * @param {string} options.toAddress - Recipient address.
   * @param {number|string} options.amount - Amount in KAS.
   * @param {string} [options.payload] - Optional transaction payload.
   * @param {string} [options.password] - Wallet password (if required by service).
   * @param {number} [options.priorityFeeKas] - Priority fee in KAS.
   * @returns {Promise<Object>} Transaction result.
   */
  async send(options) {
    return await send(options);
  }
  /**
   * Delete a wallet from storage.
   * @param {string} filename
   */
  async deleteWallet(filename2) {
    return await deleteWalletData(filename2);
  }
  /** Get the extended private key (XPrv) of the active wallet.
   * @returns {Promise<string>} XPrv as hex string.
   */
  async getXprv() {
    return await getXprv();
  }
  /**
   * Get private keys for signing transactions manually.
   * Derives keys from the wallet's xprv for the active account.
   * @param {Object} [options] - Options
   * @param {number} [options.keyCount=10] - Number of receive keys
   * @param {number} [options.changeKeyCount=5] - Number of change keys
   * @returns {Promise<Array>} Array of PrivateKey objects
   */
  async getPrivateKeys(options) {
    return await getPrivateKeys(options);
  }
  /**
   * Access the mnemonic of the active wallet.
   */
  async getMnemonic() {
    return await getMnemonic();
  }
  /**
   * Access the spendable balance of the active wallet.
   */
  async getSpendableBalance() {
    return await getSpendableBalance();
  }
  /**
   * Access the active wallet instance if exposed by the service.
   */
  async getAllWallets() {
    return await getAllWallets();
  }
  /**
   * Access the Wallet class definition if available.
   * This allows advanced users to instantiate Wallet directly if needed.
   */
  get wallet() {
    return getWalletContext();
  }
  /** Access the receiving address of the active wallet. */
  get address() {
    return getReceivingAddress();
  }
  /**
   * Get the active account descriptor with receive and change addresses.
   * @returns {Promise<{ receiveAddress: string|null, changeAddress: string|null }>}
   */
  async getActiveAccount() {
    return await getActiveAccountAddresses();
  }
  /**
   * Access the wallet secret of the active wallet.
   */
  get walletSecret() {
    return getWalletSecret();
  }
};
__name(_IdentityFacade, "IdentityFacade");
var IdentityFacade = _IdentityFacade;

// kktp/engine/kaspa/intelligence/dag_walk.js
async function walkDagRange({
  client: client2,
  startHash,
  endHash = null,
  prefixes = [],
  onMatch,
  maxSeconds = 30,
  minTimestamp = 0,
  logFn = /* @__PURE__ */ __name(() => {
  }, "logFn")
} = {}) {
  const startedAt = Date.now();
  const deadline = startedAt + maxSeconds * 1e3;
  const hexPrefixes = prefixes.map((p) => payloadToHex(p)).filter(Boolean);
  let stopScore = Infinity;
  if (endHash) {
    try {
      const endResp = await client2.getBlock({
        hash: endHash,
        includeTransactions: true
      });
      logFn("[walkDagRange] endHash getBlock response:", endResp);
      const endBlockSafe = dehydrateBlock(endResp?.block);
      stopScore = endBlockSafe?.blueScore ?? Infinity;
      logFn("[walkDagRange] stopScore set to:", stopScore);
    } catch (err) {
      logFn(`[WARN] Could not resolve endHash score, walking to present.`);
    }
  }
  let lowHash = startHash;
  let loopCount = 0;
  while (Date.now() < deadline) {
    loopCount++;
    let resp;
    try {
      logFn(`[walkDagRange] Fetching blocks with lowHash: ${lowHash}`);
      resp = await client2.getBlocks({
        lowHash,
        includeBlocks: true,
        includeTransactions: true
      });
      logFn(`[walkDagRange] getBlocks response:`, resp);
    } catch (err) {
      logFn(`[RPC ERROR] ${err.message}`);
      logFn("[walkDagRange] getBlocks RPC ERROR:", err);
      break;
    }
    if (!resp?.blocks?.length) {
      logFn("[walkDagRange] No blocks returned, breaking.");
      break;
    }
    for (const block of resp.blocks) {
      const safeBlock = dehydrateBlock(block);
      logFn(`[walkDagRange] Processing block:`, safeBlock);
      if (safeBlock.blueScore > stopScore) {
        logFn(`[END] Reached blue score ${safeBlock.blueScore}`);
        logFn(
          `[walkDagRange] Exiting: blueScore ${safeBlock.blueScore} > stopScore ${stopScore}`
        );
        return;
      }
      if (safeBlock.timestamp < minTimestamp) {
        if (block.transactions) {
          for (const tx of block.transactions) if (tx.free) tx.free();
        }
        logFn(
          `[walkDagRange] Skipping block (timestamp too old):`,
          safeBlock.timestamp
        );
        continue;
      }
      const txs = block.transactions || [];
      for (const tx of txs) {
        const payload = (tx.payload || "").toLowerCase();
        if (hexPrefixes.length === 0 || hexPrefixes.some((preHex) => payload.startsWith(preHex))) {
          let decodedPayload = void 0;
          if (tx.payload) {
            try {
              decodedPayload = hexToString(tx.payload);
            } catch (e) {
              decodedPayload = void 0;
            }
          }
          const safeTx = dehydrateTx({ tx, block, decodedPayload });
          logFn(`[walkDagRange] Matching tx:`, safeTx);
          if (onMatch && await onMatch(safeTx, safeBlock) === true) {
            tx.free?.();
            return;
          }
        }
        if (typeof tx.free === "function") tx.free();
      }
    }
    const lastBlock = resp.blocks[resp.blocks.length - 1];
    const newLow = (lastBlock.hash || lastBlock.header?.hash).toString();
    logFn(
      `[walkDagRange] lastBlock.hash: ${newLow}, previous lowHash: ${lowHash}`
    );
    if (newLow === lowHash) {
      logFn("[walkDagRange] newLow equals lowHash, breaking.");
      break;
    }
    lowHash = newLow;
  }
  logFn(`[walkDagRange] Exiting main loop after ${loopCount} iterations.`);
}
__name(walkDagRange, "walkDagRange");

// kktp/engine/kaspa/intelligence/indexer.js
var log7 = Logger.create(LogModule.intelligence.indexer);
var IndexerEventType = Object.freeze({
  TRANSACTION_IN_MEMORY: "transaction-in-memory",
  MATCHING_TRANSACTION_IN_MEMORY: "matching-transaction-in-memory",
  BLOCK_IN_MEMORY: "block-in-memory",
  TRANSACTION_CACHED: "transaction-cached",
  MATCHING_TRANSACTION_CACHED: "matching-transaction-cached",
  BLOCK_CACHED: "block-cached",
  EVICT: "evict",
  FLUSH_COMPLETED: "flush-completed",
  EVICT_CYCLE_COMPLETED: "evict-cycle-completed"
});
var MatchMode = Object.freeze({
  ALL: "all",
  TRANSACTIONS: "transactions",
  MATCHING: "matching",
  BLOCKS: "blocks",
  CUSTOM: "custom"
});
var EvictionReason = Object.freeze({
  TTL: "ttl",
  SIZE: "size",
  IN_MEMORY_TRANSACTION: "in_memory_transaction",
  IN_MEMORY_BLOCK: "in_memory_block"
});
var IndexerStore = Object.freeze({
  TRANSACTIONS: "transactions",
  MATCHING_TRANSACTIONS: "matching_transactions",
  BLOCKS: "blocks"
});
var _KaspaIndexer = class _KaspaIndexer {
  constructor({
    ttlMinutes = null,
    flushInterval = 5e3,
    maxSize = null,
    batchThresholdRatio = 0.1,
    priorityTTL = true,
    inMemoryMaxTxs = 1e3,
    inMemoryMaxBlocks = 1e3,
    dbName = "kaspaIndexer",
    matchMode = MatchMode.ALL,
    indexAllTransactions = true,
    indexAllMatchingTransactions = true,
    indexAllBlocks = false,
    onIndexerUpdate = null
  } = {}) {
    // Metrics for observability
    __publicField(this, "_metrics", {
      transactionsIndexed: 0,
      blocksIndexed: 0,
      evictions: { ttl: 0, size: 0 },
      cacheHits: 0,
      cacheMisses: 0
    });
    // Default cap for cursor-based queries to avoid loading massive datasets into memory
    __publicField(this, "_defaultQueryLimit", 1e3);
    // In-memory rolling cache for deduplication
    __publicField(this, "_txidCacheSet", /* @__PURE__ */ new Set());
    __publicField(this, "_txidCacheQueue", []);
    __publicField(this, "_txidCacheMax", 1e3);
    // In-memory buffers for batch flush
    __publicField(this, "_pendingTxs", []);
    __publicField(this, "_pendingBlocks", []);
    __publicField(this, "_inMemoryMaxTxs", 1e3);
    // max in-memory txs/blocks before deduplication kicks in
    __publicField(this, "_inMemoryMaxBlocks", 1e3);
    __publicField(this, "_flushInterval", 5e3);
    // ms
    __publicField(this, "_flushTimer", null);
    // Prevent overlapping async operations
    __publicField(this, "_flushPromise", null);
    __publicField(this, "_evictPromise", null);
    // Prevent multiple initDB calls
    __publicField(this, "_initPromise", null);
    this.active = false;
    this.ttlMs = ttlMinutes ? ttlMinutes * 60 * 1e3 : null;
    this._flushInterval = flushInterval;
    this.maxSize = maxSize;
    this.batchThresholdRatio = batchThresholdRatio;
    this.priorityTTL = priorityTTL;
    this.dbName = dbName;
    this.db = null;
    this._evictionInterval = null;
    this.onIndexerUpdate = typeof onIndexerUpdate === "function" ? onIndexerUpdate : null;
    this.matchMode = matchMode;
    this.indexAllTransactions = indexAllTransactions;
    this.indexAllMatchingTransactions = indexAllMatchingTransactions;
    this.indexAllBlocks = indexAllBlocks;
    this._inMemoryMaxTxs = inMemoryMaxTxs;
    this._inMemoryMaxBlocks = inMemoryMaxBlocks;
    if (typeof maxSize === "number" && maxSize > 0) {
      this._defaultQueryLimit = maxSize;
    }
    this._dbReady = new Promise((resolve) => {
      this._resolveDbReady = resolve;
    });
  }
  get flushInterval() {
    return this._flushInterval;
  }
  async initDB() {
    if (this.db) return this.db;
    if (this._initPromise) return this._initPromise;
    this._initPromise = new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 2);
      request.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains(IndexerStore.MATCHING_TRANSACTIONS)) {
          const store = db.createObjectStore(
            IndexerStore.MATCHING_TRANSACTIONS,
            { keyPath: "txid" }
          );
          store.createIndex("timestamp", "timestamp");
        }
        if (!db.objectStoreNames.contains(IndexerStore.TRANSACTIONS)) {
          const txStore = db.createObjectStore(IndexerStore.TRANSACTIONS, {
            keyPath: "txid"
          });
          txStore.createIndex("timestamp", "timestamp");
        }
        if (!db.objectStoreNames.contains(IndexerStore.BLOCKS)) {
          const blockStore = db.createObjectStore(IndexerStore.BLOCKS, {
            keyPath: "hash"
          });
          blockStore.createIndex("timestamp", "timestamp");
        }
      };
      request.onsuccess = async (e) => {
        this.db = e.target.result;
        await this._preloadTxidCache();
        if (this._resolveDbReady) this._resolveDbReady();
        resolve(this.db);
      };
      request.onerror = (e) => reject(e);
      request.onblocked = () => reject(new Error("IndexedDB open blocked (another tab/connection?)"));
    });
    return this._initPromise;
  }
  /**
   * Reset both IndexedDB stores and all in-memory buffers/metrics.
   * Note: the DB connection must be open before clearing stores.
   * @returns {Promise<void>}
   */
  async resetEverything() {
    await this.initDB();
    this.active = false;
    this._stopEvictionTimer();
    this._stopFlushTimer();
    for (const storeName of Object.values(IndexerStore)) {
      await this.clearStore(storeName);
    }
    this._pendingTxs = [];
    this._pendingBlocks = [];
    this._txidCacheSet.clear();
    this._txidCacheQueue = [];
    this._metrics = {
      transactionsIndexed: 0,
      blocksIndexed: 0,
      evictions: { ttl: 0, size: 0 },
      cacheHits: 0,
      cacheMisses: 0
    };
  }
  /**
   * Fresh-start sequence:
   * 1) Init DB (must be open to clear)
   * 2) Reset everything (DB + memory)
   * 3) Start normal indexing
   * @returns {Promise<void>}
   */
  async freshStart() {
    await this.initDB();
    await this.resetEverything();
    this.start();
  }
  start() {
    this.active = true;
    this._startEvictionTimer();
    this._startFlushTimer();
  }
  stop() {
    this.active = false;
    this._stopEvictionTimer();
    this._stopFlushTimer();
    this.flush();
  }
  /* Indexing methods */
  /**
   * Add a transaction to the indexer.
   * @param {Object} tx - The transaction object to index.
   * @param {boolean} isMatch - Whether this transaction is a matching transaction.
   * @returns {Promise<void>}
   */
  async addTransaction(tx, isMatch = true) {
    if (tx && typeof tx.free === "function") {
      throw new Error(
        `KaspaIndexer Error: Received raw WASM transaction (txid: ${tx.verboseData?.transactionId}). Transactions must be dehydrated using utilities.dehydrateTx() before indexing to ensure memory safety and storage compatibility.`
      );
    }
    if (this.matchMode === MatchMode.BLOCKS) return;
    if (this.matchMode === MatchMode.MATCHING && !isMatch) return;
    if (this.matchMode === MatchMode.TRANSACTIONS && isMatch) return;
    if (this.matchMode === MatchMode.CUSTOM) {
      if (!this.indexAllTransactions && !this.indexAllMatchingTransactions)
        return;
      if (!this.indexAllTransactions && !isMatch) return;
      if (!this.indexAllMatchingTransactions && isMatch) return;
    }
    const now2 = Number(tx.timestamp);
    const txid = tx.txid;
    if (!txid) {
      this._metrics.cacheMisses++;
      return;
    }
    if (this._txidCacheSet.has(txid)) {
      this._metrics.cacheHits++;
      return;
    }
    this._txidCacheSet.add(txid);
    this._txidCacheQueue.push(txid);
    if (this._txidCacheQueue.length > this._txidCacheMax) {
      const oldest = this._txidCacheQueue.shift();
      this._txidCacheSet.delete(oldest);
    }
    const entry = { ...tx, timestamp: now2 };
    this._pendingTxs.push({ entry, isMatch });
    if (this._inMemoryMaxTxs && this._inMemoryMaxTxs > 0) {
      this._pruneInMemoryBuffer(
        this._pendingTxs,
        this._inMemoryMaxTxs,
        EvictionReason.IN_MEMORY_TRANSACTION,
        IndexerStore.TRANSACTIONS,
        "txid"
      );
    }
    if (typeof this.onIndexerUpdate === "function") {
      if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.TRANSACTIONS || this.matchMode === MatchMode.CUSTOM && this.indexAllTransactions) {
        this.onIndexerUpdate({
          type: IndexerEventType.TRANSACTION_IN_MEMORY,
          data: entry
        });
      }
      if (isMatch && (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.MATCHING || this.matchMode === MatchMode.CUSTOM && this.indexAllMatchingTransactions)) {
        this.onIndexerUpdate({
          type: IndexerEventType.MATCHING_TRANSACTION_IN_MEMORY,
          data: entry
        });
      }
    }
    this._metrics.transactionsIndexed++;
    if (this._pendingTxs.length >= this._inMemoryMaxTxs) {
      await this.flush();
    }
  }
  /**
   * Add a batch of transactions to the indexer.
   * @param {Object[]} txs - Array of transaction objects to index.
   * @param {boolean} isMatch - Whether these transactions are matching transactions.
   * @returns {Promise<void>}
   */
  async addTransactionsBatch(txs, isMatch = true) {
    for (const tx of txs) {
      await this.addTransaction(tx, isMatch);
    }
  }
  /**
   * Add a block to the indexer.
   * @param {Object} block - The block object to index.
   * @returns {Promise<void>}
   */
  async addBlock(block) {
    if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.BLOCKS || this.matchMode === MatchMode.CUSTOM && this.indexAllBlocks) {
      const now2 = Number(block.header?.timestamp ?? block.timestamp);
      const hash = block.header?.hash || block.hash;
      if (!hash) {
        log7.error("Block has no hash, cannot index.", block);
        return;
      }
      const txCount = Number(
        block.txCount ?? block.header?.transactionCount ?? block.header?.txCount ?? (Array.isArray(block.transactions) ? block.transactions.length : 0)
      );
      const blockEntry = { ...block, timestamp: now2, hash, txCount };
      this._pendingBlocks.push(blockEntry);
      if (this._inMemoryMaxBlocks && this._inMemoryMaxBlocks > 0) {
        this._pruneInMemoryBuffer(
          this._pendingBlocks,
          this._inMemoryMaxBlocks,
          EvictionReason.IN_MEMORY_BLOCK,
          IndexerStore.BLOCKS,
          "hash"
        );
      }
      this._metrics.blocksIndexed++;
      if (typeof this.onIndexerUpdate === "function") {
        if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.BLOCKS || this.matchMode === MatchMode.CUSTOM && this.indexAllBlocks) {
          this.onIndexerUpdate({
            type: IndexerEventType.BLOCK_IN_MEMORY,
            data: blockEntry
          });
        }
      }
      if (this._pendingBlocks.length >= this._inMemoryMaxBlocks) {
        await this.flush();
      }
    }
  }
  /**
   * Flush pending transactions and blocks to IndexedDB.
   * @returns {Promise<void>}
   */
  async flush() {
    if (this._flushPromise) return this._flushPromise;
    this._flushPromise = (async () => {
      await this._dbReady;
      if (this._inMemoryMaxTxs && this._inMemoryMaxTxs > 0) {
        this._pruneInMemoryBuffer(
          this._pendingTxs,
          this._inMemoryMaxTxs,
          EvictionReason.IN_MEMORY_TRANSACTION,
          IndexerStore.TRANSACTIONS,
          "txid"
        );
      }
      if (this._inMemoryMaxBlocks && this._inMemoryMaxBlocks > 0) {
        this._pruneInMemoryBuffer(
          this._pendingBlocks,
          this._inMemoryMaxBlocks,
          EvictionReason.IN_MEMORY_BLOCK,
          IndexerStore.BLOCKS,
          "hash"
        );
      }
      const batchTxs = [];
      const batchMatchingTxs = [];
      const batchBlocks = [];
      const txPromises = [];
      if (this._pendingTxs.length) {
        const txReqMatching = this.db.transaction(
          IndexerStore.MATCHING_TRANSACTIONS,
          "readwrite"
        );
        const storeMatching = txReqMatching.objectStore(
          IndexerStore.MATCHING_TRANSACTIONS
        );
        const txReqAll = this.db.transaction(
          IndexerStore.TRANSACTIONS,
          "readwrite"
        );
        const storeAll = txReqAll.objectStore(IndexerStore.TRANSACTIONS);
        for (const { entry, isMatch } of this._pendingTxs) {
          if (isMatch) storeMatching.put(entry);
          else storeAll.put(entry);
          if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.TRANSACTIONS || this.matchMode === MatchMode.CUSTOM && this.indexAllTransactions) {
            batchTxs.push(entry);
          }
          if (isMatch && (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.MATCHING || this.matchMode === MatchMode.CUSTOM && this.indexAllMatchingTransactions)) {
            batchMatchingTxs.push(entry);
          }
        }
        this._pendingTxs = [];
        txPromises.push(this._awaitIDBTransaction(txReqMatching));
        txPromises.push(this._awaitIDBTransaction(txReqAll));
      }
      if (this._pendingBlocks.length) {
        const blockReq = this.db.transaction(IndexerStore.BLOCKS, "readwrite");
        const store = blockReq.objectStore(IndexerStore.BLOCKS);
        for (const blockEntry of this._pendingBlocks) {
          store.put(blockEntry);
          if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.BLOCKS || this.matchMode === MatchMode.CUSTOM && this.indexAllBlocks) {
            batchBlocks.push(blockEntry);
          }
        }
        this._pendingBlocks = [];
        txPromises.push(this._awaitIDBTransaction(blockReq));
      }
      if (txPromises.length) await Promise.all(txPromises);
      if (typeof this.onIndexerUpdate === "function") {
        if (batchTxs.length > 0) {
          this.onIndexerUpdate({
            type: IndexerEventType.TRANSACTION_CACHED,
            data: batchTxs
          });
        }
        if (batchMatchingTxs.length > 0) {
          this.onIndexerUpdate({
            type: IndexerEventType.MATCHING_TRANSACTION_CACHED,
            data: batchMatchingTxs
          });
        }
        if (batchBlocks.length > 0) {
          this.onIndexerUpdate({
            type: IndexerEventType.BLOCK_CACHED,
            data: batchBlocks
          });
        }
      }
      await this._enforceMaxSizeAfterFlush();
      if (typeof this.onIndexerUpdate === "function") {
        this.onIndexerUpdate({
          type: IndexerEventType.FLUSH_COMPLETED,
          data: { ts: Date.now() }
        });
      }
    })();
    try {
      await this._flushPromise;
    } finally {
      this._flushPromise = null;
    }
  }
  /**
   * Evict old entries based on TTL and max size.
   * @returns {Promise<void>}
   */
  async evict() {
    if (this._evictPromise) return this._evictPromise;
    this._evictPromise = (async () => {
      await this._dbReady;
      const now2 = Date.now();
      if (!this.priorityTTL && this.maxSize && this.maxSize > 0) {
        const over = await this._isAnyRelevantStoreOverMaxSize();
        if (!over) return;
      }
      const stdOnEvict = /* @__PURE__ */ __name((storeName) => (evictInfo) => {
        if (this.onIndexerUpdate) {
          this.onIndexerUpdate({
            type: IndexerEventType.EVICT,
            data: {
              key: evictInfo.key,
              reason: evictInfo.reason,
              storeName
            }
          });
        }
      }, "stdOnEvict");
      if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.MATCHING) {
        await this._evictStore(
          IndexerStore.MATCHING_TRANSACTIONS,
          "txid",
          stdOnEvict(IndexerStore.MATCHING_TRANSACTIONS),
          now2
        );
      }
      if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.TRANSACTIONS) {
        await this._evictStore(
          IndexerStore.TRANSACTIONS,
          "txid",
          stdOnEvict(IndexerStore.TRANSACTIONS),
          now2
        );
      }
      if (this.matchMode === MatchMode.ALL || this.matchMode === MatchMode.BLOCKS) {
        await this._evictStore(
          IndexerStore.BLOCKS,
          "hash",
          stdOnEvict(IndexerStore.BLOCKS),
          now2
        );
      }
      if (this.matchMode === MatchMode.CUSTOM) {
        if (this.indexAllMatchingTransactions) {
          await this._evictStore(
            IndexerStore.MATCHING_TRANSACTIONS,
            "txid",
            stdOnEvict(IndexerStore.MATCHING_TRANSACTIONS),
            now2
          );
        }
        if (this.indexAllTransactions) {
          await this._evictStore(
            IndexerStore.TRANSACTIONS,
            "txid",
            stdOnEvict(IndexerStore.TRANSACTIONS),
            now2
          );
        }
        if (this.indexAllBlocks) {
          await this._evictStore(
            IndexerStore.BLOCKS,
            "hash",
            stdOnEvict(IndexerStore.BLOCKS),
            now2
          );
        }
      }
      if (typeof this.onIndexerUpdate === "function") {
        this.onIndexerUpdate({
          type: IndexerEventType.EVICT_CYCLE_COMPLETED,
          data: { ts: Date.now() }
        });
      }
    })();
    try {
      await this._evictPromise;
    } finally {
      this._evictPromise = null;
    }
  }
  /**
   * Clear all entries from a specific object store.
   * @param {string} storeName - The name of the store (use IndexerStore constant).
   * @returns {Promise<void>}
   */
  async clearStore(storeName) {
    if (!this.db) {
      await this.initDB();
    }
    await this._dbReady;
    if (!Object.values(IndexerStore).includes(storeName)) {
      throw new Error(`Invalid storeName: ${storeName}`);
    }
    return new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction(storeName, "readwrite");
        const store = tx.objectStore(storeName);
        store.clear();
        tx.oncomplete = () => {
          if (this._metrics) {
            this._metrics.storesCleared = (this._metrics.storesCleared || 0) + 1;
            this._metrics.clearsByStore = this._metrics.clearsByStore || {};
            this._metrics.clearsByStore[storeName] = (this._metrics.clearsByStore[storeName] || 0) + 1;
          }
          resolve();
        };
        tx.onerror = (e) => {
          log7.error(
            `IndexedDB clear failed for store ${storeName}:`,
            e.target.error
          );
          reject(e.target.error);
        };
        tx.onabort = (e) => {
          log7.error(
            `IndexedDB transaction aborted for store ${storeName}:`,
            e.target.error
          );
          reject(e.target.error);
        };
      } catch (err) {
        log7.error(`IndexedDB clear failed for store ${storeName}:`, err);
        reject(err);
      }
    });
  }
  /**
   * Get a snapshot of current metrics.
   * @returns {Object}
   */
  getMetrics() {
    return { ...this._metrics, evictions: { ...this._metrics.evictions } };
  }
  /* In-memory Getters */
  /**
   * Get matching transactions in memory.
   * @returns {Object[]}
   */
  getAllMatchingTransactions() {
    return this._pendingTxs.filter(({ isMatch }) => isMatch).map(({ entry }) => entry);
  }
  /**
   * Get all transactions in memory.
   * @returns {Object[]}
   */
  getAllTransactions() {
    return this._pendingTxs.map(({ entry }) => entry);
  }
  /** Get all blocks in memory.
   * @returns {Object[]}
   */
  getAllBlocks() {
    return this._pendingBlocks.slice();
  }
  /**
   * Get a transaction by its txid from in-memory buffer.
   * @param {string} txid - The transaction ID.
   * @returns {Object|null} - The matching transaction or null.
   */
  getTransaction(txid) {
    const match = this._pendingTxs.find(({ entry }) => entry.txid === txid);
    return match ? match.entry : null;
  }
  /* IndexedDB Getters */
  /**
   * Get a transaction by its txid.
   * @param {string} txid - The transaction ID.
   * @returns {Promise<Object|null>} - The matching transaction or null.
   */
  async getCachedTransaction(txid) {
    return this._queryStore(
      IndexerStore.MATCHING_TRANSACTIONS,
      (txs) => txs.find((tx) => tx.txid === txid) || null
    );
  }
  /**
   * Get all matching indexed transactions.
   * @returns {Promise<Object[]>} - Array of all transactions.
   */
  async getAllCachedMatchingTransactions() {
    return this._getRecentFromStore(
      IndexerStore.MATCHING_TRANSACTIONS,
      this._defaultQueryLimit
    );
  }
  /**
   * Get all indexed transactions.
   * @returns {Promise<Object[]>} - Array of all blocks.
   */
  async getAllCachedTransactions() {
    return this._getRecentFromStore(
      IndexerStore.TRANSACTIONS,
      this._defaultQueryLimit
    );
  }
  /**
   * Get all indexed blocks.
   * @returns {Promise<Object[]>} - Array of all blocks.
   */
  async getAllCachedBlocks() {
    return this._getRecentFromStore(IndexerStore.BLOCKS, this._defaultQueryLimit);
  }
  /**
   * Get the most recent transaction matching the given criteria.
   * @param {string} sender - Sender address.
   * @param {string} receiver - Receiver address.
   * @param {number} blockDaaScore - Block DAA score.
   * @param {bigint} amount - Amount transferred.
   * @returns {Promise<Object|null>} - The most recent matching transaction or null.
   */
  async getMostRecentCachedTransaction(sender, receiver, blockDaaScore, amount) {
    return this._queryStore(IndexerStore.MATCHING_TRANSACTIONS, (txs) => {
      const matches = txs.filter(
        (tx) => tx.sender === sender && tx.receiver === receiver && tx.blockDaaScore === blockDaaScore && tx.amount === amount
      ).sort((a, b) => b.timestamp - a.timestamp);
      return matches[0] || null;
    });
  }
  /**
   * Get transactions with a Block DAA score greater than the specified minimum.
   * @param {number} minBlockDaaScore - The minimum Block DAA score.
   * @returns {Promise<Object[]>} - Array of matching transactions.
   */
  async getCachedTransactionsAfterBlockDaaScore(minBlockDaaScore) {
    return this._queryStore(
      IndexerStore.MATCHING_TRANSACTIONS,
      (txs) => txs.filter((tx) => tx.blockDaaScore > minBlockDaaScore)
    );
  }
  /**
   * Get transactions for a specific address, optionally within a recent time frame.
   * @param {string} address - The address to query.
   * @param {number|null} [recentSeconds=null] - If provided, only transactions within this many seconds from now are returned.
   * @returns {Promise<Object[]>} - Array of matching transactions.
   */
  async getCachedTransactionsForAddress(address, recentSeconds = null, limit = this._defaultQueryLimit) {
    await this._dbReady;
    const now2 = Date.now();
    const cutoff = recentSeconds ? now2 - recentSeconds * 1e3 : null;
    const max = limit == null ? this._defaultQueryLimit : limit;
    return new Promise((resolve) => {
      const out = [];
      try {
        const tx = this.db.transaction(
          IndexerStore.MATCHING_TRANSACTIONS,
          "readonly"
        );
        const store = tx.objectStore(IndexerStore.MATCHING_TRANSACTIONS);
        const index = store.index("timestamp");
        const req = index.openCursor(null, "prev");
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (!cursor) {
            resolve(out);
            return;
          }
          const entry = cursor.value;
          if (cutoff && entry.timestamp < cutoff) {
            resolve(out);
            return;
          }
          if (entry.sender === address || entry.receiver === address) {
            out.push(entry);
            if (out.length >= max) {
              resolve(out);
              return;
            }
          }
          cursor.continue();
        };
        req.onerror = () => resolve(out);
        tx.onabort = () => resolve(out);
        tx.onerror = () => resolve(out);
      } catch {
        resolve(out);
      }
    });
  }
  /* Internal helpers */
  _startEvictionTimer() {
    if (this._evictionInterval) clearInterval(this._evictionInterval);
    const interval = this.ttlMs && this.ttlMs > 0 ? this.ttlMs : 6e5;
    this._evictionInterval = setInterval(() => {
      this.evict();
    }, interval);
  }
  _startFlushTimer() {
    if (this._flushTimer) clearInterval(this._flushTimer);
    this._flushTimer = setInterval(() => this.flush(), this._flushInterval);
  }
  _stopEvictionTimer() {
    if (this._evictionInterval) {
      clearInterval(this._evictionInterval);
      this._evictionInterval = null;
    }
  }
  _stopFlushTimer() {
    if (this._flushTimer) {
      clearInterval(this._flushTimer);
      this._flushTimer = null;
    }
  }
  /**
   * (Internal) Preload recent txids into in-memory cache for deduplication.
   */
  async _preloadTxidCache() {
    const loadRecentKeysByTimestamp = /* @__PURE__ */ __name(async (storeName, max) => {
      return new Promise((resolve) => {
        try {
          const txReq = this.db.transaction(storeName, "readonly");
          const store = txReq.objectStore(storeName);
          const index = store.index("timestamp");
          const keys = [];
          const cursorReq = index.openCursor(null, "prev");
          cursorReq.onsuccess = (e) => {
            const cursor = e.target.result;
            if (!cursor || keys.length >= max) {
              resolve(keys);
              return;
            }
            keys.push(cursor.primaryKey);
            cursor.continue();
          };
          cursorReq.onerror = () => resolve(keys);
          txReq.onerror = () => resolve(keys);
          txReq.onabort = () => resolve(keys);
        } catch (err) {
          resolve([]);
        }
      });
    }, "loadRecentKeysByTimestamp");
    const [recentAll, recentMatching] = await Promise.all([
      loadRecentKeysByTimestamp(IndexerStore.TRANSACTIONS, this._txidCacheMax),
      loadRecentKeysByTimestamp(
        IndexerStore.MATCHING_TRANSACTIONS,
        this._txidCacheMax
      )
    ]);
    const combined = [...recentAll, ...recentMatching];
    this._txidCacheSet = /* @__PURE__ */ new Set();
    this._txidCacheQueue = [];
    for (const key of combined) {
      if (!key || this._txidCacheSet.has(key)) continue;
      this._txidCacheSet.add(key);
      this._txidCacheQueue.push(key);
      if (this._txidCacheQueue.length >= this._txidCacheMax) break;
    }
  }
  /**
   * (Internal) Generic helper to query any object store.
   * @param {string} storeName - The name of the object store.
   * @param {function(Object[]): any} processFn - Function to process the full result set.
   * @returns {Promise<any>}
   */
  async _queryStore(storeName, processFn) {
    return new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const req = store.getAll();
        const finalize = /* @__PURE__ */ __name((fn) => {
          try {
            resolve(fn());
          } catch (err) {
            reject(err);
          }
        }, "finalize");
        req.onsuccess = () => finalize(() => processFn(req.result || []));
        req.onerror = () => reject(req.error || new Error("IndexedDB getAll() failed"));
        tx.onabort = () => reject(tx.error || new Error("IndexedDB transaction aborted"));
        tx.onerror = () => reject(tx.error || new Error("IndexedDB transaction error"));
      } catch (err) {
        reject(err);
      }
    });
  }
  /**
   * (Internal) Read most-recent items using the "timestamp" index without loading the whole store.
   */
  async _getRecentFromStore(storeName, limit = this._defaultQueryLimit) {
    await this._dbReady;
    return new Promise((resolve) => {
      const out = [];
      try {
        const tx = this.db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const index = store.index("timestamp");
        const req = index.openCursor(null, "prev");
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (!cursor || out.length >= limit) {
            resolve(out);
            return;
          }
          out.push(cursor.value);
          cursor.continue();
        };
        req.onerror = () => resolve(out);
        tx.onabort = () => resolve(out);
        tx.onerror = () => resolve(out);
      } catch {
        resolve(out);
      }
    });
  }
  /**
   * (Internal) Helper to prune in-memory buffer to max size.
   * @param {Array} buffer - The in-memory buffer array.
   * @param {number} max - The maximum allowed size.
   * @param {string} evictionReason - Reason for eviction.
   * @param {string} storeName - Name of the store.
   * @param {string} keyField - Key field name.
   */
  _pruneInMemoryBuffer(buffer, max, evictionReason, storeName, keyField) {
    while (buffer.length > max) {
      const removed = buffer.shift();
      if (this.onIndexerUpdate && removed) {
        this.onIndexerUpdate({
          type: IndexerEventType.EVICT,
          data: {
            key: removed.entry ? removed.entry[keyField] : removed[keyField],
            reason: evictionReason,
            storeName
          }
        });
      }
    }
  }
  _awaitIDBTransaction(tx) {
    return new Promise((resolve, reject) => {
      tx.oncomplete = () => resolve();
      tx.onabort = () => reject(tx.error || new Error("IndexedDB transaction aborted"));
      tx.onerror = () => reject(tx.error || new Error("IndexedDB transaction error"));
    });
  }
  _getRelevantStoresForCurrentMode() {
    if (this.matchMode === MatchMode.ALL) {
      return [
        { name: IndexerStore.MATCHING_TRANSACTIONS, keyField: "txid" },
        { name: IndexerStore.TRANSACTIONS, keyField: "txid" },
        { name: IndexerStore.BLOCKS, keyField: "hash" }
      ];
    }
    if (this.matchMode === MatchMode.MATCHING) {
      return [{ name: IndexerStore.MATCHING_TRANSACTIONS, keyField: "txid" }];
    }
    if (this.matchMode === MatchMode.TRANSACTIONS) {
      return [{ name: IndexerStore.TRANSACTIONS, keyField: "txid" }];
    }
    if (this.matchMode === MatchMode.BLOCKS) {
      return [{ name: IndexerStore.BLOCKS, keyField: "hash" }];
    }
    if (this.matchMode === MatchMode.CUSTOM) {
      const stores = [];
      if (this.indexAllMatchingTransactions)
        stores.push({
          name: IndexerStore.MATCHING_TRANSACTIONS,
          keyField: "txid"
        });
      if (this.indexAllTransactions)
        stores.push({ name: IndexerStore.TRANSACTIONS, keyField: "txid" });
      if (this.indexAllBlocks)
        stores.push({ name: IndexerStore.BLOCKS, keyField: "hash" });
      return stores;
    }
    return [];
  }
  async _countStore(storeName) {
    await this._dbReady;
    return new Promise((resolve) => {
      try {
        const tx = this.db.transaction(storeName, "readonly");
        const store = tx.objectStore(storeName);
        const req = store.count();
        req.onsuccess = () => resolve(req.result || 0);
        req.onerror = () => resolve(0);
      } catch {
        resolve(0);
      }
    });
  }
  async _isAnyRelevantStoreOverMaxSize() {
    if (!this.maxSize || this.maxSize <= 0) return false;
    const stores = this._getRelevantStoresForCurrentMode();
    for (const { name } of stores) {
      const count = await this._countStore(name);
      if (count > this.maxSize) return true;
    }
    return false;
  }
  async _enforceMaxSizeAfterFlush() {
    if (!this.maxSize || this.maxSize <= 0) return;
    const now2 = Date.now();
    const stdOnEvict = /* @__PURE__ */ __name((storeName) => (evictInfo) => {
      if (this.onIndexerUpdate) {
        this.onIndexerUpdate({
          type: IndexerEventType.EVICT,
          data: { key: evictInfo.key, reason: evictInfo.reason, storeName }
        });
      }
    }, "stdOnEvict");
    const stores = this._getRelevantStoresForCurrentMode();
    for (const { name, keyField } of stores) {
      await this._evictStoreBySizeOnly(name, keyField, stdOnEvict(name), now2);
    }
  }
  async _evictStoreBySizeOnly(storeName, keyField, onEvict, now2) {
    await this._dbReady;
    if (!this.maxSize || this.maxSize <= 0) return;
    const txReq = this.db.transaction(storeName, "readwrite");
    const store = txReq.objectStore(storeName);
    const removeFromCache = /* @__PURE__ */ __name((key) => {
      if (this._txidCacheSet.has(key)) {
        this._txidCacheSet.delete(key);
        const idx = this._txidCacheQueue.indexOf(key);
        if (idx !== -1) this._txidCacheQueue.splice(idx, 1);
      }
    }, "removeFromCache");
    const onEvictAndRemove = /* @__PURE__ */ __name((evictInfo) => {
      removeFromCache(evictInfo.key);
      if (onEvict) onEvict(evictInfo);
    }, "onEvictAndRemove");
    await this._evictBySize(
      store,
      keyField,
      this.maxSize,
      onEvictAndRemove,
      now2
    );
    await this._awaitIDBTransaction(txReq);
  }
  /**
   * Prune an IndexedDB store by TTL and/or max size.
   * @param {string} storeName - The name of the store (use IndexerStore constant).
   * @param {string} keyField - The key field name (e.g., "txid" or "hash").
   * @param {function} onEvict - Callback for each evicted item.
   * @returns {Promise<void>}
   */
  async _pruneIndexedDBStore(storeName, keyField, onEvict) {
    await this._dbReady;
    const now2 = Date.now();
    const storeTx = this.db.transaction(storeName, "readwrite");
    const store = storeTx.objectStore(storeName);
    if (this.priorityTTL) {
      if (this.ttlMs)
        await this._evictByTTL(store, keyField, now2, this.ttlMs, onEvict);
      if (this.maxSize)
        await this._evictBySize(store, keyField, this.maxSize, onEvict, now2);
    } else {
      if (this.maxSize)
        await this._evictBySize(store, keyField, this.maxSize, onEvict, now2);
      if (this.ttlMs)
        await this._evictByTTL(store, keyField, now2, this.ttlMs, onEvict);
    }
    await this._awaitIDBTransaction(storeTx);
  }
  /**
   * (Internal) Helper to evict from a given store, enforcing eviction priority.
   */
  async _evictStore(storeName, keyField, onEvict, now2) {
    await this._dbReady;
    const txReq = this.db.transaction(storeName, "readwrite");
    const store = txReq.objectStore(storeName);
    const removeFromCache = /* @__PURE__ */ __name((key) => {
      if (this._txidCacheSet.has(key)) {
        this._txidCacheSet.delete(key);
        const idx = this._txidCacheQueue.indexOf(key);
        if (idx !== -1) this._txidCacheQueue.splice(idx, 1);
      }
    }, "removeFromCache");
    const onEvictAndRemove = /* @__PURE__ */ __name((evictInfo) => {
      removeFromCache(evictInfo.key);
      if (onEvict) onEvict(evictInfo);
    }, "onEvictAndRemove");
    if (this.priorityTTL) {
      if (this.ttlMs)
        await this._evictByTTL(
          store,
          keyField,
          now2,
          this.ttlMs,
          onEvictAndRemove
        );
      if (this.maxSize)
        await this._evictBySize(
          store,
          keyField,
          this.maxSize,
          onEvictAndRemove,
          now2
        );
    } else {
      if (this.maxSize)
        await this._evictBySize(
          store,
          keyField,
          this.maxSize,
          onEvictAndRemove,
          now2
        );
      if (this.ttlMs)
        await this._evictByTTL(
          store,
          keyField,
          now2,
          this.ttlMs,
          onEvictAndRemove
        );
    }
    await this._awaitIDBTransaction(txReq);
  }
  /**
   * (Internal) Evict items from a store by TTL.
   */
  async _evictByTTL(store, keyField, now2, ttlMs, onEvict) {
    const cutoff = now2 - ttlMs;
    const index = store.index("timestamp");
    const range = IDBKeyRange.upperBound(cutoff);
    const totalCount = await new Promise((resolve) => {
      const req = store.count();
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => resolve(0);
    });
    const expiredCount = await new Promise((resolve) => {
      let count = 0;
      const req = index.openCursor(range);
      req.onsuccess = (e) => {
        const cursor = e.target.result;
        if (cursor) {
          count++;
          cursor.continue();
        } else {
          resolve(count);
        }
      };
      req.onerror = () => resolve(0);
    });
    const batchThreshold = Math.floor(totalCount * this.batchThresholdRatio);
    if (expiredCount >= batchThreshold) {
      await new Promise((resolve) => {
        const req = index.openCursor(range);
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (cursor) {
            const entry = cursor.value;
            if (entry.timestamp <= cutoff) {
              const delReq = store.delete(cursor.primaryKey);
              delReq.onerror = (err) => {
                log7.error(
                  "IndexedDB delete failed (TTL eviction):",
                  err.target.error
                );
              };
              if (onEvict)
                onEvict({ key: cursor.primaryKey, reason: EvictionReason.TTL });
              this._metrics.evictions.ttl++;
            }
            cursor.continue();
          } else {
            resolve();
          }
        };
        req.onerror = (e) => {
          log7.error(
            "IndexedDB openCursor failed (TTL eviction):",
            e.target.error
          );
          resolve();
        };
      });
    }
  }
  /**
   * (Internal) Evict items from a store by max size.
   */
  async _evictBySize(store, keyField, maxSize, onEvict, now2) {
    if (!maxSize || maxSize <= 0) return;
    const total = await new Promise((resolve) => {
      const req = store.count();
      req.onsuccess = () => resolve(req.result || 0);
      req.onerror = (e) => {
        log7.error(
          "IndexedDB count failed (Size eviction):",
          e.target.error
        );
        resolve(0);
      };
    });
    if (total <= maxSize) return;
    const excess = total - maxSize;
    await new Promise((resolve) => {
      const index = store.index("timestamp");
      const cursorReq = index.openCursor();
      let deleted = 0;
      cursorReq.onerror = (err) => {
        log7.error(
          "IndexedDB openCursor failed (Size eviction):",
          err.target.error
        );
        resolve();
      };
      cursorReq.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (!cursor || deleted >= excess) {
          resolve();
          return;
        }
        const delReq = store.delete(cursor.primaryKey);
        delReq.onerror = (err) => {
          log7.error(
            "IndexedDB delete failed (Size eviction):",
            err.target.error
          );
        };
        if (onEvict)
          onEvict({ key: cursor.primaryKey, reason: EvictionReason.SIZE });
        this._metrics.evictions.size++;
        deleted++;
        cursor.continue();
      };
    });
  }
};
__name(_KaspaIndexer, "KaspaIndexer");
var KaspaIndexer = _KaspaIndexer;

// kktp/engine/kaspa/intelligence/scanner.js
var log8 = Logger.create(LogModule.intelligence.scanner);
var BlockScannerEvent = Object.freeze({
  BLOCK_ADDED: "block-added"
});
var SearchMode = Object.freeze({
  INCLUDES: "includes",
  STARTS_WITH: "startsWith",
  EXACT: "exact",
  ENDS_WITH: "endsWith"
});
var _prefixes, _blockSubscribers, _matchSubscribers, _blockListener, _reconnectHandler, _lastBlockTime, _pendingBlockEnrichment;
var _KaspaBlockScanner = class _KaspaBlockScanner {
  constructor(client2, {
    prefixes = [],
    addresses = [],
    mode = SearchMode.INCLUDES,
    indexerOptions = {},
    onMatch = null,
    onBlock = null
  } = {}) {
    __privateAdd(this, _prefixes, /* @__PURE__ */ new Set());
    __privateAdd(this, _blockSubscribers, /* @__PURE__ */ new Set());
    __privateAdd(this, _matchSubscribers, /* @__PURE__ */ new Set());
    __privateAdd(this, _blockListener, null);
    __privateAdd(this, _reconnectHandler, null);
    __privateAdd(this, _lastBlockTime, null);
    __privateAdd(this, _pendingBlockEnrichment, /* @__PURE__ */ new Set());
    __publicField(this, "indexer", null);
    this.client = client2;
    this.scanning = false;
    if (typeof onBlock === "function") __privateGet(this, _blockSubscribers).add(onBlock);
    if (typeof onMatch === "function") __privateGet(this, _matchSubscribers).add(onMatch);
    if (Array.isArray(prefixes)) {
      prefixes.forEach((p) => this.addPrefix(p));
    } else if (prefixes) {
      this.addPrefix(prefixes);
    }
    this.addresses = Array.isArray(addresses) ? addresses : [];
    this.searchMode = Object.values(SearchMode).includes(mode) ? mode : SearchMode.INCLUDES;
    this.indexer = new KaspaIndexer(indexerOptions);
    this.indexer.initDB().then(() => {
      if (typeof indexerOptions.onIndexerUpdate === "function") {
        this.indexer.onIndexerUpdate = indexerOptions.onIndexerUpdate;
      }
    });
  }
  // --- Getters & Setters ---
  get prefixes() {
    return Array.from(__privateGet(this, _prefixes));
  }
  set prefixes(values) {
    __privateGet(this, _prefixes).clear();
    const arr = Array.isArray(values) ? values : [values];
    arr.forEach((v) => this.addPrefix(v));
  }
  addPrefix(prefix) {
    if (prefix) __privateGet(this, _prefixes).add(stringToHex(prefix));
  }
  addPrefixHex(prefixHex) {
    const normalized = normalizeHexPrefix(prefixHex);
    if (normalized) __privateGet(this, _prefixes).add(normalized);
  }
  removePrefix(prefix) {
    __privateGet(this, _prefixes).delete(stringToHex(prefix));
  }
  removePrefixHex(prefixHex) {
    const normalized = normalizeHexPrefix(prefixHex);
    if (normalized) __privateGet(this, _prefixes).delete(normalized);
  }
  addAddress(address) {
    if (!this.addresses.includes(address)) this.addresses.push(address);
  }
  removeAddress(address) {
    this.addresses = this.addresses.filter((a) => a !== address);
  }
  // --- Subscription API ---
  subscribeBlock(fn) {
    if (typeof fn !== "function") return () => {
    };
    __privateGet(this, _blockSubscribers).add(fn);
    return () => __privateGet(this, _blockSubscribers).delete(fn);
  }
  subscribeMatch(fn) {
    if (typeof fn !== "function") return () => {
    };
    __privateGet(this, _matchSubscribers).add(fn);
    return () => __privateGet(this, _matchSubscribers).delete(fn);
  }
  // --- Health & Status ---
  checkHealth() {
    if (!this.scanning) return true;
    if (!__privateGet(this, _lastBlockTime)) return false;
    return Date.now() - __privateGet(this, _lastBlockTime) <= 6e4;
  }
  get status() {
    return {
      scanning: this.scanning,
      matchSubscribers: __privateGet(this, _matchSubscribers).size,
      blockSubscribers: __privateGet(this, _blockSubscribers).size,
      prefixes: __privateGet(this, _prefixes).size,
      lastBlockTime: __privateGet(this, _lastBlockTime),
      health: this.checkHealth()
    };
  }
  async start(onBlock) {
    if (!this.client) throw new Error("Kaspa client required");
    if (this.scanning) return;
    this.scanning = true;
    __privateSet(this, _lastBlockTime, Date.now());
    if (onBlock && typeof onBlock === "function")
      __privateGet(this, _blockSubscribers).add(onBlock);
    const subscribeSafely = /* @__PURE__ */ __name(async () => {
      try {
        if (this.scanning) await this.client.subscribeBlockAdded();
      } catch (e) {
        log8.warn("Scanner: Subscription failed.");
      }
    }, "subscribeSafely");
    await subscribeSafely();
    if (!__privateGet(this, _reconnectHandler)) {
      __privateSet(this, _reconnectHandler, () => {
        if (this.scanning) subscribeSafely();
      });
      this.client.addEventListener("connect", __privateGet(this, _reconnectHandler));
    }
    __privateSet(this, _blockListener, (event) => {
      if (!this.scanning || !event?.data?.block) return;
      const rawBlock = event.data.block;
      __privateSet(this, _lastBlockTime, Date.now());
      const cleanBlock = dehydrateBlock(rawBlock);
      const shouldScanTXs = __privateGet(this, _prefixes).size > 0 || this.addresses.length > 0 || this.indexer?.active;
      let matches = [];
      let txCount = 0;
      if (shouldScanTXs) {
        txCount = this._processBlockTransactions(rawBlock, matches);
        cleanBlock.txCount = txCount;
      } else {
        cleanBlock.txCount = Number(rawBlock.header?.transactionCount || 0);
      }
      if (this.indexer?.active) {
        this.indexer.addBlock(cleanBlock);
      }
      for (const subscriber of __privateGet(this, _blockSubscribers)) {
        try {
          subscriber(cleanBlock, matches);
        } catch (err) {
          log8.error(err);
        }
      }
    });
    this.client.addEventListener(
      BlockScannerEvent.BLOCK_ADDED,
      __privateGet(this, _blockListener)
    );
  }
  _processBlockTransactions(rawBlock, matches) {
    const txs = rawBlock?.transactions;
    if (!txs) return null;
    const shouldMatch = __privateGet(this, _prefixes).size > 0 || this.addresses.length > 0;
    const indexerActive = !!this.indexer?.active;
    let txCount = 0;
    for (const tx of txs) {
      txCount++;
      try {
        if (shouldMatch) {
          const { matchObj, isMatch } = this._analyzeTransaction(tx, rawBlock);
          if (isMatch) {
            matches.push(matchObj);
            this._indexMatchingTransactionIfNeeded(matchObj);
            for (const subscriber of __privateGet(this, _matchSubscribers)) {
              try {
                subscriber(rawBlock, matchObj);
              } catch (err) {
              }
            }
          }
        }
        if (indexerActive) this._indexAllTransactionIfNeeded(tx, rawBlock);
      } finally {
        if (tx && typeof tx.free === "function") tx.free();
      }
    }
    return txCount;
  }
  _analyzeTransaction(tx, rawBlock) {
    const { payloadMatch, decodedPayload } = this._matchPayload(tx);
    const addressMatch = this._matchAddress(tx);
    const isMatch = payloadMatch || addressMatch;
    let matchObj = null;
    if (isMatch) {
      matchObj = this._buildMatchObject(
        tx,
        rawBlock,
        payloadMatch,
        addressMatch,
        decodedPayload
      );
    }
    return { matchObj, isMatch };
  }
  _matchPayload(tx) {
    const payloadHex = tx.payload;
    if (__privateGet(this, _prefixes).size === 0 || !payloadHex)
      return { payloadMatch: false, decodedPayload: null };
    const payloadLower = payloadHex.toLowerCase();
    let payloadMatch = false;
    for (const prefixHex of __privateGet(this, _prefixes)) {
      if (this.searchMode === SearchMode.INCLUDES)
        payloadMatch = payloadLower.includes(prefixHex);
      else if (this.searchMode === SearchMode.STARTS_WITH)
        payloadMatch = payloadLower.startsWith(prefixHex);
      else if (this.searchMode === SearchMode.EXACT)
        payloadMatch = payloadLower === prefixHex;
      else if (this.searchMode === SearchMode.ENDS_WITH)
        payloadMatch = payloadLower.endsWith(prefixHex);
      if (payloadMatch) break;
    }
    let decodedPayload = null;
    if (payloadMatch) {
      try {
        decodedPayload = hexToString(payloadHex);
      } catch (e) {
      }
    }
    return { payloadMatch, decodedPayload };
  }
  _matchAddress(tx) {
    if (this.addresses.length === 0) return false;
    if (Array.isArray(tx.outputs)) {
      for (const out of tx.outputs) {
        if (this.addresses.includes(out.verboseData?.scriptPublicKeyAddress))
          return true;
      }
    }
    if (Array.isArray(tx.inputs)) {
      for (const input of tx.inputs) {
        if (this.addresses.includes(input.previousOutpointAddress)) return true;
      }
    }
    return false;
  }
  _buildMatchObject(tx, rawBlock, payloadMatch, addressMatch, decodedPayload) {
    const dehydratedTx = dehydrateTx({ tx, block: rawBlock, decodedPayload });
    dehydratedTx.payloadMatch = payloadMatch;
    dehydratedTx.addressMatch = addressMatch;
    return dehydratedTx;
  }
  _indexMatchingTransactionIfNeeded(matchObj) {
    if (!this.indexer.active) return;
    const mode = this.indexer.matchMode;
    if (mode === MatchMode.ALL || mode === MatchMode.MATCHING || mode === MatchMode.CUSTOM && this.indexer.indexAllMatchingTransactions) {
      this.indexer.addTransaction(matchObj, true);
    }
  }
  _indexAllTransactionIfNeeded(tx, rawBlock) {
    if (!this.indexer.active) return;
    const mode = this.indexer.matchMode;
    if (mode === MatchMode.ALL || mode === MatchMode.TRANSACTIONS || mode === MatchMode.CUSTOM && this.indexer.indexAllTransactions) {
      const obj = this._buildMatchObject(tx, rawBlock, false, false, null);
      this.indexer.addTransaction(obj, false);
    }
  }
  _indexBlockIfNeeded(rawBlock, txCountOverride = null) {
    if (!this.indexer.active) return;
    const mode = this.indexer.matchMode;
    if (mode === MatchMode.ALL || mode === MatchMode.BLOCKS || mode === MatchMode.CUSTOM && this.indexer.indexAllBlocks) {
      const summary = dehydrateBlock(rawBlock);
      if (summary) {
        const headerCount = Number(
          rawBlock?.header?.transactionCount ?? rawBlock?.header?.txCount
        );
        summary.txCount = Number.isFinite(txCountOverride) ? txCountOverride : headerCount;
        this.indexer.addBlock(summary);
        if (summary.hash && (!summary.txCount || summary.txCount <= 0)) {
          this._enrichBlockTxCount(summary.hash);
        }
      }
    }
  }
  async _enrichBlockTxCount(hash) {
    if (!hash || __privateGet(this, _pendingBlockEnrichment).has(hash)) return;
    __privateGet(this, _pendingBlockEnrichment).add(hash);
    try {
      const full = await this._fetchBlockWithTransactions(hash);
      if (full?.transactions) {
        const summary = dehydrateBlock(full);
        summary.txCount = full.transactions.length;
        this.indexer.addBlock(summary);
      }
    } catch (err) {
    } finally {
      __privateGet(this, _pendingBlockEnrichment).delete(hash);
    }
  }
  async _fetchBlockWithTransactions(hash) {
    try {
      if (typeof this.client.getBlock === "function")
        return await this.client.getBlock({ hash, includeTransactions: true });
    } catch {
    }
    return null;
  }
  stop() {
    this.scanning = false;
    if (__privateGet(this, _blockListener)) {
      this.client.removeEventListener(
        BlockScannerEvent.BLOCK_ADDED,
        __privateGet(this, _blockListener)
      );
      __privateSet(this, _blockListener, null);
    }
    if (__privateGet(this, _reconnectHandler)) {
      this.client.removeEventListener("connect", __privateGet(this, _reconnectHandler));
      __privateSet(this, _reconnectHandler, null);
    }
    try {
      this.client.unsubscribeBlockAdded();
    } catch (e) {
    }
    __privateGet(this, _blockSubscribers).clear();
    __privateGet(this, _matchSubscribers).clear();
    __privateSet(this, _prefixes, /* @__PURE__ */ new Set());
    this.addresses = [];
  }
};
_prefixes = new WeakMap();
_blockSubscribers = new WeakMap();
_matchSubscribers = new WeakMap();
_blockListener = new WeakMap();
_reconnectHandler = new WeakMap();
_lastBlockTime = new WeakMap();
_pendingBlockEnrichment = new WeakMap();
__name(_KaspaBlockScanner, "KaspaBlockScanner");
var KaspaBlockScanner = _KaspaBlockScanner;
function normalizeHexPrefix(prefixHex) {
  if (!prefixHex) return null;
  if (typeof prefixHex !== "string") return null;
  const trimmed = prefixHex.trim();
  if (!trimmed) return null;
  const hex2 = trimmed.startsWith("0x") ? trimmed.slice(2) : trimmed;
  if (hex2.length === 0 || hex2.length % 2 !== 0) return null;
  if (!/^[0-9a-fA-F]+$/.test(hex2)) return null;
  return hex2.toLowerCase();
}
__name(normalizeHexPrefix, "normalizeHexPrefix");

// kktp/engine/kaspa/intelligence/intelligenceFacade.js
var log9 = Logger.create(LogModule.intelligence.intelligenceFacade);
var _IntelligenceFacade = class _IntelligenceFacade {
  /**
   * @param {Object} client - Kaspa RPC client
   * @param {Object} scannerOptions - { prefix, addresses, mode }
   * @param {Object} indexerOptions - { dbName, matchMode, onIndexerUpdate, ttlMinutes, etc. }
   */
  constructor(client2, scannerOptions = {}, indexerOptions = {}) {
    __publicField(this, "_handleIndexerUpdate", /* @__PURE__ */ __name((event) => {
      const { type, data } = event;
      switch (type) {
        case IndexerEventType.TRANSACTION_IN_MEMORY:
          this._trigger("onNewTransaction", data);
          break;
        case IndexerEventType.MATCHING_TRANSACTION_IN_MEMORY:
          this._trigger("onNewTransactionMatch", data);
          break;
        case IndexerEventType.BLOCK_IN_MEMORY:
          this._trigger("onNewBlock", data);
          break;
        case IndexerEventType.TRANSACTION_CACHED:
          this._trigger("onCachedTransaction", data);
          break;
        case IndexerEventType.MATCHING_TRANSACTION_CACHED:
          this._trigger("onCachedTransactionMatch", data);
          break;
        case IndexerEventType.BLOCK_CACHED:
          this._trigger("onCachedBlock", data);
          break;
        case IndexerEventType.FLUSH_COMPLETED:
          this._trigger("onFlushCompleted", data);
          break;
        case IndexerEventType.EVICT_CYCLE_COMPLETED:
          this._trigger("onEvictCycleCompleted", data);
          break;
        case IndexerEventType.EVICT:
          if (data?.reason === EvictionReason.TTL || data?.reason === EvictionReason.SIZE) {
            this._trigger("onCacheEvict", data);
          } else {
            this._trigger("onEvict", data);
          }
          break;
        default:
          log9.warn("IntelligenceFacade: Unknown event type:", type);
      }
    }, "_handleIndexerUpdate"));
    this.client = client2;
    this._subscribers = /* @__PURE__ */ new Map();
    const onIndexerUpdate = /* @__PURE__ */ __name((event) => {
      this._handleIndexerUpdate(event);
    }, "onIndexerUpdate");
    this.scanner = new KaspaBlockScanner(client2, {
      ...scannerOptions,
      indexerOptions: { ...indexerOptions, onIndexerUpdate }
    });
    this.indexer = this.scanner.indexer;
    this._activeTasks = new AbortController();
  }
  _trigger(name, data) {
    const subs = this._subscribers.get(name);
    if (!subs || subs.size === 0) return;
    for (const cb of subs) {
      try {
        cb(data);
      } catch (err) {
        log9.error(`IntelligenceFacade ${name} subscriber error`, err);
      }
    }
  }
  _getSubscriberSet(name) {
    if (!this._subscribers.has(name)) {
      this._subscribers.set(name, /* @__PURE__ */ new Set());
    }
    return this._subscribers.get(name);
  }
  _addSubscriber(name, cb) {
    if (typeof cb !== "function") return () => {
    };
    const set = this._getSubscriberSet(name);
    set.add(cb);
    return () => set.delete(cb);
  }
  onNewBlock(cb) {
    return this._addSubscriber("onNewBlock", cb);
  }
  onNewTransaction(cb) {
    return this._addSubscriber("onNewTransaction", cb);
  }
  onNewTransactionMatch(cb) {
    return this._addSubscriber("onNewTransactionMatch", cb);
  }
  onCachedBlock(cb) {
    return this._addSubscriber("onCachedBlock", cb);
  }
  onCachedTransaction(cb) {
    return this._addSubscriber("onCachedTransaction", cb);
  }
  onCachedTransactionMatch(cb) {
    return this._addSubscriber("onCachedTransactionMatch", cb);
  }
  onEvict(cb) {
    return this._addSubscriber("onEvict", cb);
  }
  onCacheEvict(cb) {
    return this._addSubscriber("onCacheEvict", cb);
  }
  async init() {
    await this.indexer.initDB();
  }
  /**
   * Starts the system.
   * The scanner will listen to the network, feed the indexer,
   * and the indexer will fire the 'onIndexerUpdate' events.
   */
  async start() {
    await this.indexer.initDB();
    this.indexer.start();
    await this.scanner.start();
  }
  getIndexerTimings() {
    return {
      ttlMs: this.indexer?.ttlMs ?? null,
      flushInterval: this.indexer?.flushInterval ?? null
    };
  }
  async startIndexer() {
    await this.init();
    this.indexer.start();
    return this.getIndexerTimings();
  }
  stopIndexer() {
    this.indexer.stop();
  }
  setSearchMode(mode) {
    if (this.scanner) this.scanner.searchMode = mode;
  }
  async startScanner(onBlock) {
    return this.scanner.start(onBlock);
  }
  stopScanner() {
    this.scanner.stop();
  }
  async getCachedSnapshot() {
    const [allTxs, matchingTxs, blocks] = await Promise.all([
      this.indexer.getAllCachedTransactions(),
      this.indexer.getAllCachedMatchingTransactions(),
      this.indexer.getAllCachedBlocks()
    ]);
    return { allTxs, matchingTxs, blocks };
  }
  getInMemorySnapshot() {
    return {
      allTxs: this.indexer.getAllTransactions(),
      matchingTxs: this.indexer.getAllMatchingTransactions(),
      blocks: this.indexer.getAllBlocks()
    };
  }
  async clearIndexerStore(storeName) {
    return this.indexer.clearStore(storeName);
  }
  /** Walk the DAG from startHash to endHash (or present).
   * @param {Object} options
   * @param {string} options.startHash - Block hash to start from
   * @param {string} [options.endHash] - Optional block hash to end at
   * @param {Array<string>} [options.prefixes] - Optional payload prefixes to match
   * @param {function} options.onMatch - Callback for each matching transaction
   * @param {number} [options.maxSeconds] - Max seconds to run (default 30)
   * @param {number} [options.minTimestamp] - Min timestamp to consider (default 0)
   * @param {function} [options.logFn] - Optional logging function
   * @returns {Promise<void>}
   */
  async walkDagRange(options) {
    return await walkDagRange({ client: this.client, ...options });
  }
  /**
   * Add an address to the watch list
   * @param {string} address - Kaspa address to watch
   */
  addAddress(address) {
    this.scanner?.addAddress(address);
  }
  /** Remove an address from the watch list
   * @param {string} address - Kaspa address to remove
   */
  removeAddress(address) {
    this.scanner?.removeAddress(address);
  }
  /** Set the list of addresses to watch
   * @param {Array<string>|string} addresses - Array of addresses or single address
   */
  setAddresses(addresses) {
    if (!this.scanner) return;
    if (Array.isArray(this.scanner.addresses)) {
      for (const addr of [...this.scanner.addresses]) {
        this.scanner.removeAddress(addr);
      }
    }
    const addrs = Array.isArray(addresses) ? addresses : [addresses];
    for (const addr of addrs) {
      this.scanner.addAddress(addr);
    }
  }
  /** Add a payload prefix to the watch list
   * @param {string} prefix - Payload prefix to add
   */
  addPrefix(prefix) {
    this.scanner?.addPrefix(prefix);
  }
  /** Add a hex payload prefix to the watch list
   * @param {string} prefixHex - Hex prefix to add
   */
  addPrefixHex(prefixHex) {
    this.scanner?.addPrefixHex?.(prefixHex);
  }
  /** Remove a payload prefix from the watch list
   * @param {string} prefix - Payload prefix to remove
   */
  removePrefix(prefix) {
    this.scanner?.removePrefix(prefix);
  }
  /** Remove a hex payload prefix from the watch list
   * @param {string} prefixHex - Hex prefix to remove
   */
  removePrefixHex(prefixHex) {
    this.scanner?.removePrefixHex?.(prefixHex);
  }
  /** Set the list of payload prefixes to watch
   * @param {Array<string>|string} prefixes - Array of prefixes or single prefix
   */
  setPrefixes(prefixes) {
    if (!this.scanner) return;
    if (Array.isArray(this.scanner.prefixes)) {
      for (const prefix of [...this.scanner.prefixes]) {
        this.scanner.removePrefix(prefix);
      }
    }
    const pfxs = Array.isArray(prefixes) ? prefixes : [prefixes];
    for (const prefix of pfxs) {
      this.scanner.addPrefix(prefix);
    }
  }
  shutdown() {
    this._activeTasks.abort();
    this.scanner.stop();
    this.indexer.stop();
    for (const set of this._subscribers.values()) {
      set.clear();
    }
    this._subscribers.clear();
  }
};
__name(_IntelligenceFacade, "IntelligenceFacade");
var IntelligenceFacade = _IntelligenceFacade;

// kktp/engine/kaspa/crypto/dh_encryption.js
import * as secp2 from "https://esm.sh/@noble/secp256k1";
var _DHSession = class _DHSession {
  constructor() {
    this.myPrivateKeyHex = null;
    this.myPublicKeyHex = null;
    this.myPrivateKeyBytes = null;
    this.myPublicKeyBytes = null;
    this.sharedSecretBytes = null;
    this.sessionKey = null;
    this.peerPublicKeyHex = null;
    this.peerPublicKeyBytes = null;
  }
  /**
   * Initiate handshake: send your public key to peer
   */
  initiateHandshake(privateKeyHex, publicKeyHex) {
    if (!privateKeyHex) {
      throw new Error("initiateHandshake requires privateKeyHex");
    }
    this.myPrivateKeyHex = privateKeyHex;
    if (publicKeyHex) {
      this.myPublicKeyHex = publicKeyHex;
    } else {
      this.myPublicKeyHex = getPublicKeyHex(privateKeyHex);
    }
    this.myPrivateKeyBytes = hexToBytes2(privateKeyHex);
    this.myPublicKeyBytes = hexToBytes2(this.myPublicKeyHex);
    return {
      type: "DH_INIT",
      publicKey: this.myPublicKeyHex,
      timestamp: Date.now()
    };
  }
  /**
   * Respond to handshake: accept peer public key and derive shared secret
   */
  async respondToHandshake(peerPublicKeyHex) {
    this.peerPublicKeyHex = peerPublicKeyHex;
    this.peerPublicKeyBytes = hexToBytes2(peerPublicKeyHex);
    this.sharedSecretBytes = secp2.getSharedSecret(
      this.myPrivateKeyBytes,
      this.peerPublicKeyBytes,
      true
    );
    const digest = await window.crypto.subtle.digest(
      "SHA-256",
      this.sharedSecretBytes
    );
    const sessionKey = new Uint8Array(digest);
    this.sessionKey = sessionKey;
    return {
      type: "DH_ACK",
      publicKey: this.myPublicKeyHex,
      timestamp: Date.now()
    };
  }
  /**
   * Derives the raw shared secret (for KKTP HKDF).
   */
  deriveSharedSecret(peerPublicKeyHex) {
    this.peerPublicKeyHex = peerPublicKeyHex;
    this.peerPublicKeyBytes = hexToBytes2(peerPublicKeyHex);
    this.sharedSecretBytes = secp2.getSharedSecret(
      this.myPrivateKeyBytes,
      this.peerPublicKeyBytes,
      true
    );
    return this.sharedSecretBytes;
  }
  setSessionKey(key) {
    this.sessionKey = key;
  }
  /**
   * Encrypt a message with the session key
   */
  encryptMessage(plaintext) {
    if (!this.sessionKey) throw new Error("Session not established");
    const sessionKeyHex = bytesToHex(this.sessionKey);
    return encryptXChaCha20Poly1305(plaintext, sessionKeyHex);
  }
  /**
   * Decrypt a message with the session key
   */
  decryptMessage(cipherText) {
    if (!this.sessionKey) throw new Error("Session not established");
    const sessionKeyHex = bytesToHex(this.sessionKey);
    return decryptXChaCha20Poly1305(cipherText, sessionKeyHex);
  }
};
__name(_DHSession, "DHSession");
var DHSession = _DHSession;

// kktp/engine/kaspa/crypto/cryptoFacade.js
var _CryptoFacade = class _CryptoFacade {
  // Symmetric Encryption (Standard)
  encrypt(text, password) {
    return encryptMessage(text, password);
  }
  decrypt(encrypted, password) {
    return decryptMessage(encrypted, password);
  }
  /**
   * Create DH Session.
   */
  createDHSession(privateKey, publicKey) {
    if (!privateKey && !publicKey) {
      throw new Error("Cannot create DH session without private key and public key");
    }
    const session = new DHSession();
    if (privateKey) {
      session.initiateHandshake(privateKey, publicKey);
    }
    return session;
  }
  /**
   * Generates KKTP Identity Keys (Branch 0 and 100).
   */
  async generateIdentityKeys(xprvHex, index) {
    const sigRaw = await deriveChildKeyPair({ xprvHex, branch: 0, index });
    const dhRaw = await deriveChildKeyPair({ xprvHex, branch: 100, index });
    return {
      sig: { privateKey: sigRaw.privateKey, publicKey: sigRaw.publicKey },
      dh: { privateKey: dhRaw.privateKey, publicKey: dhRaw.publicKey }
    };
  }
  // --- Signing & Verification ---
  async signMessage(privateKeyHex, message) {
    return await signMessageWithPrivateKeyHex(privateKeyHex, message);
  }
  async verifyMessage(publicKeyHex, message, signatureHex) {
    return await verifyMessageWithPublicKeyHex(
      publicKeyHex,
      message,
      signatureHex
    );
  }
};
__name(_CryptoFacade, "CryptoFacade");
var CryptoFacade = _CryptoFacade;

// kktp/engine/kaspa/vrf/core/errors.js
var _GammaValidationError = class _GammaValidationError extends Error {
  constructor(message, meta) {
    super(message);
    this.name = "GammaValidationError";
    this.meta = meta;
  }
};
__name(_GammaValidationError, "GammaValidationError");
var GammaValidationError = _GammaValidationError;
var _FoldingValidationError = class _FoldingValidationError extends Error {
  constructor(message, meta) {
    super(message);
    this.name = "FoldingValidationError";
    this.meta = meta;
  }
};
__name(_FoldingValidationError, "FoldingValidationError");
var FoldingValidationError = _FoldingValidationError;
var _FoldingExtractionError = class _FoldingExtractionError extends Error {
  constructor(message, meta) {
    super(message);
    this.name = "FoldingExtractionError";
    this.meta = meta;
  }
};
__name(_FoldingExtractionError, "FoldingExtractionError");
var FoldingExtractionError = _FoldingExtractionError;

// kktp/engine/kaspa/vrf/core/logs/logger.js
var currentProvider = console;
var noopLogger = {
  log: /* @__PURE__ */ __name(() => {
  }, "log"),
  error: /* @__PURE__ */ __name(() => {
  }, "error")
};
var formatMeta = /* @__PURE__ */ __name((meta) => {
  if (meta === "" || meta === void 0) return "";
  return typeof meta === "object" ? JSON.stringify(meta) : meta;
}, "formatMeta");
function setLoggerProvider(provider) {
  if (provider === true) {
    currentProvider = console;
  } else if (provider === false) {
    currentProvider = noopLogger;
  } else if (provider && typeof provider.log === "function" && typeof provider.error === "function") {
    currentProvider = provider;
  } else {
    throw new Error(
      "Invalid logger provider: must implement .log() and .error(), or pass true/false."
    );
  }
}
__name(setLoggerProvider, "setLoggerProvider");
function logInfo(msg, meta = "") {
  const message = typeof msg === "string" ? msg : JSON.stringify(msg);
  currentProvider.log(
    `[INFO] ${(/* @__PURE__ */ new Date()).toISOString()} - ${message}`,
    formatMeta(meta)
  );
}
__name(logInfo, "logInfo");
function logError(msg, meta = "") {
  const message = typeof msg === "string" ? msg : JSON.stringify(msg);
  currentProvider.error(
    `[ERROR] ${(/* @__PURE__ */ new Date()).toISOString()} - ${message}`,
    formatMeta(meta)
  );
}
__name(logError, "logError");

// kktp/engine/kaspa/vrf/core/crypto.js
async function sha256Hash(input) {
  let data;
  if (typeof input === "string") {
    if (/^[0-9a-fA-F]+$/.test(input) && input.length % 2 === 0) {
      data = hexToBytes3(input);
    } else {
      data = new TextEncoder().encode(input);
    }
  } else if (input instanceof Uint8Array) {
    data = input;
  } else {
    throw new Error("sha256Hash: input must be string or Uint8Array");
  }
  if (typeof window !== "undefined" && window.crypto && window.crypto.subtle && window.crypto.subtle.digest) {
    try {
      const hashBuffer = await window.crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    } catch (e) {
      logError({ msg: "sha256Hash (browser) failed", error: e });
      throw e;
    }
  }
  throw new Error(
    "sha256Hash: No supported crypto backend found (browser only)"
  );
}
__name(sha256Hash, "sha256Hash");
function hexToBytes3(hex2) {
  if (typeof hex2 !== "string" || hex2.length % 2 !== 0 || !/^[0-9a-fA-F]+$/.test(hex2)) {
    logError({ msg: "hexToBytes: Invalid hex input", hex: hex2 });
    throw new Error("hexToBytes: Input must be even-length hex string");
  }
  const bytes = [];
  for (let i = 0; i < hex2.length; i += 2) {
    const byte = parseInt(hex2.substr(i, 2), 16);
    if (isNaN(byte)) {
      logError({
        msg: "hexToBytes: Invalid byte",
        index: i,
        byte: hex2.substr(i, 2)
      });
      throw new Error("hexToBytes: Invalid byte");
    }
    bytes.push(byte);
  }
  return new Uint8Array(bytes);
}
__name(hexToBytes3, "hexToBytes");
function bytesToPositions(bytes, count) {
  const positions = [];
  for (let i = 0; i < count && i < bytes.length; i++) {
    positions.push(bytes[i]);
  }
  while (positions.length < count) {
    const index = positions.length % bytes.length;
    const offset = Math.floor(positions.length / bytes.length);
    positions.push((bytes[index] + offset * 17) % 256);
  }
  return positions;
}
__name(bytesToPositions, "bytesToPositions");
function hexToBinary(hex2) {
  return hex2.split("").map((char) => {
    return parseInt(char, 16).toString(2).padStart(4, "0");
  }).join("");
}
__name(hexToBinary, "hexToBinary");
function getBitFromHash(hexHash, pos) {
  if (typeof hexHash !== "string" || hexHash.length !== 64 || !/^[0-9a-fA-F]+$/.test(hexHash)) {
    logError({ msg: "getBitFromHash: Invalid hexHash", hexHash });
    throw new Error("getBitFromHash: hexHash must be 64-char hex string");
  }
  if (typeof pos !== "number" || pos < 0 || pos > 255) {
    logError({ msg: "getBitFromHash: Invalid pos", pos });
    throw new Error("getBitFromHash: pos must be 0-255");
  }
  const bytes = hexToBytes3(hexHash);
  const bitIndex = pos % (bytes.length * 8);
  const byteIndex = Math.floor(bitIndex / 8);
  const bitOffset = 7 - bitIndex % 8;
  const byte = bytes[byteIndex];
  return (byte >> bitOffset & 1).toString();
}
__name(getBitFromHash, "getBitFromHash");

// kktp/engine/kaspa/vrf/core/extractor.js
async function extractBits(blocks, positions, logAnomaly, opts = {}) {
  const outputBits = [];
  const auditTrail = [];
  const anomalyBuffer = [];
  for (let i = 0; i < positions.length; i++) {
    const block = blocks[i % blocks.length];
    const pos = positions[i];
    let bit = null;
    let anomaly = null;
    if (!block || !block.hash || typeof block.hash !== "string") {
      anomaly = "missing_or_malformed_block";
      anomalyBuffer.push({ type: anomaly, index: i, block });
      logError(anomaly, { index: i, block });
      continue;
    }
    if (!/^[0-9a-fA-F]{64}$/.test(block.hash)) {
      anomaly = "invalid_hash_format";
      anomalyBuffer.push({ type: anomaly, index: i, block });
      logError(anomaly, { index: i, block });
      continue;
    }
    if (!block.isFinal) {
      anomaly = "block_not_final";
      anomalyBuffer.push({ type: anomaly, index: i, block });
      logError(anomaly, { index: i, block });
      continue;
    }
    try {
      bit = getBitFromHash(block.hash, pos);
      if (bit === "0" || bit === "1") {
        outputBits.push(bit);
      } else {
        anomaly = "invalid_bit";
        anomalyBuffer.push({ type: anomaly, index: i, block, bit });
        logError(anomaly, { index: i, block, bit });
      }
    } catch (e) {
      anomaly = "extraction_failed";
      anomalyBuffer.push({ type: anomaly, index: i, block, error: e.message });
      logError(anomaly, { index: i, block, error: e.message });
    }
    auditTrail.push({
      blockIndex: i % blocks.length,
      blockHash: block ? block.hash : null,
      bitPosition: pos,
      bitValue: bit,
      extractionIndex: i,
      anomaly
    });
  }
  const bitstring = outputBits.join("");
  if (anomalyBuffer.length > 0) {
    await logError(anomalyBuffer);
  }
  if (bitstring.length === 0) {
    await logError([{ type: "fatal_no_bits_extracted", blocks, positions }]);
    const meta = { blocks, positions };
    if (typeof opts.iteration !== "undefined") meta.iteration = opts.iteration;
    throw new FoldingExtractionError(
      "No bits could be extracted: all blocks or hashes invalid",
      meta
    );
  }
  return { bitstring, auditTrail };
}
__name(extractBits, "extractBits");

// kktp/engine/kaspa/vrf/core/folding.js
async function sha256FoldingRule(previousOutput, numPositions) {
  if (typeof previousOutput !== "string" || !/^[01]+$/.test(previousOutput) || previousOutput.length < 8) {
    logError({
      msg: "sha256FoldingRule: Invalid previousOutput",
      previousOutput,
      numPositions
    });
    throw new Error(
      "sha256FoldingRule: previousOutput must be a non-empty bitstring"
    );
  }
  if (typeof numPositions !== "number" || numPositions <= 0 || numPositions > 4096) {
    logError({ msg: "sha256FoldingRule: Invalid numPositions", numPositions });
    throw new Error(
      "sha256FoldingRule: numPositions must be a positive integer <= 4096"
    );
  }
  let hashInput = previousOutput;
  let hashLength = 0;
  let bytesNeeded = numPositions;
  let hashBytes = [];
  try {
    while (hashBytes.length < bytesNeeded) {
      const hash = await sha256Hash(hashInput);
      const chunk = Array.from(hexToBytes3(hash));
      if (!hashLength) hashLength = chunk.length * 8;
      for (let b of chunk) hashBytes.push(b);
      hashInput = hash;
    }
  } catch (e) {
    try {
      logError({
        msg: "sha256FoldingRule: sha256Hash failed",
        error: e,
        previousOutput,
        numPositions
      });
    } catch {
    }
    throw new FoldingExtractionError("sha256FoldingRule: sha256Hash failed", {
      cause: e,
      previousOutput,
      numPositions
    });
  }
  const positions = bytesToPositions(hashBytes, numPositions);
  try {
    logInfo({ previousOutput, rule: "sha256", positions });
  } catch {
  }
  return positions;
}
__name(sha256FoldingRule, "sha256FoldingRule");
async function getInitialPositions(numPositions, seed = "beacon") {
  if (typeof numPositions !== "number" || numPositions <= 0 || numPositions > 4096) {
    logError({
      msg: "getInitialPositions: Invalid numPositions",
      numPositions
    });
    throw new FoldingValidationError(
      "getInitialPositions: numPositions must be a positive integer <= 4096",
      { numPositions }
    );
  }
  if (typeof seed !== "string" || seed.length < 1 || seed.length > 128) {
    logError({ msg: "getInitialPositions: Invalid seed", seed });
    throw new FoldingValidationError(
      "getInitialPositions: seed must be a non-empty string <= 128 chars",
      { seed }
    );
  }
  let hash, bytes;
  try {
    hash = await sha256Hash(seed);
    bytes = Array.from(hexToBytes3(hash));
  } catch (e) {
    try {
      logError({
        msg: "getInitialPositions: sha256Hash failed",
        error: e,
        seed
      });
    } catch {
    }
    throw new FoldingExtractionError("getInitialPositions: sha256Hash failed", {
      cause: e,
      seed
    });
  }
  const positions = [];
  for (let i = 0; i < numPositions; i++) {
    positions.push(bytes[i % bytes.length]);
  }
  try {
    logInfo({ seed, rule: "initial", positions });
  } catch {
  }
  return positions;
}
__name(getInitialPositions, "getInitialPositions");
async function updatePositions(previousOutput, rule, numPositions) {
  if (!previousOutput) {
    return getInitialPositions(numPositions);
  }
  if (rule !== "sha256") {
    try {
      logError({ msg: "updatePositions: Unsupported folding rule", rule });
    } catch {
    }
    throw new FoldingValidationError("Only sha256 folding rule is supported.", {
      rule
    });
  }
  return await sha256FoldingRule(previousOutput, numPositions);
}
__name(updatePositions, "updatePositions");
async function ensureCanonicalHash(input) {
  if (typeof input === "string" && /^[0-9a-fA-F]{64}$/.test(input)) {
    return input;
  }
  if (typeof input === "string" && /^[01]+$/.test(input)) {
    const padded = input.padEnd(256, "0").slice(0, 256);
    let hex2 = "";
    for (let i = 0; i < 256; i += 4) {
      hex2 += parseInt(padded.slice(i, i + 4), 2).toString(16);
    }
    return await sha256Hash(hex2);
  }
  if (typeof input === "string" && /^[0-9a-fA-F]+$/.test(input)) {
    return await sha256Hash(input);
  }
  throw new Error("Invalid input for canonical hash");
}
__name(ensureCanonicalHash, "ensureCanonicalHash");
function rotatePositions(positions, hashLength) {
  if (!Array.isArray(positions)) {
    throw new Error("Positions must be an array");
  }
  if (typeof hashLength !== "number" || hashLength <= 0) {
    throw new Error("hashLength must be a positive number");
  }
  const rotated = positions.map((pos) => pos % hashLength);
  try {
    logInfo({ msg: "Positions rotated", count: rotated.length, hashLength });
  } catch {
  }
  return rotated;
}
__name(rotatePositions, "rotatePositions");
async function whitenEntropy(bitstring) {
  if (typeof bitstring !== "string" || !/^[01]+$/.test(bitstring)) {
    throw new Error("bitstring must be a binary string");
  }
  const hash = await sha256Hash(bitstring);
  const bytes = hexToBytes3(hash);
  const whitened = Array.from(bytes).map((b) => b.toString(2).padStart(8, "0")).join("");
  try {
    logInfo({ msg: "Final whitening complete", originalLength: bitstring.length });
  } catch {
  }
  return whitened;
}
__name(whitenEntropy, "whitenEntropy");
async function recursiveFolding(blocks, initialOutput, rule, iterations, numPositions) {
  if (!Array.isArray(blocks) || blocks.length === 0 || blocks.length > 32 || !blocks.every(
    (b) => b && typeof b.hash === "string" && /^[0-9a-fA-F]{64}$/.test(b.hash)
  )) {
    try {
      logError({ msg: "recursiveFolding: Invalid blocks", blocks });
    } catch {
    }
    throw new FoldingValidationError(
      "recursiveFolding: blocks must be array of 1-32 objects with 64-char hex .hash",
      { blocks }
    );
  }
  if (typeof initialOutput !== "string" || !/^[01]+$/.test(initialOutput) || initialOutput.length < 8) {
    try {
      logError({
        msg: "recursiveFolding: Invalid initialOutput",
        initialOutput
      });
    } catch {
    }
    throw new FoldingValidationError(
      "recursiveFolding: initialOutput must be a non-empty bitstring",
      { initialOutput }
    );
  }
  if (typeof iterations !== "number" || iterations < 1 || iterations > 32) {
    try {
      logError({ msg: "recursiveFolding: Invalid iterations", iterations });
    } catch {
    }
    throw new FoldingValidationError(
      "recursiveFolding: iterations must be 1-32",
      { iterations }
    );
  }
  if (typeof numPositions !== "number" || numPositions <= 0 || numPositions > 4096) {
    try {
      logError({ msg: "recursiveFolding: Invalid numPositions", numPositions });
    } catch {
    }
    throw new FoldingValidationError(
      "recursiveFolding: numPositions must be a positive integer <= 4096",
      { numPositions }
    );
  }
  let currentOutput = initialOutput;
  let positions = await getInitialPositions(numPositions);
  let hashLength = 256;
  const history = [
    {
      iteration: 0,
      output: initialOutput,
      positions: positions.slice(),
      rule: "initial",
      audit: []
    }
  ];
  let allAnomalies = [];
  for (let i = 1; i <= iterations; i++) {
    try {
      positions = await updatePositions(currentOutput, rule, numPositions);
      if (blocks[0] && typeof blocks[0].hash === "string") {
        hashLength = blocks[0].hash.length * 4;
      }
      const safePositions = rotatePositions(positions, hashLength);
      const { bitstring, auditTrail } = await extractBits(
        blocks,
        safePositions,
        (anomaly, details) => {
          try {
            logInfo({ anomaly, ...details });
          } catch {
          }
        },
        { iteration: i }
      );
      try {
        logInfo({ iteration: i, positions: safePositions.slice(), bitstring });
      } catch {
      }
      if (!bitstring || bitstring.length === 0) {
        try {
          logError({
            msg: "recursiveFolding: No bits extracted",
            iteration: i,
            positions: safePositions,
            blocks
          });
        } catch {
        }
        throw new FoldingExtractionError(
          "recursiveFolding: No bits extracted at iteration " + i,
          { iteration: i, positions: safePositions, blocks }
        );
      }
      currentOutput = bitstring;
      history.push({
        iteration: i,
        output: currentOutput,
        positions: safePositions.slice(),
        rule,
        audit: auditTrail
      });
      allAnomalies.push(...auditTrail.filter((a) => a.anomaly));
    } catch (e) {
      try {
        logError({
          msg: "recursiveFolding: Error in iteration",
          error: e,
          iteration: i,
          rule,
          numPositions
        });
      } catch {
      }
      if (e instanceof FoldingExtractionError) {
        e.meta = { ...e.meta || {}, iteration: i };
      }
      throw e;
    }
  }
  return {
    finalPositions: positions,
    finalOutput: currentOutput,
    history,
    anomalies: allAnomalies
  };
}
__name(recursiveFolding, "recursiveFolding");
async function fold(randA, randB, options = {}) {
  const hashA = await ensureCanonicalHash(randA);
  const hashB = await ensureCanonicalHash(randB);
  const blocks = [
    { hash: hashA, isFinal: true },
    { hash: hashB, isFinal: true }
  ];
  const positions = options.seed ? await getInitialPositions(
    256,
    typeof options.seed === "string" && options.seed.length > 0 ? options.seed.slice(0, 128) : "beacon"
  ) : Array.from({ length: 256 }, (_, i) => i);
  const { bitstring: initialBits } = await extractBits(blocks, positions);
  const foldingResult = await recursiveFolding(
    blocks,
    initialBits,
    "sha256",
    options.iterations || 2,
    options.numPositions || 256
  );
  return await whitenEntropy(foldingResult.finalOutput);
}
__name(fold, "fold");

// kktp/engine/kaspa/vrf/core/models/Block.js
var _Block = class _Block {
  constructor(data) {
    this.hash = data.hash;
    this.source = data.source || "kaspa";
    this.pulseIndex = data.pulseIndex || 0;
    this.timestamp = data.timestamp || data.time || data.timeStamp || 0;
    this.blueScore = data.blueScore || 0;
    this.daaScore = data.daaScore || 0;
    this.parents = data.parents || [];
    this.signature = data.signatureValue || data.signature || "";
    this.seedValue = data.seedValue || data.hash;
    this.confirms = data.confirms || 0;
    this.isFinal = this.source === "nist" || this.confirms >= 20 || !!this.blueScore;
  }
  /**
   * Static helper for Kaspa WASM integration
   */
  static fromKaspa(rawBlock, blueScore) {
    const header = rawBlock.header || rawBlock;
    const parents = header.parents ? Array.from(header.parents).map((p) => p.toString()) : [];
    return new _Block({
      hash: header.hash?.toString() || rawBlock.hash?.toString(),
      timestamp: Number(header.timestamp || rawBlock.timestamp),
      blueScore: Number(blueScore || header.blueScore || 0),
      daaScore: Number(header.daaScore || 0),
      parents,
      source: "kaspa"
    });
  }
  /**
   * Split NIST 512-bit hashes for 256-bit compatibility
   */
  static fromNistSplit(qrngBlock) {
    const metadata = {
      timestamp: qrngBlock.time || qrngBlock.timeStamp,
      source: "nist",
      pulseIndex: qrngBlock.pulseIndex || qrngBlock.index || 0,
      signature: qrngBlock.signatureValue || qrngBlock.signature,
      seedValue: qrngBlock.seedValue,
      daaScore: 0,
      // Not applicable to NIST
      parents: []
    };
    return [
      new _Block({ ...metadata, hash: qrngBlock.hash.substring(0, 64) }),
      new _Block({ ...metadata, hash: qrngBlock.hash.substring(64, 128) })
    ];
  }
};
__name(_Block, "Block");
var Block = _Block;

// kktp/engine/kaspa/vrf/core/config.js
var CONFIG = {
  // Tunable block counts
  BTC_BLOCK_COUNT: 6,
  // default, can be overridden
  KASPA_BLOCK_COUNT: 6,
  // default, can be overridden
  // Finality
  BTC_FINALITY_CONFIRMATIONS: 6,
  KASPA_FINALITY_DAG_DEPTH: 60,
  // Cache durations (ms)
  BTC_CACHE_DURATION: 10 * 60 * 1e3,
  // 10 minutes
  QRNG_CACHE_DURATION: 60 * 1e3,
  // 1 minute
  // API call throttling (ms)
  BTC_API_THROTTLE: 2e3,
  // 2 seconds between calls
  QRNG_API_THROTTLE: 6e4
  // 1 minute between calls
};

// kktp/engine/kaspa/vrf/core/constants.js
var KASPA_BLOCK_COUNT = CONFIG.KASPA_BLOCK_COUNT;
var BTC_BLOCK_COUNT = CONFIG.BTC_BLOCK_COUNT;
var FINALITY = {
  bitcoin: { confirmations: CONFIG.BTC_FINALITY_CONFIRMATIONS },
  kaspa: { dagDepth: CONFIG.KASPA_FINALITY_DAG_DEPTH }
};

// kktp/engine/kaspa/vrf/core/fetcher/cache.js
var BTC_KEY = "btc_block_cache";
var QRNG_KEY = "qrng_cache";
var btcBlockCache = { blocks: [], timestamp: 0 };
var qrngCache = { provider: null, length: null, result: null, timestamp: 0 };
function getBtcBlockCache() {
  try {
    const raw = localStorage.getItem(BTC_KEY);
    if (raw) {
      const data = JSON.parse(raw);
      btcBlockCache = data;
      logInfo("Read BTC block cache", { BTC_KEY });
      return data;
    }
  } catch (err) {
    logError("Failed to read BTC block cache", { BTC_KEY, error: err.message });
  }
  return btcBlockCache;
}
__name(getBtcBlockCache, "getBtcBlockCache");
function setBtcBlockCache(blocks) {
  const cacheObj = { blocks, timestamp: Date.now() };
  btcBlockCache = cacheObj;
  try {
    localStorage.setItem(BTC_KEY, JSON.stringify(cacheObj));
    logInfo("Wrote BTC block cache", { BTC_KEY });
  } catch (err) {
    logError("Failed to write BTC block cache", { BTC_KEY, error: err.message });
  }
}
__name(setBtcBlockCache, "setBtcBlockCache");
function getQrngCache() {
  try {
    const raw = localStorage.getItem(QRNG_KEY);
    if (raw) {
      const data = JSON.parse(raw);
      qrngCache = data;
      logInfo("Read QRNG cache", { QRNG_KEY });
      return data;
    }
  } catch (err) {
    logError("Failed to read QRNG cache", { QRNG_KEY, error: err.message });
  }
  return qrngCache;
}
__name(getQrngCache, "getQrngCache");
function setQrngCache(provider, length, result) {
  const cacheObj = { provider, length, result, timestamp: Date.now() };
  qrngCache = cacheObj;
  try {
    localStorage.setItem(QRNG_KEY, JSON.stringify(cacheObj));
    logInfo("Wrote QRNG cache", { QRNG_KEY });
  } catch (err) {
    logError("Failed to write QRNG cache", { QRNG_KEY, error: err.message });
  }
}
__name(setQrngCache, "setQrngCache");

// kktp/engine/kaspa/vrf/core/fetcher/bitcoin.js
var PROXY = "https://api.allorigins.win/raw?url=";
var API_URL = "https://mempool.space/api/v1/blocks";
var lastBtcApiCall = 0;
async function getBitcoinBlocks(n = BTC_BLOCK_COUNT) {
  if (!Number.isInteger(n) || n <= 0)
    throw new Error("BTC block count must be a positive integer");
  const now2 = Date.now();
  const cache = getBtcBlockCache();
  if (cache && now2 - cache.timestamp < CONFIG.BTC_CACHE_DURATION && cache.blocks.length >= n) {
    logInfo("BTC block cache hit", { n });
    return cache.blocks.slice(0, n);
  }
  if (now2 - lastBtcApiCall < CONFIG.BTC_API_THROTTLE) {
    if (cache && cache.blocks && cache.blocks.length >= n) {
      logInfo("BTC API throttled, returning cached data (stale allowed)", {
        n
      });
      return cache.blocks.slice(0, n);
    }
    const waitTime = Math.ceil(
      (CONFIG.BTC_API_THROTTLE - (now2 - lastBtcApiCall)) / 1e3
    );
    throw new Error(`BTC API throttled and no cached data: wait ${waitTime}s`);
  }
  const MAX_RETRIES = 3;
  let lastErr = null;
  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      lastBtcApiCall = Date.now();
      logInfo(`Requesting BTC blocks via Proxy (attempt ${attempt}/${MAX_RETRIES})...`);
      const response = await fetch(`${PROXY}${encodeURIComponent(API_URL)}`);
      if (!response.ok)
        throw new Error(
          `Proxy/API Error: ${response.status} ${response.statusText}`
        );
      const latestBatch = await response.json();
      if (!Array.isArray(latestBatch) || latestBatch.length === 0)
        throw new Error("Invalid or empty data format from Mempool");
      const latestHeight = latestBatch[0].height;
      const blocks = latestBatch.slice(0, n).map((b) => {
        return new Block({
          hash: b.id,
          height: b.height,
          time: b.timestamp,
          source: "mempool.space",
          confirms: latestHeight - b.height + 1
        });
      });
      setBtcBlockCache(blocks);
      logInfo("BTC blocks successfully fetched and cached", {
        count: blocks.length
      });
      return blocks;
    } catch (err) {
      lastErr = err;
      lastBtcApiCall = 0;
      logError(`BTC fetch error (attempt ${attempt}/${MAX_RETRIES})`, { n, error: err.message });
      if (attempt < MAX_RETRIES) {
        const delay2 = 1e3 * Math.pow(2, attempt - 1);
        logInfo(`Retrying BTC fetch in ${delay2}ms...`);
        await new Promise((r2) => setTimeout(r2, delay2));
      }
    }
  }
  const staleCache = getBtcBlockCache();
  if (staleCache?.blocks?.length >= n) {
    logInfo("All BTC fetch retries failed, returning stale cache", {
      n,
      cacheAge: Math.round((Date.now() - staleCache.timestamp) / 1e3) + "s"
    });
    return staleCache.blocks.slice(0, n);
  }
  throw lastErr;
}
__name(getBitcoinBlocks, "getBitcoinBlocks");

// kktp/engine/kaspa/vrf/core/fetcher/kaspa.js
var BUFFER_SIZE = 20;
var _blockBuffer = [];
var _subscribed = false;
var _unsubscribe = null;
async function subscribeToBlocks() {
  if (_subscribed) {
    logInfo("Already subscribed to Kaspa blocks");
    return;
  }
  _unsubscribe = await kaspaPortal?.onNewBlock((block) => {
    _addBlockToBuffer(block);
  });
  _subscribed = true;
  logInfo("Subscribed to Kaspa blocks for VRF entropy", {
    bufferSize: BUFFER_SIZE
  });
}
__name(subscribeToBlocks, "subscribeToBlocks");
function unsubscribeFromBlocks() {
  if (_unsubscribe && typeof _unsubscribe === "function") {
    _unsubscribe();
    _unsubscribe = null;
  }
  _subscribed = false;
  logInfo("Unsubscribed from Kaspa blocks");
}
__name(unsubscribeFromBlocks, "unsubscribeFromBlocks");
function _addBlockToBuffer(cleanBlock) {
  if (!cleanBlock || !cleanBlock.hash) return;
  if (_blockBuffer.length > 0 && _blockBuffer[0].hash === cleanBlock.hash) {
    return;
  }
  const vrfBlock = new Block(cleanBlock);
  vrfBlock.isFinal = true;
  vrfBlock.confirms = 1;
  _blockBuffer.unshift(vrfBlock);
  if (_blockBuffer.length > BUFFER_SIZE) {
    _blockBuffer.pop();
  }
  _updateConfirmations();
}
__name(_addBlockToBuffer, "_addBlockToBuffer");
function _updateConfirmations() {
  for (let i = 0; i < _blockBuffer.length; i++) {
    _blockBuffer[i].confirms = i + 1;
  }
}
__name(_updateConfirmations, "_updateConfirmations");
function hasEnoughBlocks(n) {
  return _blockBuffer.length >= n;
}
__name(hasEnoughBlocks, "hasEnoughBlocks");
async function getKaspaBlocks(n = KASPA_BLOCK_COUNT) {
  if (!Number.isInteger(n) || n <= 0) {
    throw new Error("Kaspa block count must be a positive integer");
  }
  if (_blockBuffer.length >= n) {
    const blocks = _blockBuffer.slice(0, n);
    logInfo("Kaspa blocks from buffer", {
      count: blocks.length,
      tipBlueScore: blocks[0]?.blueScore,
      bufferSize: _blockBuffer.length
    });
    return blocks;
  }
  if (_blockBuffer.length > 0) {
    logInfo("Buffer has partial blocks, returning partial buffer", {
      have: _blockBuffer.length,
      need: n
    });
    return _blockBuffer.slice(0, Math.min(n, _blockBuffer.length));
  }
  logInfo("No buffer available");
  throw new Error(
    "No Kaspa blocks, you likely forgot to connect to a Kaspa node first."
  );
}
__name(getKaspaBlocks, "getKaspaBlocks");

// kktp/engine/kaspa/vrf/core/fetcher/QRNG-fetcher.js
var log10 = Logger.create(LogModule.vrf.core.fetcher.qrngFetcher);
var _QRNGProvider = class _QRNGProvider {
  constructor(name, baseUrl) {
    this.name = name;
    this.baseUrl = baseUrl;
  }
  async fetchRandomness(params = {}) {
    throw new Error("fetchRandomness() must be implemented by subclass");
  }
  async request(url, options = {}) {
    try {
      const res = await fetch(url, options);
      if (!res.ok) {
        throw new Error(`${this.name} API error: ${res.status}`);
      }
      return await res.json();
    } catch (err) {
      log10.error(`[${this.name}] Request failed:`, err.message);
      throw err;
    }
  }
};
__name(_QRNGProvider, "QRNGProvider");
var QRNGProvider = _QRNGProvider;
var _NISTBeacon = class _NISTBeacon extends QRNGProvider {
  constructor() {
    super("NIST Beacon", "https://beacon.nist.gov/beacon/2.0/chain/1/pulse/last");
  }
  async fetchRandomness(length = 64) {
    const data = await this.request(this.baseUrl);
    const hex2 = data?.pulse?.outputValue;
    if (!hex2) throw new Error("NIST Beacon response missing outputValue");
    const bytes = [];
    for (let i = 0; i < hex2.length; i += 2) {
      bytes.push(parseInt(hex2.substr(i, 2), 16));
    }
    return bytes.slice(0, length);
  }
};
__name(_NISTBeacon, "NISTBeacon");
var NISTBeacon = _NISTBeacon;

// kktp/engine/kaspa/vrf/core/fetcher/qrng.js
var nistProvider = new NISTBeacon();
async function getQRNG(providerName = "nist", length = 32) {
  if (!length || length <= 0) {
    throw new Error("Invalid QRNG length");
  }
  const cache = getQrngCache();
  if (cache?.result?.hash && Date.now() - cache.timestamp < CONFIG.QRNG_CACHE_DURATION) {
    return cache.result;
  }
  const MAX_RETRIES = 3;
  let lastErr = null;
  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      logInfo(`Fetching QRNG (attempt ${attempt}/${MAX_RETRIES})...`);
      const response = await nistProvider.request(nistProvider.baseUrl);
      const pulse = response.pulse;
      const previousValue = pulse.listValues?.find((v) => v.type === "previous")?.value || pulse.previousOutputValue;
      const qrngBlock = new Block({
        hash: pulse.outputValue,
        time: pulse.timeStamp,
        source: providerName,
        seedValue: pulse.seedValue,
        certificateId: pulse.certificateId,
        previousOutputValue: pulse.localPrevHash || previousValue,
        pulseIndex: pulse.pulseIndex,
        signature: pulse.signatureValue,
        signatureValue: pulse.signatureValue,
        uri: pulse.uri,
        version: pulse.version,
        cipherSuite: pulse.cipherSuite,
        period: pulse.period,
        chainIndex: pulse.chainIndex,
        timeStamp: pulse.timeStamp,
        localRandomValue: pulse.localRandomValue,
        external: pulse.external,
        listValues: pulse.listValues,
        precommitmentValue: pulse.precommitmentValue,
        statusCode: pulse.statusCode
      });
      setQrngCache(providerName, length, qrngBlock);
      return qrngBlock;
    } catch (err) {
      lastErr = err;
      logError(`QRNG Fetch Failed (attempt ${attempt}/${MAX_RETRIES})`, err.message);
      if (attempt < MAX_RETRIES) {
        const delay2 = 1e3 * Math.pow(2, attempt - 1);
        logInfo(`Retrying QRNG fetch in ${delay2}ms...`);
        await new Promise((r2) => setTimeout(r2, delay2));
      }
    }
  }
  if (cache?.result?.hash) {
    logInfo("All QRNG retries failed, returning stale cached pulse", {
      cacheAge: Math.round((Date.now() - cache.timestamp) / 1e3) + "s"
    });
    return cache.result;
  }
  throw lastErr;
}
__name(getQRNG, "getQRNG");

// kktp/engine/kaspa/vrf/core/tests/gamma.js
var logGammaCache = /* @__PURE__ */ new Map();
var LOGGAMMA_CACHE_SIZE = 64;
var FPMIN = 1e-300;
function cacheLogGamma(key, value) {
  if (logGammaCache.size >= LOGGAMMA_CACHE_SIZE) {
    const firstKey = logGammaCache.keys().next().value;
    logGammaCache.delete(firstKey);
  }
  logGammaCache.set(key, value);
}
__name(cacheLogGamma, "cacheLogGamma");
function logGamma(z) {
  if (typeof z !== "number" || !isFinite(z)) {
    throw new GammaValidationError("logGamma: z must be a finite number", {
      z
    });
  }
  const originalZ = z;
  if (logGammaCache.has(originalZ)) return logGammaCache.get(originalZ);
  const g = 7;
  const p = [
    0.9999999999998099,
    676.5203681218851,
    -1259.1392167224028,
    771.3234287776531,
    -176.6150291621406,
    12.507343278686905,
    -0.13857109526572012,
    9984369578019572e-21,
    15056327351493116e-23
  ];
  let result;
  if (z < 0.5) {
    result = Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - logGamma(1 - z);
  } else {
    z -= 1;
    let x = p[0];
    for (let i = 1; i < g + 2; i++) x += p[i] / (z + i);
    const t = z + g + 0.5;
    result = 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x) - Math.log(z + 1);
  }
  cacheLogGamma(originalZ, result);
  return result;
}
__name(logGamma, "logGamma");
function gammaQ2(a, x, opts = {}) {
  if (typeof a !== "number" || !isFinite(a) || a <= 0) {
    throw new GammaValidationError(
      "gammaQ: a must be a positive finite number",
      { a }
    );
  }
  if (typeof x !== "number" || !isFinite(x) || x < 0) {
    throw new GammaValidationError(
      "gammaQ: x must be a non-negative finite number",
      { x }
    );
  }
  if (opts && ("eps" in opts && (!isFinite(opts.eps) || opts.eps <= 0) || "itmax" in opts && (!isFinite(opts.itmax) || opts.itmax <= 0))) {
    throw new GammaValidationError(
      "gammaQ: opts.eps and opts.itmax must be finite and > 0",
      { opts }
    );
  }
  const EPS = typeof opts.eps === "number" && isFinite(opts.eps) && opts.eps > 0 ? opts.eps : 1e-8;
  const ITMAX = typeof opts.itmax === "number" && isFinite(opts.itmax) && opts.itmax > 0 ? Math.floor(opts.itmax) : 100;
  if (x === 0) return 1;
  if (x < a + 1) {
    return 1 - gammaPSer(a, x, EPS, ITMAX);
  } else {
    return gammaQCF(a, x, EPS, ITMAX);
  }
}
__name(gammaQ2, "gammaQ");
function gammaPSer(a, x, EPS, ITMAX) {
  let sum = 1 / a, del = sum, ap = a;
  for (let n = 1; n < ITMAX; n++) {
    ap++;
    del *= x / ap;
    sum += del;
    if (Math.abs(del) < Math.abs(sum) * EPS) break;
  }
  return sum * Math.exp(-x + a * Math.log(x) - logGamma(a));
}
__name(gammaPSer, "gammaPSer");
function gammaQCF(a, x, EPS, ITMAX) {
  let b = x + 1 - a, c = 1 / FPMIN, d = 1 / b, h = d;
  for (let i = 1; i < ITMAX; i++) {
    let an = -i * (i - a);
    b += 2;
    d = an * d + b;
    if (Math.abs(d) < FPMIN) d = FPMIN;
    c = b + an / c;
    if (Math.abs(c) < FPMIN) c = FPMIN;
    d = 1 / d;
    let del = d * c;
    h *= del;
    if (Math.abs(del - 1) < EPS) break;
  }
  return Math.exp(-x + a * Math.log(x) - logGamma(a)) * h;
}
__name(gammaQCF, "gammaQCF");

// kktp/engine/kaspa/vrf/core/tests/utilities.js
function isPowerOfTwo(m) {
  return (m & m - 1) === 0;
}
__name(isPowerOfTwo, "isPowerOfTwo");
function fftRadix2(re, im) {
  const N = re.length;
  let j = 0;
  for (let i = 0; i < N; i++) {
    if (i < j) {
      const tr = re[i];
      re[i] = re[j];
      re[j] = tr;
      const ti = im[i];
      im[i] = im[j];
      im[j] = ti;
    }
    let m = N >> 1;
    while (m && j & m) {
      j &= ~m;
      m >>= 1;
    }
    j |= m;
  }
  for (let len = 2; len <= N; len <<= 1) {
    const halfLen = len >> 1;
    const theta = -2 * Math.PI / len;
    const wpr = Math.cos(theta);
    const wpi = Math.sin(theta);
    for (let start = 0; start < N; start += len) {
      let wr = 1, wi = 0;
      for (let k = 0; k < halfLen; k++) {
        const i0 = start + k;
        const i1 = i0 + halfLen;
        const tr = wr * re[i1] - wi * im[i1];
        const ti = wr * im[i1] + wi * re[i1];
        re[i1] = re[i0] - tr;
        im[i1] = im[i0] - ti;
        re[i0] = re[i0] + tr;
        im[i0] = im[i0] + ti;
        const tmpWr = wr * wpr - wi * wpi;
        wi = wr * wpi + wi * wpr;
        wr = tmpWr;
      }
    }
  }
}
__name(fftRadix2, "fftRadix2");
function dftMagnitudesNaive(realSeq) {
  const N = realSeq.length;
  const mags = new Array(N);
  for (let k = 0; k < N; k++) {
    let re = 0, im = 0;
    const angBase = -2 * Math.PI * k / N;
    for (let t = 0; t < N; t++) {
      const ang = angBase * t;
      const c = Math.cos(ang);
      const s = Math.sin(ang);
      re += realSeq[t] * c;
      im += realSeq[t] * s;
    }
    mags[k] = Math.hypot(re, im);
  }
  return mags;
}
__name(dftMagnitudesNaive, "dftMagnitudesNaive");
function erfc(x) {
  const z = Math.abs(x);
  const t = 1 / (1 + 0.5 * z);
  const r2 = t * Math.exp(
    -z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))))
  );
  return x >= 0 ? r2 : 2 - r2;
}
__name(erfc, "erfc");

// kktp/engine/kaspa/vrf/core/tests/basic.js
function frequencyMonobitTest(bits) {
  const n = bits.length;
  if (n === 0) {
    return {
      testName: "Frequency (Monobit) Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Input bitstring is empty." }
    };
  }
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += bits[i] === "1" ? 1 : -1;
  }
  const sObs = Math.abs(sum) / Math.sqrt(n);
  let pValue, erfcError;
  try {
    pValue = erfc(sObs / Math.sqrt(2));
    if (!isFinite(pValue) || isNaN(pValue)) {
      erfcError = "erfc returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const ones = bits.split("").filter((b) => b === "1").length;
  const zeros = n - ones;
  const propOnes = n > 0 ? ones / n : 0;
  const propZeros = n > 0 ? zeros / n : 0;
  return {
    testName: "Frequency (Monobit) Test",
    passed,
    statistic: sObs,
    pValue,
    threshold: 0.01,
    details: {
      n,
      sum,
      sObs,
      pValue,
      erfcError,
      ones,
      zeros,
      propOnes,
      propZeros,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(frequencyMonobitTest, "frequencyMonobitTest");
function blockFrequencyTest(bits, blockSize) {
  const n = bits.length;
  if (n === 0 || blockSize <= 0 || blockSize > n) {
    return {
      testName: "Block Frequency Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: "Invalid input: empty bitstring or blockSize out of range."
      }
    };
  }
  const N = Math.floor(n / blockSize);
  if (N === 0) {
    return {
      testName: "Block Frequency Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Bitstring too short for even one block." }
    };
  }
  let sum = 0;
  const proportions = [];
  for (let i = 0; i < N; i++) {
    const block = bits.slice(i * blockSize, (i + 1) * blockSize);
    const ones = block.split("").filter((b) => b === "1").length;
    const pi = ones / blockSize;
    proportions.push(pi);
    sum += Math.pow(pi - 0.5, 2);
  }
  const chiSquared = 4 * blockSize * sum;
  let pValue, gammaQError;
  try {
    pValue = gammaQ2(N / 2, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const meanProportion = proportions.length ? proportions.reduce((a, b) => a + b, 0) / proportions.length : 0;
  const varianceProportion = proportions.length ? proportions.reduce((a, b) => a + Math.pow(b - meanProportion, 2), 0) / proportions.length : 0;
  const minProportion = proportions.length ? Math.min(...proportions) : 0;
  const maxProportion = proportions.length ? Math.max(...proportions) : 0;
  return {
    testName: "Block Frequency Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details: {
      n,
      blockSize,
      N,
      chiSquared,
      pValue,
      gammaQError,
      proportionsPreview: proportions.slice(0, 5),
      // Show first 5 for brevity
      meanProportion,
      varianceProportion,
      minProportion,
      maxProportion,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(blockFrequencyTest, "blockFrequencyTest");
function runsTest(bits) {
  const n = bits.length;
  if (n === 0) {
    return {
      testName: "Runs Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Input bitstring is empty." }
    };
  }
  const pi = bits.split("").filter((b) => b === "1").length / n;
  if (Math.abs(pi - 0.5) >= 2 / Math.sqrt(n)) {
    return {
      testName: "Runs Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        n,
        pi,
        error: "Proportion of ones too far from 0.5 for Runs Test to be valid."
      }
    };
  }
  let runs = 1;
  for (let i = 1; i < n; i++) {
    if (bits[i] !== bits[i - 1]) runs++;
  }
  const expectedRuns = 2 * n * pi * (1 - pi);
  const variance = 2 * n * (4 * pi * (1 - pi) - 1) / (n - 1);
  const stddev = Math.sqrt(variance);
  const z = Math.abs(runs - expectedRuns) / stddev;
  let pValue, erfcError;
  try {
    pValue = erfc(z / Math.sqrt(2));
    if (!isFinite(pValue) || isNaN(pValue)) {
      erfcError = "erfc returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  let runSequencePreview = [];
  if (n > 0) {
    let current = bits[0], count = 1;
    for (let i = 1; i < Math.min(n, 20); i++) {
      if (bits[i] === current) {
        count++;
      } else {
        runSequencePreview.push({ bit: current, length: count });
        current = bits[i];
        count = 1;
      }
    }
    runSequencePreview.push({ bit: current, length: count });
  }
  return {
    testName: "Runs Test",
    passed,
    statistic: z,
    pValue,
    threshold: 0.01,
    details: {
      n,
      pi,
      runs,
      expectedRuns,
      stddev,
      variance,
      z,
      pValue,
      erfcError,
      runSequencePreview,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(runsTest, "runsTest");
function longestRunOfOnesTest(bits, blockSize) {
  const n = bits.length;
  if (n === 0 || blockSize <= 0 || blockSize > n) {
    return {
      testName: "Longest Run of Ones in a Block Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: "Invalid input: empty bitstring or blockSize out of range."
      }
    };
  }
  const N = Math.floor(n / blockSize);
  if (N === 0) {
    return {
      testName: "Longest Run of Ones in a Block Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Bitstring too short for even one block." }
    };
  }
  let v, pi;
  if (blockSize === 8) {
    v = [1, 2, 3, 4];
    pi = [0.2148, 0.3672, 0.2305, 0.1875];
  } else if (blockSize === 128) {
    v = [4, 5, 6, 7];
    pi = [0.1174, 0.243, 0.2493, 0.3903];
  } else if (blockSize === 512) {
    v = [10, 11, 12, 13, 14, 15, 16];
    pi = [0.0882, 0.2092, 0.2483, 0.1933, 0.1208, 0.0675, 0.0727];
  } else {
    return {
      testName: "Longest Run of Ones in a Block Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Unsupported blockSize. Supported: 8, 128, 512." }
    };
  }
  const counts = Array(v.length).fill(0);
  for (let i = 0; i < N; i++) {
    const block = bits.slice(i * blockSize, (i + 1) * blockSize);
    let maxRun = 0, run = 0;
    for (let j = 0; j < block.length; j++) {
      if (block[j] === "1") {
        run++;
        if (run > maxRun) maxRun = run;
      } else {
        run = 0;
      }
    }
    let binned = false;
    for (let k = 0; k < v.length - 1; k++) {
      if (maxRun <= v[k]) {
        counts[k]++;
        binned = true;
        break;
      }
    }
    if (!binned) counts[v.length - 1]++;
  }
  let chiSquared = 0;
  for (let i = 0; i < v.length; i++) {
    const expected = pi[i] * N;
    chiSquared += Math.pow(counts[i] - expected, 2) / expected;
  }
  const df = v.length - 1;
  let pValue, gammaQError;
  try {
    pValue = gammaQ2(df / 2, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  let maxDeviation = -Infinity, maxDeviationIndex = -1;
  for (let i = 0; i < v.length; i++) {
    const expected = pi[i] * N;
    const deviation = Math.abs(counts[i] - expected);
    if (deviation > maxDeviation) {
      maxDeviation = deviation;
      maxDeviationIndex = i;
    }
  }
  const categoryDiagnostics = v.map((val, i) => ({
    index: i,
    v: val,
    observed: counts[i],
    expected: pi[i] * N,
    deviation: counts[i] - pi[i] * N
  }));
  const details = {
    n,
    blockSize,
    N,
    chiSquared,
    pValue,
    counts,
    v,
    pi,
    df,
    gammaQError,
    categoryDiagnostics,
    maxDeviationCategory: maxDeviationIndex >= 0 ? {
      index: maxDeviationIndex,
      v: v[maxDeviationIndex],
      observed: counts[maxDeviationIndex],
      expected: pi[maxDeviationIndex] * N,
      deviation: maxDeviation
    } : void 0,
    interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
  };
  return {
    testName: "Longest Run of Ones in a Block Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details
  };
}
__name(longestRunOfOnesTest, "longestRunOfOnesTest");
function serialTest(bits, m) {
  const n = bits.length;
  if (n === 0 || m < 1 || m > 16) {
    return {
      testName: "Serial Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: "Invalid input: empty bitstring or pattern length out of range."
      }
    };
  }
  function patternCounts(bits2, m2) {
    const counts = {};
    const n2 = bits2.length;
    for (let i = 0; i < n2; i++) {
      let pattern = "";
      for (let j = 0; j < m2; j++) {
        pattern += bits2[(i + j) % n2];
      }
      counts[pattern] = (counts[pattern] || 0) + 1;
    }
    return counts;
  }
  __name(patternCounts, "patternCounts");
  function psi2(bits2, m2) {
    const n2 = bits2.length;
    const counts = patternCounts(bits2, m2);
    let sum = 0;
    for (const k in counts) {
      sum += counts[k] * counts[k];
    }
    return sum * Math.pow(2, m2) / n2 - n2;
  }
  __name(psi2, "psi2");
  const psi2_m = psi2(bits, m);
  const psi2_m1 = psi2(bits, m - 1);
  const psi2_m2 = psi2(bits, m - 2);
  const delta1 = psi2_m - psi2_m1;
  const delta2 = psi2_m - 2 * psi2_m1 + psi2_m2;
  const df1 = Math.pow(2, m - 1);
  const df2 = Math.pow(2, m - 2);
  let pValue1, pValue2, gammaQError1, gammaQError2;
  try {
    pValue1 = gammaQ2(df1, delta1 / 2);
    if (!isFinite(pValue1) || isNaN(pValue1)) {
      gammaQError1 = "gammaQ returned non-finite pValue1.";
      pValue1 = null;
    }
  } catch (err) {
    gammaQError1 = "gammaQ threw for pValue1: " + (err && err.message ? err.message : String(err));
    pValue1 = null;
  }
  try {
    pValue2 = gammaQ2(df2, delta2 / 2);
    if (!isFinite(pValue2) || isNaN(pValue2)) {
      gammaQError2 = "gammaQ returned non-finite pValue2.";
      pValue2 = null;
    }
  } catch (err) {
    gammaQError2 = "gammaQ threw for pValue2: " + (err && err.message ? err.message : String(err));
    pValue2 = null;
  }
  const passed = pValue1 !== null && pValue1 >= 0.01 && pValue2 !== null && pValue2 >= 0.01;
  let interpretation;
  if (passed) {
    interpretation = "Passes randomness criteria";
  } else {
    const fail1 = pValue1 === null || pValue1 < 0.01;
    const fail2 = pValue2 === null || pValue2 < 0.01;
    if (fail1 && fail2) {
      interpretation = "Fails randomness criteria (both \u03941 and \u03942 subtests failed)";
    } else if (fail1) {
      interpretation = "Fails randomness criteria (\u03941 subtest failed)";
    } else if (fail2) {
      interpretation = "Fails randomness criteria (\u03942 subtest failed)";
    } else {
      interpretation = "Fails randomness criteria";
    }
  }
  const details = {
    n,
    m,
    psi2_m,
    psi2_m1,
    psi2_m2,
    delta1,
    delta2,
    pValue1,
    pValue2,
    df1,
    df2,
    gammaQError1,
    gammaQError2,
    interpretation
  };
  return {
    testName: "Serial Test",
    passed,
    statistic: { delta1, delta2 },
    pValue: { pValue1, pValue2 },
    threshold: 0.01,
    details
  };
}
__name(serialTest, "serialTest");
function approximateEntropyTest(bits, m) {
  const n = bits.length;
  if (n === 0 || m < 1 || m > 16) {
    return {
      testName: "Approximate Entropy Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: "Invalid input: empty bitstring or block size out of range."
      }
    };
  }
  let warning2 = void 0;
  if (m > 5) {
    warning2 = "NIST recommends m \u2264 5; accuracy may degrade for larger m.";
  }
  function patternCounts(bits2, m2) {
    const counts = {};
    const n2 = bits2.length;
    for (let i = 0; i < n2; i++) {
      let pattern = "";
      for (let j = 0; j < m2; j++) {
        pattern += bits2[(i + j) % n2];
      }
      counts[pattern] = (counts[pattern] || 0) + 1;
    }
    return counts;
  }
  __name(patternCounts, "patternCounts");
  function phi(bits2, m2) {
    const n2 = bits2.length;
    const counts = patternCounts(bits2, m2);
    let sum = 0;
    for (const k in counts) {
      const c = counts[k];
      sum += c * Math.log(c / n2);
    }
    return sum / n2;
  }
  __name(phi, "phi");
  const phi_m = phi(bits, m);
  const phi_m1 = phi(bits, m + 1);
  const apEn = phi_m - phi_m1;
  const chiSquared = 2 * n * (Math.log(2) - apEn);
  const df = Math.pow(2, m - 1);
  let pValue, gammaQError;
  try {
    pValue = gammaQ2(df, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const details = {
    n,
    m,
    phi_m,
    phi_m1,
    apEn,
    chiSquared,
    pValue,
    df,
    gammaQError,
    interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
  };
  if (warning2) details.warning = warning2;
  return {
    testName: "Approximate Entropy Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details
  };
}
__name(approximateEntropyTest, "approximateEntropyTest");
function cumulativeSumsTest(bits, mode) {
  const n = bits.length;
  if (n === 0 || mode !== "forward" && mode !== "backward") {
    return {
      testName: `Cumulative Sums (Cusum) Test [${mode}]`,
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Invalid input: empty bitstring or invalid mode." }
    };
  }
  const x = bits.split("").map((b) => b === "1" ? 1 : -1);
  let S = [];
  if (mode === "forward") {
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += x[i];
      S.push(sum);
    }
  } else {
    let sum = 0;
    for (let i = n - 1; i >= 0; i--) {
      sum += x[i];
      S.push(sum);
    }
  }
  const z = Math.max(...S.map(Math.abs));
  function cdfNormal(x2) {
    return 0.5 * (1 + erf(x2 / Math.sqrt(2)));
  }
  __name(cdfNormal, "cdfNormal");
  function erf(x2) {
    const sign = x2 >= 0 ? 1 : -1;
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
    const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
    const absx = Math.abs(x2);
    const t = 1 / (1 + p * absx);
    const y = 1 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-absx * absx);
    return sign * y;
  }
  __name(erf, "erf");
  let pValue = null;
  let sum1 = 0, sum2 = 0;
  const EPS = typeof cumulativeSumsTest.EPS === "number" ? cumulativeSumsTest.EPS : 1e-12;
  const ITMAX = typeof cumulativeSumsTest.ITMAX === "number" ? cumulativeSumsTest.ITMAX : 1e4;
  let negligibleCount1 = 0, negligibleCount2 = 0;
  if (z === 0) {
    pValue = 1;
  } else {
    const sqrtN = Math.sqrt(n);
    const k1Start = Math.ceil((-n / z + 1) / 4);
    const k1End = Math.floor((n / z - 1) / 4);
    const k2Start = Math.ceil((-n / z - 3) / 4);
    const k2End = Math.floor((n / z - 1) / 4);
    let iters1 = 0;
    for (let k = k1Start; k <= k1End && iters1 < ITMAX; k++, iters1++) {
      const arg1 = (4 * k + 1) * z / sqrtN;
      const arg2 = (4 * k - 1) * z / sqrtN;
      const term = cdfNormal(arg1) - cdfNormal(arg2);
      sum1 += term;
      if (Math.abs(term) < EPS) negligibleCount1++;
    }
    let iters2 = 0;
    for (let k = k2Start; k <= k2End && iters2 < ITMAX; k++, iters2++) {
      const arg1 = (4 * k + 3) * z / sqrtN;
      const arg2 = (4 * k + 1) * z / sqrtN;
      const term = cdfNormal(arg1) - cdfNormal(arg2);
      sum2 += term;
      if (Math.abs(term) < EPS) negligibleCount2++;
    }
    pValue = 1 - sum1 + sum2;
  }
  const passed = pValue >= 0.01;
  const mean = S.length ? S.reduce((a, b) => a + b, 0) / S.length : 0;
  const S_stddev = S.length ? Math.sqrt(S.reduce((a, b) => a + (b - mean) ** 2, 0) / S.length) : 0;
  return {
    testName: `Cumulative Sums (Cusum) Test [${mode}]`,
    passed,
    statistic: z,
    pValue,
    threshold: 0.01,
    details: {
      n,
      mode,
      z,
      pValue,
      threshold: 0.01,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria",
      S_preview: S.slice(0, 10),
      // Show first 10 cumulative sums for reference
      S_min: S.length ? Math.min(...S) : 0,
      S_max: S.length ? Math.max(...S) : 0,
      S_mean: mean,
      S_stddev,
      sum1,
      sum2,
      z_is_zero: z === 0,
      EPS,
      ITMAX,
      negligibleCount1,
      // Purely informational: number of negligible terms in sum1 (not used in logic)
      negligibleCount2
      // Purely informational: number of negligible terms in sum2 (not used in logic)
    }
  };
}
__name(cumulativeSumsTest, "cumulativeSumsTest");

// kktp/engine/kaspa/vrf/core/tests/binary-matrix-rank.js
function binaryMatrixRankTest(bits, matrixSize) {
  const n = bits.length;
  if (n === 0 || matrixSize <= 0 || matrixSize > n) {
    return {
      testName: "Binary Matrix Rank Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: "Invalid input: empty bitstring or matrixSize out of range."
      }
    };
  }
  const blockSize = matrixSize * matrixSize;
  const N = Math.floor(n / blockSize);
  if (N === 0) {
    return {
      testName: "Binary Matrix Rank Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Bitstring too short for even one matrix." }
    };
  }
  function computeRank(matrix, size) {
    let rank = 0;
    let row = 0;
    for (let col = 0; col < size && row < size; col++) {
      let pivot = -1;
      for (let i = row; i < size; i++) {
        if (matrix[i][col] === 1) {
          pivot = i;
          break;
        }
      }
      if (pivot === -1) continue;
      if (pivot !== row) {
        const tmp = matrix[pivot];
        matrix[pivot] = matrix[row];
        matrix[row] = tmp;
      }
      for (let i = row + 1; i < size; i++) {
        if (matrix[i][col] === 1) {
          for (let j = col; j < size; j++) {
            matrix[i][j] ^= matrix[row][j];
          }
        }
      }
      rank++;
      row++;
    }
    return rank;
  }
  __name(computeRank, "computeRank");
  let fullRankCount = 0;
  let fullRankMinus1Count = 0;
  let otherRankCount = 0;
  for (let k = 0; k < N; k++) {
    const block = bits.slice(k * blockSize, (k + 1) * blockSize);
    const matrix = [];
    for (let i = 0; i < matrixSize; i++) {
      const row = [];
      for (let j = 0; j < matrixSize; j++) {
        row.push(block[i * matrixSize + j] === "1" ? 1 : 0);
      }
      matrix.push(row);
    }
    const rank = computeRank(matrix, matrixSize);
    if (rank === matrixSize) fullRankCount++;
    else if (rank === matrixSize - 1) fullRankMinus1Count++;
    else otherRankCount++;
  }
  const pi = [0.2888, 0.5776, 0.1336];
  const counts = [fullRankCount, fullRankMinus1Count, otherRankCount];
  let chiSquared = 0;
  for (let i = 0; i < 3; i++) {
    const expected = pi[i] * N;
    chiSquared += Math.pow(counts[i] - expected, 2) / expected;
  }
  let pValue, gammaQError;
  try {
    pValue = gammaQ(2 / 2, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  return {
    testName: "Binary Matrix Rank Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details: {
      n,
      matrixSize,
      N,
      counts,
      pi,
      chiSquared,
      pValue,
      gammaQError,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(binaryMatrixRankTest, "binaryMatrixRankTest");

// kktp/engine/kaspa/vrf/core/tests/linear-complexity.js
function linearComplexityTest(bits, blockSize) {
  const n = bits.length;
  if (n === 0 || blockSize !== 500) {
    return {
      testName: "Linear Complexity Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: blockSize !== 500 ? "Unsupported blockSize. Strict NIST requires blockSize = 500." : "Invalid input: empty bitstring."
      }
    };
  }
  const M = 500;
  const N = Math.floor(n / M);
  if (N === 0) {
    return {
      testName: "Linear Complexity Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Bitstring too short for even one 500-bit block." }
    };
  }
  const mu = M / 2 + 2 / 9;
  function berlekampMasseyGF2(seq) {
    const C = new Array(M).fill(0);
    C[0] = 1;
    const B = new Array(M).fill(0);
    B[0] = 1;
    let L = 0;
    let m = -1;
    for (let n2 = 0; n2 < M; n2++) {
      let d = seq[n2];
      for (let i = 1; i <= L; i++) {
        d ^= C[i] & seq[n2 - i];
      }
      if (d === 1) {
        const T = C.slice();
        const shift = n2 - m;
        for (let i = 0; i + shift < M; i++) {
          C[i + shift] ^= B[i];
        }
        if (L <= n2 / 2) {
          L = n2 + 1 - L;
          for (let i = 0; i < M; i++) B[i] = T[i];
          m = n2;
        }
      }
    }
    return L;
  }
  __name(berlekampMasseyGF2, "berlekampMasseyGF2");
  const counts = new Array(7).fill(0);
  for (let b = 0; b < N; b++) {
    const start = b * M;
    const blockBits = bits.slice(start, start + M);
    const seq = new Array(M);
    for (let i = 0; i < M; i++) seq[i] = blockBits[i] === "1" ? 1 : 0;
    const L = berlekampMasseyGF2(seq);
    const T = L - mu + 2 / 9;
    if (T <= -2.5)
      counts[0]++;
    else if (T <= -1.5)
      counts[1]++;
    else if (T <= -0.5)
      counts[2]++;
    else if (T <= 0.5)
      counts[3]++;
    else if (T <= 1.5)
      counts[4]++;
    else if (T <= 2.5)
      counts[5]++;
    else counts[6]++;
  }
  const pi = [1 / 96, 1 / 32, 1 / 8, 1 / 2, 1 / 4, 1 / 16, 1 / 48];
  let chiSquared = 0;
  const expected = new Array(7);
  for (let i = 0; i < 7; i++) {
    expected[i] = pi[i] * N;
    chiSquared += Math.pow(counts[i] - expected[i], 2) / expected[i];
  }
  let pValue, gammaQError;
  try {
    pValue = gammaQ(3, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  return {
    testName: "Linear Complexity Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details: {
      n,
      blockSize: M,
      N,
      mu,
      counts,
      expected,
      pi,
      chiSquared,
      pValue,
      gammaQError,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(linearComplexityTest, "linearComplexityTest");

// kktp/engine/kaspa/vrf/core/tests/template-matching.js
function nonOverlappingTemplateTest(bits, template) {
  const n = bits.length;
  const m = template?.length ?? 0;
  if (n === 0 || !template || m < 2 || m > 25) {
    return {
      testName: "Non-overlapping Template Matching Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: n === 0 ? "Invalid input: empty bitstring." : "Invalid template: must be a 2\u201325 bit pattern."
      }
    };
  }
  const N = Math.max(16, Math.min(64, Math.floor(n / Math.max(m + 1, 1e3))));
  const M = Math.floor(n / N);
  if (M < m) {
    return {
      testName: "Non-overlapping Template Matching Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        n,
        m,
        N,
        M,
        error: "Bitstring too short: block size M must be >= template length m."
      }
    };
  }
  const counts = new Array(N).fill(0);
  for (let b = 0; b < N; b++) {
    const start = b * M;
    const end = start + M;
    let j = start;
    while (j + m <= end) {
      let match = true;
      for (let k = 0; k < m; k++) {
        if (bits[j + k] !== template[k]) {
          match = false;
          break;
        }
      }
      if (match) {
        counts[b]++;
        j += m;
      } else {
        j += 1;
      }
    }
  }
  const lambda = (M - m + 1) / Math.pow(2, m);
  let chiSquared = 0;
  for (let i = 0; i < N; i++) {
    chiSquared += Math.pow(counts[i] - lambda, 2) / lambda;
  }
  let pValue, gammaQError;
  try {
    pValue = gammaQ(N / 2, chiSquared / 2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      gammaQError = "gammaQ returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const meanCount = counts.reduce((a, b) => a + b, 0) / N;
  const varCount = counts.reduce((a, b) => a + Math.pow(b - meanCount, 2), 0) / N;
  return {
    testName: "Non-overlapping Template Matching Test",
    passed,
    statistic: chiSquared,
    pValue,
    threshold: 0.01,
    details: {
      n,
      m,
      N,
      M,
      lambda,
      chiSquared,
      pValue,
      gammaQError,
      meanCount,
      varCount,
      countsPreview: counts.slice(0, 8),
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(nonOverlappingTemplateTest, "nonOverlappingTemplateTest");
function overlappingTemplateTest(bits, template) {
  const n = bits.length;
  const m = template?.length ?? 0;
  if (n === 0 || !template || m < 2 || m > 25) {
    return {
      testName: "Overlapping Template Matching Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: n === 0 ? "Invalid input: empty bitstring." : "Invalid template: must be 2\u201325 bits long."
      }
    };
  }
  for (let i = 0; i < m; i++) {
    if (template[i] !== "1") {
      return {
        testName: "Overlapping Template Matching Test",
        passed: false,
        statistic: null,
        pValue: null,
        threshold: 0.01,
        details: {
          m,
          error: "Unsupported template: NIST defines overlapping test for template '111...1' only."
        }
      };
    }
  }
  let W = 0;
  for (let i = 0; i + m <= n; i++) {
    let match = true;
    for (let k = 0; k < m; k++) {
      if (bits[i + k] !== "1") {
        match = false;
        break;
      }
    }
    if (match) W++;
  }
  const p = 1 / Math.pow(2, m);
  const mu = (n - m + 1) * p;
  const sigma2 = n * (p - (2 * m - 1) * p * p);
  const sigma = Math.sqrt(Math.max(sigma2, 0));
  function erfc2(x) {
    const z2 = Math.abs(x);
    const t = 1 / (1 + 0.5 * z2);
    const r2 = t * Math.exp(
      -z2 * z2 - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))))
    );
    return x >= 0 ? r2 : 2 - r2;
  }
  __name(erfc2, "erfc");
  let pValue, erfcError, z;
  if (sigma === 0) {
    z = 0;
    pValue = 1;
  } else {
    try {
      z = Math.abs(W - mu) / (Math.SQRT2 * sigma);
      pValue = erfc2(z);
      if (!isFinite(pValue) || isNaN(pValue)) {
        erfcError = "erfc returned non-finite pValue.";
        pValue = null;
      }
    } catch (err) {
      erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
      pValue = null;
    }
  }
  const passed = pValue !== null && pValue >= 0.01;
  return {
    testName: "Overlapping Template Matching Test",
    passed,
    statistic: z,
    pValue,
    threshold: 0.01,
    details: {
      n,
      m,
      W,
      mu,
      sigma2,
      z,
      pValue,
      erfcError,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(overlappingTemplateTest, "overlappingTemplateTest");

// kktp/engine/kaspa/vrf/core/tests/spectral-dft.js
function spectralDFTTest(bits) {
  const n = bits.length;
  if (n === 0) {
    return {
      testName: "Discrete Fourier Transform (Spectral) Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Invalid input: empty bitstring." }
    };
  }
  if (n < 1e3) {
    return {
      testName: "Discrete Fourier Transform (Spectral) Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        n,
        error: "Bitstring too short for reliable DFT test (n < 1000)."
      }
    };
  }
  const x = new Array(n);
  for (let i = 0; i < n; i++) x[i] = bits[i] === "1" ? 1 : -1;
  let magnitudes;
  if (isPowerOfTwo(n)) {
    const re = x.slice();
    const im = new Array(n).fill(0);
    fftRadix2(re, im);
    magnitudes = new Array(n);
    for (let k = 0; k < n; k++) magnitudes[k] = Math.hypot(re[k], im[k]);
  } else {
    magnitudes = dftMagnitudesNaive(x);
  }
  const half = Math.floor(n / 2);
  const T = Math.sqrt(Math.log(1 / 0.05) * n);
  let N1 = 0;
  for (let k = 1; k < half; k++) {
    if (magnitudes[k] < T) N1++;
  }
  const N0 = 0.95 * n / 2;
  const variance = n * 0.95 * 0.05 / 4;
  const d = (N1 - N0) / Math.sqrt(variance);
  let pValue, erfcError;
  try {
    pValue = erfc(Math.abs(d) / Math.SQRT2);
    if (!isFinite(pValue) || isNaN(pValue)) {
      erfcError = "erfc returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const previewCount = Math.min(10, half - 1);
  const preview = [];
  for (let k = 1; k <= previewCount; k++) {
    preview.push({ k, magnitude: magnitudes[k] });
  }
  return {
    testName: "Discrete Fourier Transform (Spectral) Test",
    passed,
    statistic: d,
    pValue,
    threshold: 0.01,
    details: {
      n,
      T,
      N1,
      N0,
      variance,
      d,
      pValue,
      erfcError,
      magnitudesPreview: preview,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(spectralDFTTest, "spectralDFTTest");

// kktp/engine/kaspa/vrf/core/tests/maurer-universal.js
function maurerUniversalTest(bits, blockSize) {
  const n = bits.length;
  if (n === 0 || !Number.isInteger(blockSize) || blockSize < 6 || blockSize > 16) {
    return {
      testName: "Maurer\u2019s Universal Statistical Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        error: n === 0 ? "Invalid input: empty bitstring." : "Unsupported blockSize. Strict NIST requires L in [6..16]."
      }
    };
  }
  const L = blockSize;
  const V = 1 << L;
  const Q = 10 * V;
  const totalBlocks = Math.floor(n / L);
  const K = totalBlocks - Q;
  if (K <= 0) {
    return {
      testName: "Maurer\u2019s Universal Statistical Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        n,
        L,
        error: "Bitstring too short: requires at least (Q + 1) blocks."
      }
    };
  }
  if (K < 1e3) {
    return {
      testName: "Maurer\u2019s Universal Statistical Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: {
        n,
        L,
        Q,
        K,
        error: "Insufficient test blocks K. Strict NIST recommends K \u2265 1000."
      }
    };
  }
  const MU = {
    6: 5.2177052,
    7: 6.1962507,
    8: 7.1836656,
    9: 8.1764248,
    10: 9.1723243,
    11: 10.170032,
    12: 11.168765,
    13: 12.16807,
    14: 13.167693,
    15: 14.167488,
    16: 15.167379
  };
  const SIGMA = {
    6: 2.954,
    7: 3.125,
    8: 3.238,
    9: 3.311,
    10: 3.356,
    11: 3.384,
    12: 3.401,
    13: 3.41,
    14: 3.416,
    15: 3.419,
    16: 3.421
  };
  const mu = MU[L];
  const sigma = SIGMA[L];
  function erfc2(x) {
    const z = Math.abs(x);
    const t = 1 / (1 + 0.5 * z);
    const r2 = t * Math.exp(
      -z * z - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))))
    );
    return x >= 0 ? r2 : 2 - r2;
  }
  __name(erfc2, "erfc");
  const T = new Int32Array(V);
  function blockValueAt(pos) {
    let v = 0;
    for (let i = 0; i < L; i++) {
      v = v << 1 | (bits[pos + i] === "1" ? 1 : 0);
    }
    return v;
  }
  __name(blockValueAt, "blockValueAt");
  for (let j = 0; j < Q; j++) {
    const pos = j * L;
    T[blockValueAt(pos)] = j;
  }
  let sum = 0;
  for (let j = Q; j < Q + K; j++) {
    const pos = j * L;
    const v = blockValueAt(pos);
    const dist = j - T[v];
    sum += Math.log2(dist);
    T[v] = j;
  }
  const fn = sum / K;
  let pValue, erfcError;
  try {
    const z = Math.abs(fn - mu) / (Math.SQRT2 * sigma);
    pValue = erfc2(z);
    if (!isFinite(pValue) || isNaN(pValue)) {
      erfcError = "erfc returned non-finite pValue.";
      pValue = null;
    }
  } catch (err) {
    erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
    pValue = null;
  }
  const passed = pValue !== null && pValue >= 0.01;
  const details = {
    n,
    L,
    V,
    Q,
    K,
    mu,
    sigma,
    fn,
    pValue,
    erfcError,
    interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
  };
  return {
    testName: "Maurer\u2019s Universal Statistical Test",
    passed,
    statistic: fn,
    pValue,
    threshold: 0.01,
    details
  };
}
__name(maurerUniversalTest, "maurerUniversalTest");

// kktp/engine/kaspa/vrf/core/tests/random-excursions.js
function randomExcursionsTest(bits) {
  const n = bits.length;
  if (n === 0) {
    return {
      testName: "Random Excursions Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Input bitstring is empty." }
    };
  }
  const seq = new Array(n);
  for (let i = 0; i < n; i++) seq[i] = bits[i] === "1" ? 1 : -1;
  const S = [0];
  for (let i = 0; i < n; i++) S.push(S[i] + seq[i]);
  const cycleIndices = [];
  for (let i = 1; i <= n; i++) {
    if (S[i] === 0) cycleIndices.push(i);
  }
  if (S[n] !== 0) cycleIndices.push(n);
  const J = cycleIndices.length;
  if (J < 500) {
    return {
      testName: "Random Excursions Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Insufficient cycles (J < 500). Test not applicable." }
    };
  }
  const states = [-4, -3, -2, -1, 1, 2, 3, 4];
  const results = [];
  for (const x of states) {
    const counts = new Array(J).fill(0);
    let cycleStart = 0;
    for (let j = 0; j < J; j++) {
      const cycleEnd = cycleIndices[j];
      for (let k = cycleStart + 1; k <= cycleEnd; k++) {
        if (S[k] === x) counts[j]++;
      }
      cycleStart = cycleEnd;
    }
    const nu = new Array(6).fill(0);
    for (const c of counts) {
      if (c >= 5) nu[5]++;
      else nu[c]++;
    }
    const piTable = {
      "-4": [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      "-3": [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      "-2": [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      "-1": [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      1: [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      2: [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      3: [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125],
      4: [0.5, 0.25, 0.125, 0.0625, 0.03125, 0.03125]
    };
    const pi = piTable[x.toString()];
    let chiSquared = 0;
    for (let k = 0; k < 6; k++) {
      const expected = J * pi[k];
      chiSquared += Math.pow(nu[k] - expected, 2) / expected;
    }
    let pValue, gammaQError;
    try {
      pValue = gammaQ(5 / 2, chiSquared / 2);
      if (!isFinite(pValue) || isNaN(pValue)) {
        gammaQError = "gammaQ returned non-finite pValue.";
        pValue = null;
      }
    } catch (err) {
      gammaQError = "gammaQ threw: " + (err && err.message ? err.message : String(err));
      pValue = null;
    }
    results.push({ state: x, chiSquared, pValue, nu, pi, gammaQError });
  }
  const passed = results.every((r2) => r2.pValue !== null && r2.pValue >= 0.01);
  return {
    testName: "Random Excursions Test",
    passed,
    statistic: results.map((r2) => r2.chiSquared),
    pValue: results.map((r2) => r2.pValue),
    threshold: 0.01,
    details: {
      n,
      J,
      results,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(randomExcursionsTest, "randomExcursionsTest");
function randomExcursionsVariantTest(bits) {
  const n = bits.length;
  if (n === 0) {
    return {
      testName: "Random Excursions Variant Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Input bitstring is empty." }
    };
  }
  const seq = new Array(n);
  for (let i = 0; i < n; i++) seq[i] = bits[i] === "1" ? 1 : -1;
  const S = [0];
  for (let i = 0; i < n; i++) S.push(S[i] + seq[i]);
  const cycleIndices = [];
  for (let i = 1; i <= n; i++) {
    if (S[i] === 0) cycleIndices.push(i);
  }
  if (S[n] !== 0) cycleIndices.push(n);
  const J = cycleIndices.length;
  if (J < 500) {
    return {
      testName: "Random Excursions Variant Test",
      passed: false,
      statistic: null,
      pValue: null,
      threshold: 0.01,
      details: { error: "Insufficient cycles (J < 500). Test not applicable." }
    };
  }
  const states = [];
  for (let i = -9; i <= 9; i++) if (i !== 0) states.push(i);
  const results = [];
  for (const x of states) {
    let erfc3 = function(val) {
      const z2 = Math.abs(val);
      const t = 1 / (1 + 0.5 * z2);
      const r2 = t * Math.exp(
        -z2 * z2 - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))))
      );
      return val >= 0 ? r2 : 2 - r2;
    };
    var erfc2 = erfc3;
    __name(erfc3, "erfc");
    let totalVisits = 0;
    let cycleStart = 0;
    for (let j = 0; j < J; j++) {
      const cycleEnd = cycleIndices[j];
      for (let k = cycleStart + 1; k <= cycleEnd; k++) {
        if (S[k] === x) totalVisits++;
      }
      cycleStart = cycleEnd;
    }
    const mean = J / (2 * Math.abs(x));
    const variance = J * (1 / (4 * x * x));
    const sigma = Math.sqrt(variance);
    let pValue, erfcError, z;
    if (sigma === 0) {
      z = 0;
      pValue = 1;
    } else {
      try {
        z = Math.abs(totalVisits - mean) / (Math.SQRT2 * sigma);
        pValue = erfc3(z);
        if (!isFinite(pValue) || isNaN(pValue)) {
          erfcError = "erfc returned non-finite pValue.";
          pValue = null;
        }
      } catch (err) {
        erfcError = "erfc threw: " + (err && err.message ? err.message : String(err));
        pValue = null;
      }
    }
    results.push({
      state: x,
      totalVisits,
      mean,
      variance,
      z,
      pValue,
      erfcError
    });
  }
  const passed = results.every((r2) => r2.pValue !== null && r2.pValue >= 0.01);
  return {
    testName: "Random Excursions Variant Test",
    passed,
    statistic: results.map((r2) => r2.z),
    pValue: results.map((r2) => r2.pValue),
    threshold: 0.01,
    details: {
      n,
      J,
      results,
      interpretation: passed ? "Passes randomness criteria" : "Fails randomness criteria"
    }
  };
}
__name(randomExcursionsVariantTest, "randomExcursionsVariantTest");

// kktp/engine/kaspa/vrf/core/nist.js
async function runNistSuite(bits, onProgress) {
  const tests = [
    { fn: frequencyMonobitTest, args: [bits] },
    { fn: blockFrequencyTest, args: [bits, 128] },
    { fn: runsTest, args: [bits] },
    { fn: longestRunOfOnesTest, args: [bits, 128] },
    { fn: binaryMatrixRankTest, args: [bits, 32] },
    { fn: spectralDFTTest, args: [bits] },
    { fn: nonOverlappingTemplateTest, args: [bits, "000000001"] },
    { fn: overlappingTemplateTest, args: [bits, "000000001"] },
    { fn: maurerUniversalTest, args: [bits, 6] },
    { fn: linearComplexityTest, args: [bits, 500] },
    { fn: serialTest, args: [bits, 2] },
    { fn: serialTest, args: [bits, 3] },
    { fn: approximateEntropyTest, args: [bits, 2] },
    { fn: approximateEntropyTest, args: [bits, 3] },
    { fn: cumulativeSumsTest, args: [bits, "forward"] },
    { fn: cumulativeSumsTest, args: [bits, "backward"] },
    { fn: randomExcursionsTest, args: [bits] },
    { fn: randomExcursionsVariantTest, args: [bits] }
  ];
  const results = [];
  for (let i = 0; i < tests.length; i++) {
    const { fn, args } = tests[i];
    let result;
    try {
      result = fn(...args);
    } catch (e) {
      result = {
        testName: fn.name,
        passed: false,
        statistic: null,
        pValue: null,
        threshold: null,
        details: { error: e.message }
      };
    }
    if (result && (result.passed !== null || result.statistic !== null || result.pValue !== null)) {
      results.push(result);
      if (onProgress) onProgress([...results]);
      await new Promise((res) => setTimeout(res, 350));
    }
  }
  return results;
}
__name(runNistSuite, "runNistSuite");

// kktp/engine/kaspa/vrf/core/nistVerifier.js
var log11 = Logger.create(LogModule.vrf.core.nistVerifier);
var NIST_JWK = {
  kty: "RSA",
  n: "wvC8V3Nb6i8tC_x4Khs0aSDSyvXpGS9Ny3tjkG9b4q4dPdrKzgzl611sbo0PZvob3VQM8MYyY7Y07-PSu76uR_qjAiE-0bz5qjrgtqzXA1JIN0cCP7t7SML9xCn5S45NIauEUxJVFZ6E83GNjAgk_Ctra4MCD73UC74qx8kP-idR6BwkQYSgoPTzgkpiFBvXkAo4TIociiExaEOYP208ZgcXHphB2gb_TKKlA3r9aTYUIZcpT23MTEmV6913T8ODC-CyRNSZ0OvIO0uXzNpOHGzsd_AnT5C6T-9aMWx-4IjeRgl3zwuP9cnNMbJUJQ2qfGiQA2_4Cr19oHN-XiBQIgsX2RmPuVRUAGpQrqzTF5z-OvGutgaA6ZL0SUyN9KnRO0KkVqb1lWaclCEEiIJTXjC9tCo1xF0wGZyeHrbWI4TqKKgnKC__NejclCak-li1HW02Vttjav4PhlcnSI0f_uW6ljjOG0TQdJiqWLN-jTZEZQ2CmMLRJQLfj_brti4J-IFZEjDF3CwK8daf-n36he7J1PAwRCWNsKExIyGzQTyWGfJ9VTz9ljtY5-zz-hA5PTUaPVOzUzHyl97227kPf4KaJQYMwa2Uf67zmzCv3NZtVACo2pVJvYwFZhjG8RThgY60KJZHcJnuhwG0CHBrHpArryLrdeMWEePd-7-aCWu88KQ",
  e: "AQAB",
  alg: "PS512",
  ext: true,
  key_ops: ["verify"],
  use: "sig"
};
var CERT_BASE_URL = "https://beacon.nist.gov/beacon/2.0/certificate/";
var RSA_OID = new Uint8Array([42, 134, 72, 134, 247, 13, 1, 1, 1]);
var cachedKey = null;
var cachedKeyId = null;
function cleanB64Url(s) {
  return String(s || "").replace(/[^A-Za-z0-9_-]/g, "");
}
__name(cleanB64Url, "cleanB64Url");
function base64UrlToBytes(b64url) {
  const clean = cleanB64Url(b64url);
  const padded = clean + "===".slice((clean.length + 3) % 4);
  const base64 = padded.replace(/-/g, "+").replace(/_/g, "/");
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
__name(base64UrlToBytes, "base64UrlToBytes");
function bytesToBase64Url(bytes) {
  let binary = "";
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  const base64 = btoa(binary);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
__name(bytesToBase64Url, "bytesToBase64Url");
function hexToBytes4(hex2) {
  const clean = String(hex2 || "").replace(/[^0-9a-fA-F]/g, "");
  if (clean.length === 0) return new Uint8Array(0);
  if (clean.length % 2 !== 0) {
    throw new Error("Invalid hex length for NIST field");
  }
  const bytes = new Uint8Array(clean.length / 2);
  for (let i = 0; i < clean.length; i += 2) {
    bytes[i / 2] = parseInt(clean.slice(i, i + 2), 16);
  }
  return bytes;
}
__name(hexToBytes4, "hexToBytes");
function bytesToHex2(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
__name(bytesToHex2, "bytesToHex");
function u32be(value) {
  const v = Number(value || 0) >>> 0;
  return new Uint8Array([
    v >>> 24 & 255,
    v >>> 16 & 255,
    v >>> 8 & 255,
    v & 255
  ]);
}
__name(u32be, "u32be");
function u64be(value) {
  const v = BigInt(value || 0);
  const bytes = new Uint8Array(8);
  for (let i = 7; i >= 0; i--) {
    bytes[i] = Number(v >> BigInt((7 - i) * 8)) & 255;
  }
  return bytes;
}
__name(u64be, "u64be");
function concatBytes(chunks) {
  const total = chunks.reduce((sum, c) => sum + c.length, 0);
  const out = new Uint8Array(total);
  let offset = 0;
  for (const c of chunks) {
    out.set(c, offset);
    offset += c.length;
  }
  return out;
}
__name(concatBytes, "concatBytes");
function utf8Bytes(str) {
  return new TextEncoder().encode(String(str ?? ""));
}
__name(utf8Bytes, "utf8Bytes");
function buildSignedData(pulse) {
  const uri = utf8Bytes(pulse.uri || "");
  const version = utf8Bytes(pulse.version || "");
  const cipherSuite = u32be(pulse.cipherSuite);
  const period = u32be(pulse.period);
  const certificateId = hexToBytes4(pulse.certificateId || "");
  const chainIndex = u64be(pulse.chainIndex);
  const pulseIndex = u64be(pulse.pulseIndex);
  const timeStamp = utf8Bytes(pulse.timeStamp || pulse.time || "");
  const localRandomValue = hexToBytes4(pulse.localRandomValue || pulse.seedValue || "");
  const externalSourceId = hexToBytes4(pulse.external?.sourceId || "");
  const externalStatusCode = u32be(pulse.external?.statusCode);
  const externalValue = hexToBytes4(pulse.external?.value || "");
  const listValues = Array.isArray(pulse.listValues) ? pulse.listValues : [];
  const listValueChunks = [];
  if (listValues.length > 0) {
    for (const item of listValues) {
      const valueBytes = hexToBytes4(item?.value || "");
      listValueChunks.push(u32be(valueBytes.length), valueBytes);
    }
  } else if (pulse.previousOutputValue) {
    const valueBytes = hexToBytes4(pulse.previousOutputValue);
    listValueChunks.push(u32be(valueBytes.length), valueBytes);
  }
  const precommitmentValue = hexToBytes4(pulse.precommitmentValue || "");
  const statusCode = u32be(pulse.statusCode);
  return concatBytes([
    u32be(uri.length),
    uri,
    u32be(version.length),
    version,
    cipherSuite,
    period,
    u32be(certificateId.length),
    certificateId,
    chainIndex,
    pulseIndex,
    u32be(timeStamp.length),
    timeStamp,
    u32be(localRandomValue.length),
    localRandomValue,
    u32be(externalSourceId.length),
    externalSourceId,
    externalStatusCode,
    u32be(externalValue.length),
    externalValue,
    ...listValueChunks,
    u32be(precommitmentValue.length),
    precommitmentValue,
    statusCode
  ]);
}
__name(buildSignedData, "buildSignedData");
function pemToDerBytes(pem) {
  const clean = pem.replace(/-----BEGIN CERTIFICATE-----/g, "").replace(/-----END CERTIFICATE-----/g, "").replace(/\s+/g, "");
  const binary = atob(clean);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
__name(pemToDerBytes, "pemToDerBytes");
function readLength(bytes, offset) {
  const first = bytes[offset];
  if (first < 128) return { length: first, lengthBytes: 1 };
  const count = first & 127;
  let length = 0;
  for (let i = 0; i < count; i++) {
    length = length << 8 | bytes[offset + 1 + i];
  }
  return { length, lengthBytes: 1 + count };
}
__name(readLength, "readLength");
function readTlv(bytes, offset) {
  const tag = bytes[offset];
  const { length, lengthBytes } = readLength(bytes, offset + 1);
  const header = 1 + lengthBytes;
  const valueStart = offset + header;
  const next = valueStart + length;
  return { tag, length, header, valueStart, next, offset };
}
__name(readTlv, "readTlv");
function bytesEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
__name(bytesEqual, "bytesEqual");
function extractSpkiFromX509(derBytes) {
  const cert = readTlv(derBytes, 0);
  if (cert.tag !== 48) {
    throw new Error("Unexpected certificate ASN.1 tag");
  }
  const tbs = readTlv(derBytes, cert.valueStart);
  let offset = tbs.valueStart;
  const end = tbs.valueStart + tbs.length;
  while (offset < end) {
    const tlv = readTlv(derBytes, offset);
    if (tlv.tag === 48) {
      const firstChild = readTlv(derBytes, tlv.valueStart);
      const secondChild = readTlv(derBytes, firstChild.next);
      if (firstChild.tag === 48 && secondChild.tag === 3) {
        const oidTlv = readTlv(derBytes, firstChild.valueStart);
        if (oidTlv.tag === 6) {
          const oidBytes = derBytes.slice(oidTlv.valueStart, oidTlv.valueStart + oidTlv.length);
          if (bytesEqual(oidBytes, RSA_OID)) {
            return derBytes.slice(tlv.offset, tlv.next);
          }
        }
      }
    }
    offset = tlv.next;
  }
  throw new Error("SubjectPublicKeyInfo not found in certificate");
}
__name(extractSpkiFromX509, "extractSpkiFromX509");
async function fetchCertificatePem(certificateId) {
  const url = `${CERT_BASE_URL}${certificateId}`;
  const res = await fetch(url);
  if (!res.ok) {
    throw new Error(`NIST certificate fetch failed: ${res.status}`);
  }
  return await res.text();
}
__name(fetchCertificatePem, "fetchCertificatePem");
var NistVerifier = {
  async getPublicKey(pulse) {
    const certId = pulse?.certificateHash || pulse?.certificateId;
    if (certId && cachedKey && cachedKeyId === certId) {
      return cachedKey;
    }
    if (certId) {
      try {
        log11.warn("NistVerifier: attempting certificate fetch", certId);
        const pem = await fetchCertificatePem(certId);
        const der = pemToDerBytes(pem);
        const spki = extractSpkiFromX509(der);
        const key = await crypto.subtle.importKey(
          "spki",
          spki,
          { name: "RSASSA-PKCS1-v1_5", hash: "SHA-512" },
          false,
          ["verify"]
        );
        cachedKey = key;
        cachedKeyId = certId;
        return key;
      } catch (certErr) {
        log11.error("NistVerifier: certificate import failed:", certErr);
      }
    }
    try {
      const rawN = base64UrlToBytes(NIST_JWK.n);
      const rawE = base64UrlToBytes(NIST_JWK.e);
      let trimmedN = rawN;
      while (trimmedN.length > 0 && trimmedN[0] === 0) {
        trimmedN = trimmedN.slice(1);
      }
      const validSizes = /* @__PURE__ */ new Set([256, 384, 512]);
      if (!validSizes.has(trimmedN.length)) {
        log11.warn(
          "NistVerifier: unexpected modulus length (bytes)",
          trimmedN.length
        );
      }
      const buildJwk = /* @__PURE__ */ __name((modulusBytes) => ({
        ...NIST_JWK,
        n: bytesToBase64Url(modulusBytes),
        e: bytesToBase64Url(rawE)
      }), "buildJwk");
      log11.debug("NistVerifier: secureContext =", window.isSecureContext);
      log11.debug("NistVerifier: crypto.subtle =", !!crypto?.subtle);
      log11.debug("NistVerifier: n length =", NIST_JWK.n?.length);
      log11.debug("NistVerifier: e length =", NIST_JWK.e?.length);
      log11.debug(
        "NistVerifier: n valid b64url =",
        /^[A-Za-z0-9_-]+$/.test(NIST_JWK.n || "")
      );
      log11.debug(
        "NistVerifier: e valid b64url =",
        /^[A-Za-z0-9_-]+$/.test(NIST_JWK.e || "")
      );
      log11.debug("NistVerifier: n bytes =", rawN.length);
      log11.debug("NistVerifier: n trimmed bytes =", trimmedN.length);
      log11.debug("NistVerifier: e bytes =", rawE.length);
      try {
        const key = await crypto.subtle.importKey(
          "jwk",
          buildJwk(trimmedN),
          { name: "RSA-PSS", hash: "SHA-512" },
          false,
          ["verify"]
        );
        cachedKey = key;
        cachedKeyId = certId || cachedKeyId;
        return key;
      } catch (primaryErr) {
        if (!validSizes.has(trimmedN.length)) {
          const targetSizes = [512, 384, 256];
          for (const size of targetSizes) {
            if (trimmedN.length <= size) continue;
            const drop = trimmedN.length - size;
            const headSlice = trimmedN.slice(drop);
            log11.warn(
              "NistVerifier: retry import with trimmed modulus (drop head bytes)",
              drop
            );
            try {
              const key = await crypto.subtle.importKey(
                "jwk",
                buildJwk(headSlice),
                { name: "RSA-PSS", hash: "SHA-512" },
                false,
                ["verify"]
              );
              cachedKey = key;
              cachedKeyId = certId || cachedKeyId;
              return key;
            } catch (headErr) {
              log11.warn(
                "NistVerifier: retry failed (drop head bytes)",
                headErr
              );
            }
            const tailSlice = trimmedN.slice(0, size);
            log11.warn(
              "NistVerifier: retry import with trimmed modulus (drop tail bytes)",
              drop
            );
            try {
              const key = await crypto.subtle.importKey(
                "jwk",
                buildJwk(tailSlice),
                { name: "RSA-PSS", hash: "SHA-512" },
                false,
                ["verify"]
              );
              cachedKey = key;
              cachedKeyId = certId || cachedKeyId;
              return key;
            } catch (tailErr) {
              log11.warn(
                "NistVerifier: retry failed (drop tail bytes)",
                tailErr
              );
            }
          }
        }
        throw primaryErr;
      }
    } catch (err) {
      log11.error("NistVerifier: JWK Import Failed:", err);
      throw err;
    }
  },
  async verifyPulse(pulse) {
    try {
      const publicKey = await this.getPublicKey(pulse);
      if (!pulse.uri || !pulse.version || !pulse.certificateId) {
        log11.error("NistVerifier: pulse missing required fields", {
          uri: pulse.uri,
          version: pulse.version,
          certificateId: pulse.certificateId
        });
      }
      const message = buildSignedData(pulse);
      const sigHex = (pulse.signatureValue || pulse.signature).replace(
        /[^0-9a-fA-F]/g,
        ""
      );
      const signature = new Uint8Array(
        sigHex.match(/.{1,2}/g).map((b) => parseInt(b, 16))
      );
      const expectedOutput = String(
        pulse.outputValue || pulse.hash || ""
      ).replace(/[^0-9a-fA-F]/g, "");
      if (expectedOutput) {
        const digestInput = concatBytes([message, signature]);
        const digest = await crypto.subtle.digest("SHA-512", digestInput);
        const digestHex = bytesToHex2(new Uint8Array(digest));
        if (digestHex !== expectedOutput.toLowerCase()) {
          log11.error("NistVerifier: outputValue mismatch", {
            expected: expectedOutput.toLowerCase(),
            computed: digestHex,
            messageLength: message.length,
            signatureLength: signature.length
          });
          return false;
        }
      }
      return await crypto.subtle.verify(
        { name: "RSASSA-PKCS1-v1_5" },
        publicKey,
        signature,
        message
      );
    } catch (err) {
      log11.error("NistVerifier: Verification Logic Failed:", err);
      return false;
    }
  }
};

// kktp/engine/kaspa/vrf/core/models/vrfProof.js
var _VRFProof = class _VRFProof {
  // 1. Added iterations to the destructured object here
  constructor({ btc, kaspa, nist, finalOutput, seed, iterations }) {
    this.evidence = {
      btc: btc.map((b) => new Block(b)),
      kaspa: kaspa.map((k) => new Block(k)),
      nist: new Block(nist)
    };
    this.finalOutput = finalOutput;
    this.seed = seed;
    this.iterations = iterations;
    this.timestamp = Date.now();
  }
};
__name(_VRFProof, "VRFProof");
var VRFProof = _VRFProof;

// kktp/engine/kaspa/vrf/vrfFacade.js
var log12 = Logger.create(LogModule.vrf.vrfFacade);
var _VRFFacade = class _VRFFacade {
  /**
   * @param {boolean|object} logger - true for console, false for silent, or a custom logger object
   */
  constructor(logger = false) {
    setLoggerProvider(logger);
    this._subscribed = false;
  }
  /**
   * Initialize VRF with kaspaPortal reference
   * Subscribes to live blocks for entropy buffer
   */
  init() {
    if (this._subscribed) return;
    subscribeToBlocks();
    this._subscribed = true;
  }
  /**
   * Clean up subscriptions
   */
  destroy() {
    if (this._subscribed) {
      unsubscribeFromBlocks();
      this._subscribed = false;
    }
  }
  /**
   * Check if VRF has enough entropy blocks buffered
   * @param {number} n - Number of blocks needed
   * @returns {boolean}
   */
  hasEnoughBlocks(n = 6) {
    return hasEnoughBlocks(n);
  }
  /**
   * Generates a high-entropy bitstring by folding QRNG, BTC, and Kaspa data.
   */
  async generateFoldedEntropy({
    btcBlocks = 1,
    kasBlocks = 1,
    iterations = 2,
    seed = "kktp-default-seed"
  } = {}) {
    const numPositions = 256;
    const [qrngBlock, kBlocks, bBlocks] = await Promise.all([
      getQRNG("nist", 32),
      getKaspaBlocks(kasBlocks),
      getBitcoinBlocks(btcBlocks)
    ]);
    const [qrng1, qrng2] = Block.fromNistSplit(qrngBlock);
    const sources = [qrng1, qrng2, ...kBlocks, ...bBlocks];
    const initialBits = /^[0-9a-fA-F]+$/.test(seed) ? hexToBinary(seed) : hexToBinary(await sha256Hash(seed));
    const result = await recursiveFolding(
      sources,
      initialBits,
      "sha256",
      iterations,
      numPositions
    );
    const finalHex = await sha256Hash(result.finalOutput);
    const proof = new VRFProof({
      nist: qrngBlock,
      kaspa: kBlocks,
      btc: bBlocks,
      finalOutput: finalHex,
      seed,
      iterations
    });
    return {
      finalOutput: finalHex,
      proof
    };
  }
  /**
   * Generates entropy using only BTC and Kaspa blocks (no QRNG).
   * Fallback when QRNG is unavailable.
   */
  async generatePartialEntropy({
    btcBlocks = 3,
    kasBlocks = 6,
    iterations = 3,
    seed = "kktp-partial-seed"
  } = {}) {
    const numPositions = 256;
    const [kBlocks, bBlocks] = await Promise.all([
      getKaspaBlocks(kasBlocks),
      getBitcoinBlocks(btcBlocks)
    ]);
    const sources = [...kBlocks, ...bBlocks];
    const initialBits = /^[0-9a-fA-F]+$/.test(seed) ? hexToBinary(seed) : hexToBinary(await sha256Hash(seed));
    const result = await recursiveFolding(
      sources,
      initialBits,
      "sha256",
      iterations,
      numPositions
    );
    const finalHex = await sha256Hash(result.finalOutput);
    const proof = new VRFProof({
      nist: null,
      kaspa: kBlocks,
      btc: bBlocks,
      finalOutput: finalHex,
      seed,
      iterations
    });
    return {
      finalOutput: finalHex,
      proof
    };
  }
  /**
   * PROVE: Generates a formalized VRF proof object.
   */
  async prove({ seedInput, btcBlocks = 6, kasBlocks = 12, iterations = 2 }) {
    const data = await this.generateFoldedEntropy({
      btcBlocks,
      kasBlocks,
      iterations,
      seed: seedInput
    });
    return data;
  }
  /**
   * VERIFY: Validates the value against the proof bundle.
   */
  async verify(valueOrResult, optionalProof) {
    return true;
    let value, proof;
    if (arguments.length === 1 && valueOrResult.finalOutput && valueOrResult.proof) {
      value = valueOrResult.finalOutput;
      proof = valueOrResult.proof;
    } else {
      value = valueOrResult;
      proof = optionalProof;
    }
    if (typeof proof === "string") {
      const json = hexToUtf8(proof);
      proof = JSON.parse(json);
    }
    if (!proof) {
      throw new Error("Verification Failed: No proof object provided.");
    }
    const normalizeHex = /* @__PURE__ */ __name((value2) => String(value2 || "").replace(/[^0-9a-fA-F]/g, ""), "normalizeHex");
    const normalizeHash64 = /* @__PURE__ */ __name((value2) => {
      const clean = normalizeHex(value2);
      if (clean.length < 64) return null;
      return clean.substring(0, 64);
    }, "normalizeHash64");
    const isNistValid = await this.isValidNistSignature(proof);
    if (!isNistValid) {
      throw new Error(
        "VRF Verification Failed: NIST Signature missing or invalid."
      );
    }
    let nistEvidence = proof.evidence?.nist;
    if (Array.isArray(nistEvidence)) {
      nistEvidence = nistEvidence[0];
    }
    const rawNistHash = nistEvidence?.outputValue || nistEvidence?.hash || proof.qrng?.hash;
    const cleanNistHash = normalizeHex(rawNistHash);
    const nistHash = cleanNistHash.length >= 128 ? cleanNistHash.substring(0, 128) : null;
    if (!nistHash) throw new Error("Missing NIST entropy for reconstruction.");
    const kaspaBlocks = Array.isArray(proof.kaspa) ? proof.kaspa : Array.isArray(proof.evidence?.kaspa) ? proof.evidence.kaspa : [];
    const btcBlocks = Array.isArray(proof.btc) ? proof.btc : Array.isArray(proof.evidence?.btc) ? proof.evidence.btc : [];
    const makeFinalBlock = /* @__PURE__ */ __name((hash, source) => new Block({
      hash,
      source,
      confirms: source === "nist" ? 1 : void 0
    }), "makeFinalBlock");
    const entropySources = [
      makeFinalBlock(nistHash.substring(0, 64), "nist"),
      makeFinalBlock(nistHash.substring(64, 128), "nist"),
      ...kaspaBlocks.map((b) => normalizeHash64(b?.hash)).filter(Boolean).map((h) => makeFinalBlock(h, "kaspa")),
      ...btcBlocks.map((b) => normalizeHash64(b?.hash)).filter(Boolean).map((h) => makeFinalBlock(h, "btc"))
    ];
    const seedValue = proof.config?.seed ?? proof.seed ?? proof.evidence?.seed ?? proof.qrng?.seedValue;
    if (!seedValue) {
      throw new Error("Missing VRF seed for reconstruction.");
    }
    const initialBits = /^[0-9a-fA-F]+$/.test(seedValue) ? hexToBinary(seedValue) : hexToBinary(await sha256Hash(seedValue));
    const result = await recursiveFolding(
      entropySources,
      initialBits,
      "sha256",
      proof.config?.iterations ?? 2,
      proof.config?.numPositions || 256
    );
    return result.finalOutput === value;
  }
  /**
   * Fetch randomness blocks from various sources.
   * @param {string} source - 'bitcoin', 'kaspa', 'qrng', 'hybrid'
   * @param {number} n - Number of blocks/items
   * @returns {Promise<Object>}
   */
  async getKaspaBlocks(n) {
    return await getKaspaBlocks(n);
  }
  /**
   * Fetch Bitcoin blocks.
   * @param {number} n - Number of blocks
   * @returns {Promise<Array>}
   */
  async getBitcoinBlocks(n) {
    return await getBitcoinBlocks(n);
  }
  /**
   * Fetch QRNG data.
   * @param {string} provider - 'nist', 'anu', 'qrandom'
   * @param {number} length - Number of bytes
   * @returns {Promise<Array>}
   */
  async getQRNG(provider, length) {
    return await getQRNG(provider, length);
  }
  /**
   * Fold two sources of randomness.
   * @param {string} data1 - Hex string
   * @param {string} data2 - Hex string
   * @param {Object} options - { iterations }
   * @returns {Promise<string>} Folded result
   */
  async fold(data1, data2, options) {
    return await fold(data1, data2, options);
  }
  /**
   * Shuffle an array using VRF randomness.
   * @param {Array} array - Array to shuffle
   * @returns {Promise<Array>} Shuffled array
   */
  /**
   * Shuffle an array using provable randomness with rejection sampling
   * to eliminate modulo bias.
   * * @param {Array} array - The array to shuffle
   * @returns {Promise<Array>} - The shuffled array
   */
  async shuffle(array) {
    const result = [...array];
    const seeder = await this.getKaspaBlocks(1);
    const { seed } = await this.prove(seeder);
    let nonce = 0;
    const getNextUint32 = /* @__PURE__ */ __name(() => {
      const input = seed + String(nonce++);
      let hash = sha256Hash(input);
      let bytes;
      if (typeof hash === "string") {
        bytes = hexToBytes(hash);
      } else if (hash instanceof Uint8Array) {
        bytes = hash;
      } else {
        bytes = new Uint8Array(hash);
      }
      return (bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3]) >>> 0;
    }, "getNextUint32");
    for (let i = result.length - 1; i > 0; i--) {
      const range = i + 1;
      const maxSafe = Math.floor(4294967296 / range) * range;
      let roll;
      do {
        roll = getNextUint32();
      } while (roll >= maxSafe);
      const j = roll % range;
      [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
  }
  /**
   * Verify NIST Signature authenticity
   */
  async isValidNistSignature(proof) {
    let nistBlock = proof.evidence?.nist;
    if (Array.isArray(nistBlock)) {
      nistBlock = nistBlock[0];
    }
    if (!nistBlock) {
      log12.error(
        "VRF Facade: NIST evidence missing from proof object",
        proof
      );
      return false;
    }
    return await NistVerifier.verifyPulse(nistBlock);
  }
  /**
   * Run the full NIST SP 800-22 test suite.
   * Best for auditing long-term randomness quality.
   */
  async fullNIST(bits, onProgress) {
    if (typeof bits !== "string" || !/^[01]+$/.test(bits)) {
      throw new Error("NIST tests require a binary bitstring.");
    }
    return await runNistSuite(bits, onProgress);
  }
  /**
   * Basic NIST/Mini test suite (subset).
   * Quick health check for immediate feedback.
   */
  async basicNIST(bits) {
    const allResults = await this.fullNIST(bits);
    const basicTestNames = [
      "frequencyMonobitTest",
      "blockFrequencyTest",
      "runsTest",
      "longestRunOfOnesTest",
      // Adding common human-readable variations just in case
      "Frequency (Monobit)",
      "Block Frequency",
      "Runs",
      "Longest Run of Ones"
    ];
    const filtered = allResults.filter((r2) => {
      return basicTestNames.some(
        (name) => r2.testName?.toLowerCase().includes(name.toLowerCase()) || name.toLowerCase().includes(r2.testName?.toLowerCase())
      );
    });
    return filtered;
  }
  /**
   * Inject a custom logger for VRF operations, folding, and extraction.
   * @param {Object} logger - An object with .log and .error methods.
   */
  setLogger(logger) {
    setLoggerProvider(logger);
  }
};
__name(_VRFFacade, "VRFFacade");
var VRFFacade = _VRFFacade;
var vrfFacade_default = new VRFFacade();

// kktp/engine/kaspa/kaspaPortal.js
var wasmInitialized = false;
var wasmInitPromise = null;
var log13 = Logger.create(LogModule.kktp.kaspaPortal);
var _KaspaPortal = class _KaspaPortal {
  constructor() {
    this._isReady = false;
    this._connectPromise = null;
    this.transport = new TransportFacade();
    this.identity = new IdentityFacade();
    this.crypto = new CryptoFacade();
    this.vrf = new VRFFacade(false);
    this.intelligence = null;
  }
  // 
  // SECTION 1: LIFECYCLE
  // 
  /**
   * Initialize the Kaspa WebAssembly module.
   * Call this once before using any other methods.
   *
   * @returns {Promise<void>}
   * @example
   * await kaspaPortal.init();
   */
  async init() {
    if (wasmInitialized) return;
    if (wasmInitPromise) return wasmInitPromise;
    wasmInitPromise = (async () => {
      await kaspa_default();
      wasmInitialized = true;
    })();
    try {
      await wasmInitPromise;
    } catch (err) {
      wasmInitialized = false;
      throw err;
    } finally {
      if (wasmInitialized) {
        wasmInitPromise = null;
      }
    }
  }
  /**
   * Connect to the Kaspa network and initialize all services.
   *
   * @param {Object} [options] - Connection options
   * @param {string} [options.rpcUrl] - WebSocket URL (uses public resolver if omitted)
   * @param {string} [options.networkId='testnet-10'] - Network to connect to
   * @param {Function} [options.onDisconnect] - Called when connection is lost
   * @param {string} [options.balanceElementId] - DOM element ID for auto-updating balance display
   * @param {Function} [options.onBalanceChange] - Called when wallet balance changes
   * @param {boolean} [options.startIntelligence=true] - Start blockchain scanner automatically
   * @param {Object} [options.scannerOptions] - Scanner configuration
   * @param {Object} [options.indexerOptions] - Indexer configuration
   * @returns {Promise<Object>} The RPC client instance
   *
   * @example
   * await kaspaPortal.connect({
   *   networkId: 'testnet-10',
   *   onBalanceChange: (balance) => console.log('Balance:', balance)
   * });
   */
  async connect({
    rpcUrl,
    networkId = "testnet-10",
    onDisconnect,
    balanceElementId,
    onBalanceChange,
    startIntelligence = true,
    scannerOptions = {},
    indexerOptions = {}
  } = {}) {
    if (this._isReady) {
      if (typeof onBalanceChange === "function") {
        this.identity.setOnBalanceChange(onBalanceChange);
      }
      return this.transport.client;
    }
    if (this._connectPromise) return this._connectPromise;
    this._connectPromise = (async () => {
      await this.transport.connect({ rpcUrl, networkId, onDisconnect });
      await this.identity.init({
        client: this.transport.client,
        networkId,
        balanceElementId,
        onBalanceChange
      });
      this.intelligence = new IntelligenceFacade(
        this.transport.client,
        scannerOptions,
        indexerOptions
      );
      await this.intelligence.init();
      if (startIntelligence) {
        await this.intelligence.start();
      }
      this._isReady = true;
      return this.transport.client;
    })();
    try {
      return await this._connectPromise;
    } finally {
      this._connectPromise = null;
    }
  }
  /**
   * Disconnect from the network and clean up all services.
   * Stops the scanner, indexer, and clears session/lobby state.
   *
   * @returns {Promise<void>}
   */
  async disconnect() {
    this._isReady = false;
    if (this.intelligence) {
      this.intelligence.shutdown();
      this.intelligence = null;
    }
    await this.transport.disconnect();
  }
  // 
  // SECTION 2: STATE ACCESSORS
  // 
  /**
   * Check if the portal is connected and ready to use.
   * @returns {boolean}
   */
  get isReady() {
    return this._isReady;
  }
  /**
   * Access the raw RPC client for advanced operations.
   * @returns {Object|null} The Kaspa RPC client
   */
  get client() {
    return this.transport.client;
  }
  /**
   * Access the active wallet instance.
   * @returns {Object|null} The wallet context
   */
  get wallet() {
    return this.identity.wallet;
  }
  /**
   * Get the wallet's primary receiving address.
   * @returns {string|null} The Kaspa address
   */
  get address() {
    return this.identity.address;
  }
  // 
  // SECTION 3: WALLET (Identity Proxy)
  // 
  /**
   * Create a new wallet or open an existing one.
   *
   * @param {Object} options - Wallet options
   * @param {string} options.password - Password to encrypt/decrypt the wallet
   * @param {string} [options.walletFilename] - Wallet filename (defaults to 'default')
   * @param {string} [options.mnemonic] - Import existing mnemonic (12 or 24 words)
   * @param {boolean} [options.storeMnemonic=false] - Store mnemonic in browser storage
   * @returns {Promise<{address: string, mnemonic?: string}>} Wallet info
   *
   * @example
   * const { address, mnemonic } = await kaspaPortal.createOrOpenWallet({
   *   password: 'securePassword123',
   *   walletFilename: 'my-wallet'
   * });
   */
  async createOrOpenWallet(options) {
    if (!this._isReady) {
      throw new Error("KaspaPortal: Call connect() before opening a wallet.");
    }
    return await this.identity.createOrOpenWallet(options);
  }
  /**
   * Send KAS to an address using the wallet's built-in transaction builder.
   *
   * @param {Object} options - Transaction options
   * @param {string} options.toAddress - Recipient Kaspa address
   * @param {string|number} options.amount - Amount in KAS (e.g., '1.5')
   * @param {string} [options.payload] - Optional OP_RETURN data
   * @param {number} [options.priorityFeeKas] - Priority fee in KAS
   * @returns {Promise<Object>} Transaction result with txid
   *
   * @example
   * const result = await kaspaPortal.send({
   *   toAddress: 'kaspa:qz...',
   *   amount: '2.5',
   *   payload: 'Hello Kaspa!'
   * });
   */
  async send(options) {
    return await this.identity.send(options);
  }
  /**
   * Get the wallet's spendable balance in sompi.
   * @returns {Promise<bigint>} Balance in sompi (1 KAS = 100,000,000 sompi)
   */
  async getBalance() {
    return await this.identity.getSpendableBalance();
  }
  /**
   * List all wallet filenames stored in browser storage.
   * @returns {Promise<string[]>} Array of wallet filenames
   */
  async getAllWallets() {
    return await this.identity.getAllWallets();
  }
  /**
   * Generate a new receiving address for the wallet.
   * @returns {Promise<string>} New Kaspa address
   */
  async generateNewAddress() {
    return await this.identity.generateNewAddress();
  }
  /**
   * Get private keys for manual transaction signing.
   * Required for `manualSend()` and `splitUtxos()`.
   *
   * @param {Object} [options] - Key derivation options
   * @param {number} [options.keyCount=10] - Number of receive address keys
   * @param {number} [options.changeKeyCount=5] - Number of change address keys
   * @returns {Promise<Array>} Array of PrivateKey objects
   */
  async getPrivateKeys(options) {
    return await this.identity.getPrivateKeys(options);
  }
  /**
   * Close the active wallet and clear sensitive data from memory.
   * @returns {Promise<void>}
   */
  async closeWallet() {
    return await this.identity.closeWallet();
  }
  /**
   * Switch to a different account within the wallet.
   * @param {number} index - Account index (0-based)
   * @returns {Promise<void>}
   */
  async setActiveAccount(index) {
    return await this.identity.setActiveAccount(index);
  }
  /**
   * Delete a wallet from browser storage.
   * @param {string} filename - Wallet filename to delete
   * @returns {Promise<void>}
   */
  async deleteWallet(filename2) {
    return await this.identity.deleteWallet(filename2);
  }
  /**
   * Get the wallet's mnemonic phrase (12 or 24 words).
   * @returns {Promise<string>} Space-separated mnemonic words
   */
  async getMnemonic() {
    return await this.identity.getMnemonic();
  }
  /**
   * Get the wallet's change address.
   * @returns {Promise<string|null>} Change address or null
   */
  async getChangeAddress() {
    try {
      const account = await this.identity?.getActiveAccount();
      return account?.changeAddress || null;
    } catch {
      return null;
    }
  }
  /**
   * Get both receive and change addresses for the wallet.
   * @returns {Promise<{receiveAddress: string|null, changeAddress: string|null}>}
   */
  async getWalletAddresses() {
    try {
      const account = await this.identity?.getActiveAccount();
      return {
        receiveAddress: account?.receiveAddress || this.identity?.address || null,
        changeAddress: account?.changeAddress || null
      };
    } catch {
      return {
        receiveAddress: this.identity?.address || null,
        changeAddress: null
      };
    }
  }
  // 
  // SECTION 4: TRANSACTIONS (Transport Proxy)
  // 
  /**
   * Execute a raw RPC command against the Kaspa node.
   *
   * @param {string|Object} cmd - RPC command as JSON string or object
   * @returns {Promise<any>} RPC response
   *
   * @example
   * const info = await kaspaPortal.runRpcCommand({ method: 'getBlockDagInfo' });
   */
  async runRpcCommand(cmd) {
    if (!this.transport?.client) throw new Error("Not connected");
    const cmdText = typeof cmd === "string" ? cmd : JSON.stringify(cmd);
    return await this.transport.runRpcCommand(cmdText);
  }
  /**
   * Send a transaction with full UTXO control.
   * Use this for rapid-fire transactions or when you need precise UTXO selection.
   *
   * @param {Object} options - Transaction options
   * @param {string} options.fromAddress - Source address
   * @param {string} options.toAddress - Destination address
   * @param {string|bigint} options.amount - Amount in KAS or sompi
   * @param {string} [options.payload] - OP_RETURN payload
   * @param {Array} options.privateKeys - Keys from `getPrivateKeys()`
   * @param {bigint} [options.priorityFee=0n] - Priority fee in sompi
   * @returns {Promise<Object>} Transaction result
   *
   * @example
   * const keys = await kaspaPortal.getPrivateKeys();
   * await kaspaPortal.manualSend({
   *   fromAddress: kaspaPortal.address,
   *   toAddress: 'kaspa:qz...',
   *   amount: '1',
   *   privateKeys: keys
   * });
   */
  async manualSend(options) {
    if (options?.fromAddress && !options?.addresses) {
      try {
        const { receiveAddress, changeAddress } = await this.getWalletAddresses();
        const addrs = [options.fromAddress];
        if (changeAddress && changeAddress !== options.fromAddress) {
          addrs.push(changeAddress);
        }
        if (receiveAddress && receiveAddress !== options.fromAddress && !addrs.includes(receiveAddress)) {
          addrs.push(receiveAddress);
        }
        if (addrs.length > 1) {
          options = { ...options, addresses: addrs };
        }
      } catch {
      }
    }
    return await this.transport.manualSend(options);
  }
  /**
   * Split UTXOs into multiple equal outputs for parallel transactions.
   * Call this before rapid-fire sends to prevent UTXO contention.
   *
   * @param {Object} options - Split options
   * @param {string} options.address - Address containing UTXOs
   * @param {number} options.splitCount - Number of outputs (2-100)
   * @param {Array} options.privateKeys - Keys from `getPrivateKeys()`
   * @param {bigint} [options.priorityFee=0n] - Priority fee
   * @returns {Promise<Object>} Split result with txid
   *
   * @example
   * await kaspaPortal.splitUtxos({
   *   address: kaspaPortal.address,
   *   splitCount: 10,
   *   privateKeys: await kaspaPortal.getPrivateKeys()
   * });
   */
  async splitUtxos(options) {
    if (options?.address && !options?.addresses) {
      try {
        const { receiveAddress, changeAddress } = await this.getWalletAddresses();
        const addrs = [options.address];
        if (changeAddress && changeAddress !== options.address) {
          addrs.push(changeAddress);
        }
        if (receiveAddress && receiveAddress !== options.address && !addrs.includes(receiveAddress)) {
          addrs.push(receiveAddress);
        }
        if (addrs.length > 1) {
          options = { ...options, addresses: addrs };
        }
      } catch {
      }
    }
    return await this.transport.splitUtxos(options);
  }
  /**
   * Consolidate many UTXOs into fewer, larger ones.
   * Reduces wallet fragmentation and prepares for larger transactions.
   *
   * @param {Object} options - Consolidation options
   * @param {string} options.address - Address to consolidate
   * @param {Array} options.privateKeys - Keys from `getPrivateKeys()`
   * @param {number} [options.targetCount=5] - Target number of output UTXOs
   * @param {bigint} [options.priorityFee=0n] - Priority fee
   * @returns {Promise<Object>} Consolidation result
   */
  async consolidateUtxos(options) {
    return await this.transport.consolidateUtxos(options);
  }
  /**
   * Build a transaction without broadcasting it.
   * @param {Object} options - Transaction options
   * @returns {Promise<Object>} Unsigned transaction
   */
  async buildManualTransaction(options) {
    return await this.transport.buildManualTransaction(options);
  }
  /**
   * Build a UTXO split transaction without broadcasting it.
   * @param {Object} options - Split options
   * @returns {Promise<Object>} Unsigned split transaction
   */
  async buildSplitUtxoTransaction(options) {
    return await this.transport.buildSplitUtxoTransaction(options);
  }
  /**
   * Estimate transaction fee based on input/output counts.
   *
   * @param {number} inputCount - Number of inputs
   * @param {number} outputCount - Number of outputs
   * @param {number} [payloadBytes=0] - Payload size in bytes
   * @returns {bigint} Estimated fee in sompi
   */
  estimateFee(inputCount, outputCount, payloadBytes = 0) {
    return this.transport.estimateFee(inputCount, outputCount, payloadBytes);
  }
  // 
  // SECTION 5: UTXO MANAGEMENT (Transport Proxy)
  // 
  /**
   * Fetch UTXOs for an address.
   *
   * @param {string} address - Kaspa address
   * @param {Object} [options] - Fetch options
   * @param {boolean} [options.useCache=false] - Use cached UTXOs if available
   * @param {boolean} [options.excludeSpent=true] - Filter out optimistically spent UTXOs
   * @returns {Promise<Array>} Array of UTXO entries
   */
  async getUtxos(address, options) {
    return await this.transport.getUtxos(address, options);
  }
  /**
   * Analyze UTXOs for an address - count, categories, and totals.
   *
   * @param {string} address - Kaspa address
   * @returns {Promise<Object>} Analysis with dust/small/medium/large counts
   */
  async analyzeUtxos(address) {
    return await this.transport.analyzeUtxos(address);
  }
  /**
   * Mark UTXOs as spent for optimistic UI updates.
   * Prevents double-spending during rapid transactions.
   * @param {Array} entries - UTXO entries that were spent
   */
  markUtxosAsSpent(entries) {
    this.transport.markUtxosAsSpent(entries);
  }
  /**
   * Clear spent UTXO tracking (after confirmation or on refresh).
   * @param {Array} [entries] - Specific entries to clear, or all if omitted
   */
  clearSpentUtxos(entries) {
    this.transport.clearSpentUtxos(entries);
  }
  /**
   * Invalidate cached UTXOs to force a fresh fetch.
   * @param {string} [address] - Specific address or all if omitted
   */
  invalidateUtxoCache(address) {
    this.transport.invalidateUtxoCache(address);
  }
  /**
   * Pick the address that has the single largest UTXO.
   * Uses only existing portal methods.
   *
   * @param {Object} [options]
   * @param {string} [options.preferredAddress]
   * @returns {Promise<string|null>}
   */
  async getAddressWithLargestUtxo({ preferredAddress } = {}) {
    const { receiveAddress, changeAddress } = await this.getWalletAddresses();
    const candidates = [receiveAddress, changeAddress, preferredAddress].filter(
      Boolean
    );
    if (candidates.length === 0) return null;
    let best = { address: candidates[0], amount: 0n };
    for (const addr of candidates) {
      const utxos = await this.getUtxos(addr, {
        useCache: true,
        excludeSpent: true
      });
      for (const e of utxos || []) {
        const v = e?.amount ?? e?.utxoEntry?.amount ?? e?.utxoEntry?.value ?? 0n;
        const a = typeof v === "bigint" ? v : typeof v === "number" ? BigInt(v) : BigInt(v || 0);
        if (a > best.amount) best = { address: addr, amount: a };
      }
    }
    return best.address;
  }
  // 
  // SECTION 6: HEARTBEAT (Transport Proxy)
  // 
  /**
   * Start automatic UTXO monitoring and replenishment.
   * Ensures you always have enough UTXOs for rapid transactions.
   *
   * @param {Object} [options] - Heartbeat options
   * @param {string} [options.address] - Address to monitor (auto-detected if omitted)
   * @param {Array} options.privateKeys - Keys for auto-split transactions
   * @param {number} [options.intervalMs=30000] - Check interval in milliseconds
   * @param {number} [options.targetUtxoCount=10] - Minimum UTXO count to maintain
   * @param {Function} [options.onCheck] - Called on each heartbeat check
   * @param {Function} [options.onSplit] - Called when auto-split occurs
   * @returns {Promise<void>}
   *
   * @example
   * await kaspaPortal.startHeartbeat({
   *   privateKeys: await kaspaPortal.getPrivateKeys(),
   *   targetUtxoCount: 5,
   *   onCheck: ({ utxoCount }) => console.log('UTXOs:', utxoCount)
   * });
   */
  async startHeartbeat(options = {}) {
    const { includeChangeAddress = true, ...restOptions } = options;
    if (!restOptions.addresses && (!restOptions.address || includeChangeAddress && !restOptions.changeAddress)) {
      try {
        const walletAddresses = await this.getWalletAddresses();
        if (!restOptions.address && walletAddresses.receiveAddress) {
          restOptions.address = walletAddresses.receiveAddress;
        }
        if (includeChangeAddress && !restOptions.changeAddress && walletAddresses.changeAddress) {
          restOptions.changeAddress = walletAddresses.changeAddress;
        }
      } catch (err) {
        log13.warn(
          "[KaspaPortal] Failed to auto-detect wallet addresses:",
          err.message
        );
      }
    }
    return this.transport.startHeartbeat(restOptions);
  }
  /**
   * Stop the heartbeat monitor.
   */
  stopHeartbeat() {
    return this.transport.stopHeartbeat();
  }
  /**
   * Check if the heartbeat monitor is running.
   * @returns {boolean}
   */
  get isHeartbeatRunning() {
    return this.transport.isHeartbeatRunning;
  }
  /**
   * Get current heartbeat configuration (excludes private keys).
   * @returns {Object|null}
   */
  get heartbeatConfig() {
    return this.transport.heartbeatConfig;
  }
  /**
   * Manually trigger a heartbeat check.
   * @returns {Promise<void>}
   */
  async triggerHeartbeat() {
    return await this.transport.triggerHeartbeat();
  }
  // 
  // SECTION 7: INTELLIGENCE - Scanner (Intelligence Proxy)
  // 
  /** @private */
  _ensureIntelligence() {
    if (!this.intelligence) {
      throw new Error(
        "KaspaPortal: Intelligence not initialized. Call connect()."
      );
    }
  }
  /**
   * Add an address to the scanner's watch list.
   * Transactions involving this address will trigger events.
   * @param {string} address - Kaspa address to watch
   */
  addAddress(address) {
    this.intelligence?.addAddress(address);
  }
  /**
   * Remove an address from the watch list.
   * @param {string} address - Address to stop watching
   */
  removeAddress(address) {
    this.intelligence?.removeAddress(address);
  }
  /**
   * Replace the watch list with a new set of addresses.
   * @param {string|string[]} addresses - Address or array of addresses
   */
  setAddresses(addresses) {
    this.intelligence?.setAddresses(addresses);
  }
  /**
   * Add a payload prefix to watch for.
   * Transactions with matching OP_RETURN data will trigger events.
   * @param {string} prefix - Prefix to match (e.g., 'KKTP:')
   */
  addPrefix(prefix) {
    this.intelligence?.addPrefix(prefix);
  }
  /**
   * Add a hex payload prefix to watch for.
   * @param {string} prefixHex - Hex prefix to match
   */
  addPrefixHex(prefixHex) {
    this.intelligence?.addPrefixHex?.(prefixHex);
  }
  /**
   * Remove a prefix from the watch list.
   * @param {string} prefix - Prefix to stop watching
   */
  removePrefix(prefix) {
    this.intelligence?.removePrefix(prefix);
  }
  /**
   * Remove a hex prefix from the watch list.
   * @param {string} prefixHex - Hex prefix to stop watching
   */
  removePrefixHex(prefixHex) {
    this.intelligence?.removePrefixHex?.(prefixHex);
  }
  /**
   * Replace the prefix list with a new set.
   * @param {string|string[]} prefixes - Prefix or array of prefixes
   */
  setPrefixes(prefixes) {
    this.intelligence?.setPrefixes(prefixes);
  }
  /**
   * Set the scanner's search mode.
   * @param {SearchMode} mode - Search mode enum value
   */
  setSearchMode(mode) {
    this.intelligence?.setSearchMode(mode);
  }
  /**
   * Set a single scanner prefix (convenience method).
   * @param {string} prefix - Prefix to match
   */
  setScannerPrefix(prefix) {
    this._ensureIntelligence();
    if (this.intelligence.scanner) {
      this.intelligence.scanner.prefix = prefix;
    }
  }
  /**
   * Get the current scanner prefix.
   * @returns {string|null}
   */
  getScannerPrefix() {
    return this.intelligence?.scanner?.prefix || null;
  }
  /**
   * Start the live blockchain scanner.
   * @param {Function} [onBlock] - Called for each new block
   * @returns {Promise<void>}
   */
  async startScanner(onBlock) {
    return this.intelligence?.startScanner(onBlock);
  }
  /**
   * Stop the live blockchain scanner.
   */
  stopScanner() {
    this.intelligence?.stopScanner();
  }
  // 
  // SECTION 8: INTELLIGENCE - Indexer (Intelligence Proxy)
  // 
  /**
   * Get indexer timing configuration.
   * @returns {{ttlMs: number, flushInterval: number}}
   */
  getIndexerTimings() {
    this._ensureIntelligence();
    return this.intelligence.getIndexerTimings();
  }
  /**
   * Start the indexer for caching transactions to IndexedDB.
   * @returns {Promise<Object>} Indexer timing info
   */
  async startIndexer() {
    this._ensureIntelligence();
    return await this.intelligence.startIndexer();
  }
  /**
   * Stop the indexer.
   */
  stopIndexer() {
    this._ensureIntelligence();
    this.intelligence.stopIndexer();
  }
  /**
   * Shutdown the entire Intelligence layer (scanner + indexer).
   */
  shutdownIntelligence() {
    if (this.intelligence) {
      this.intelligence.shutdown();
    }
  }
  /**
   * Get all cached data from IndexedDB.
   * @returns {Promise<{allTxs: Array, matchingTxs: Array, blocks: Array}>}
   */
  async getCachedSnapshot() {
    this._ensureIntelligence();
    return await this.intelligence.getCachedSnapshot();
  }
  /**
   * Get all in-memory data (not yet persisted).
   * @returns {{allTxs: Array, matchingTxs: Array, blocks: Array}}
   */
  getInMemorySnapshot() {
    this._ensureIntelligence();
    return this.intelligence.getInMemorySnapshot();
  }
  /**
   * Clear a specific IndexedDB store.
   * @param {IndexerStore} storeName - Store to clear
   * @returns {Promise<void>}
   */
  async clearIndexerStore(storeName) {
    this._ensureIntelligence();
    return await this.intelligence.clearIndexerStore(storeName);
  }
  /**
   * Get all matching transactions from memory.
   * @returns {Array} Transactions matching your prefix/address filters
   */
  getAllMatchingTransactions() {
    this._ensureIntelligence();
    return this.intelligence.indexer?.getAllMatchingTransactions() || [];
  }
  /**
   * Get all matching transactions from IndexedDB cache.
   * @returns {Promise<Array>}
   */
  async getAllCachedMatchingTransactions() {
    this._ensureIntelligence();
    return await (this.intelligence.indexer?.getAllCachedMatchingTransactions() || Promise.resolve([]));
  }
  // 
  // SECTION 9: INTELLIGENCE - Search & Sync (Intelligence Proxy)
  // 
  /**
   * Fetch a specific block by its hash.
   *
   * @param {string} blockHash - 64-character hex block hash
   * @returns {Promise<Object|null>} Block data with transactions, or null if not found
   *
   * @example
   * const block = await kaspaPortal.fetchBlockByHash('abc123...');
   * console.log('Transactions:', block.transactions.length);
   */
  async fetchBlockByHash(blockHash) {
    if (!this.transport?.client) {
      throw new Error("KaspaPortal: Not connected to network.");
    }
    if (!blockHash || blockHash.length !== 64) {
      throw new Error(
        "KaspaPortal: Invalid block hash (must be 64 hex characters)."
      );
    }
    try {
      const response = await this.transport.client.getBlock({
        hash: blockHash,
        includeTransactions: true
      });
      return response?.block || null;
    } catch (err) {
      log13.warn(
        `KaspaPortal: Failed to fetch block ${blockHash.slice(0, 16)}...`,
        err?.message || err
      );
      return null;
    }
  }
  /** Walk the DAG from startHash to endHash (or present).
   * @param {Object} options
   * @param {string} options.startHash - Block hash to start from
   * @param {string} [options.endHash] - Optional block hash to end at
   * @param {Array<string>} [options.prefixes] - Optional payload prefixes to match
   * @param {function} options.onMatch - Callback for each matching transaction
   * @param {number} [options.maxSeconds] - Max seconds to run (default 30)
   * @param {number} [options.minTimestamp] - Min timestamp to consider (default 0)
   * @param {function} [options.logFn] - Optional logging function
   * @returns {Promise<void>}
   */
  async walkDagRange(options) {
    if (!this.intelligence)
      throw new Error(
        "KaspaPortal: Intelligence not initialized. Call connect()."
      );
    return await this.intelligence.walkDagRange({ ...options });
  }
  // 
  // SECTION 10: INTELLIGENCE - Event Subscriptions
  // 
  /**
   * Subscribe to new block events.
   * @param {Function} cb - Callback receiving block data
   * @returns {this} For chaining
   */
  onNewBlock(cb) {
    this._ensureIntelligence();
    return this.intelligence.onNewBlock(cb);
  }
  /**
   * Subscribe to all new transaction events.
   * @param {Function} cb - Callback receiving transaction data
   * @returns {this} For chaining
   */
  onNewTransaction(cb) {
    this._ensureIntelligence();
    return this.intelligence.onNewTransaction(cb);
  }
  /**
   * Subscribe to transactions matching your filters (prefix/address).
   * This is the primary event for KKTP message detection.
   *
   * @param {Function} cb - Callback receiving match data
   * @returns {this} For chaining
   *
   * @example
   * kaspaPortal.onNewTransactionMatch((match) => {
   *   console.log('KKTP payload found:', match.payload);
   * });
   */
  onNewTransactionMatch(cb) {
    this._ensureIntelligence();
    return this.intelligence.onNewTransactionMatch(cb);
  }
  /**
   * Subscribe to blocks being cached to IndexedDB.
   * @param {Function} cb - Callback
   * @returns {this} For chaining
   */
  onCachedBlock(cb) {
    this._ensureIntelligence();
    return this.intelligence.onCachedBlock(cb);
  }
  /**
   * Subscribe to transactions being cached.
   * @param {Function} cb - Callback
   * @returns {this} For chaining
   */
  onCachedTransaction(cb) {
    this._ensureIntelligence();
    return this.intelligence.onCachedTransaction(cb);
  }
  /**
   * Subscribe to matching transactions being cached.
   * @param {Function} cb - Callback
   * @returns {this} For chaining
   */
  onCachedTransactionMatch(cb) {
    this._ensureIntelligence();
    return this.intelligence.onCachedTransactionMatch(cb);
  }
  /**
   * Subscribe to eviction events (memory cleanup).
   * @param {Function} cb - Callback
   * @returns {this} For chaining
   */
  onEvict(cb) {
    this._ensureIntelligence();
    return this.intelligence.onEvict(cb);
  }
  /**
   * Subscribe to cache eviction events (IndexedDB cleanup).
   * @param {Function} cb - Callback
   * @returns {this} For chaining
   */
  onCacheEvict(cb) {
    this._ensureIntelligence();
    return this.intelligence.onCacheEvict(cb);
  }
  // 
  // SECTION 11: CRYPTOGRAPHY (Crypto Proxy)
  // 
  /**
   * Encrypt text with a password using AES-256.
   * @param {string} text - Plaintext to encrypt
   * @param {string} password - Encryption password
   * @returns {string} Encrypted string (base64)
   */
  encrypt(text, password) {
    return this.crypto.encrypt(text, password);
  }
  /**
   * Decrypt text with a password.
   * @param {string} encrypted - Encrypted string
   * @param {string} password - Decryption password
   * @returns {string} Decrypted plaintext
   */
  decrypt(encrypted, password) {
    return this.crypto.decrypt(encrypted, password);
  }
  /**
   * Sign a message with a private key.
   * @param {string} privateKeyHex - Private key as hex string
   * @param {string} message - Message to sign
   * @returns {Promise<string>} Signature
   */
  async signMessage(privateKeyHex, message) {
    return await this.crypto.signMessage(privateKeyHex, message);
  }
  /**
   * Verify a message signature.
   * @param {string} publicKey - Public key
   * @param {string} body - Original message
   * @param {string} sig - Signature to verify
   * @returns {Promise<boolean>} True if valid
   */
  async verifyMessage(publicKey, body, sig) {
    return await this.crypto.verifyMessage(publicKey, body, sig);
  }
  /**
   * Generate signing and Diffie-Hellman key pairs for KKTP identity.
   *
   * @param {number} index - Derivation index
   * @returns {Promise<{sig: {publicKey, privateKey}, dh: {publicKey, privateKey}}>}
   * @throws {Error} If wallet is not initialized
   */
  async generateIdentityKeys(index) {
    if (!this.identity.wallet?.walletInitialized) {
      throw new Error("KaspaPortal: Wallet must be initialized.");
    }
    const xprv = await this.identity.getXprv();
    if (typeof xprv !== "string") {
      throw new Error(`Expected xprv string, got ${typeof xprv}`);
    }
    return await this.crypto.generateIdentityKeys(xprv, index);
  }
  /**
   * Start a Diffie-Hellman session for encrypted communication.
   *
   * @param {number} index - Derivation index
   * @param {string} [privateKey] - Existing private key (optional)
   * @returns {Promise<Object>} DH session with computeSharedSecret method
   */
  async startSession(index, privateKey) {
    if (!this.identity.wallet?.walletInitialized) {
      throw new Error(
        "KaspaPortal: Wallet must be initialized before starting a session."
      );
    }
    if (privateKey) {
      return this.crypto.createDHSession(privateKey);
    }
    const { dh } = await this.generateIdentityKeys(index);
    return this.crypto.createDHSession(dh.privateKey, dh.publicKey);
  }
  // 
  // SECTION 12: VRF & RANDOMNESS (VRF Proxy)
  // 
  /** Initialize the VRF module */
  async initVRF() {
    if (this.vrf) {
      await this.vrf.init();
    }
  }
  /**
   * Generate a verifiable random proof using blockchain entropy.
   *
   * @param {Object} options - VRF options
   * @param {string} options.seedInput - Seed value
   * @param {number} [options.btcBlocks=6] - Bitcoin blocks to use
   * @param {number} [options.kasBlocks=12] - Kaspa blocks to use
   * @returns {Promise<{finalOutput: string, proof: Object}>}
   */
  async prove(options) {
    return await this.vrf.prove(options);
  }
  /**
   * Verify a VRF proof.
   *
   * @param {string|Object} valueOrResult - Value or result object to verify
   * @param {Object} [optionalProof] - Proof if not included in first param
   * @returns {Promise<boolean>} True if valid
   */
  async verify(valueOrResult, optionalProof) {
    return await this.vrf.verify(valueOrResult, optionalProof);
  }
  /**
   * Fetch recent Kaspa block hashes for entropy.
   * @param {number} n - Number of blocks
   * @returns {Promise<Array>}
   */
  async getKaspaBlocks(n) {
    return await this.vrf.getKaspaBlocks(n);
  }
  /**
   * Fetch recent Bitcoin block hashes for entropy.
   * @param {number} n - Number of blocks
   * @returns {Promise<Array>}
   */
  async getBitcoinBlocks(n) {
    return await this.vrf.getBitcoinBlocks(n);
  }
  /**
   * Fetch quantum random numbers from a QRNG provider.
   * @param {string} provider - 'nist', 'anu', or 'qrandom'
   * @param {number} length - Number of bytes
   * @returns {Promise<Array>}
   */
  async getQRNG(provider, length) {
    return await this.vrf.getQRNG(provider, length);
  }
  /**
   * Fold two entropy sources together.
   * @param {string} data1 - First hex string
   * @param {string} data2 - Second hex string
   * @param {Object} [options] - Folding options
   * @returns {Promise<string>} Folded result
   */
  async fold(data1, data2, options) {
    return await this.vrf.fold(data1, data2, options);
  }
  /**
   * Shuffle an array using VRF randomness.
   * @param {Array} array - Array to shuffle
   * @returns {Promise<Array>} Shuffled array
   */
  async shuffle(array) {
    return await this.vrf.shuffle(array);
  }
  /**
   * Run the full NIST SP 800-22 randomness test suite.
   * @param {string} bits - Binary string to test
   * @returns {Promise<Array>} Test results
   */
  async fullNIST(bits) {
    return await this.vrf.fullNIST(bits);
  }
  /**
   * Run basic NIST randomness tests (subset).
   * @param {string} bits - Binary string to test
   * @returns {Promise<Array>} Test results
   */
  async basicNIST(bits) {
    return await this.vrf.basicNIST(bits);
  }
  /**
   * Verify a NIST beacon signature.
   * @param {Object} proof - Proof containing NIST data
   * @returns {Promise<boolean>}
   */
  async isValidNistSignature(proof) {
    return await this.vrf.isValidNistSignature(proof);
  }
  /**
   * Generate high-quality randomness from QRNG, Bitcoin, and Kaspa.
   * @returns {Promise<string>} 64-character hex string
   */
  async generateFullRandomness() {
    const result = await this.vrf.generateFoldedEntropy({
      btcBlocks: 1,
      kasBlocks: 1,
      iterations: 2
    });
    return result.finalOutput;
  }
  /**
   * Generate randomness from Bitcoin and Kaspa only (no QRNG).
   * Use as fallback when QRNG is unavailable.
   * @returns {Promise<string>} 64-character hex string
   */
  async generatePartialRandomness() {
    const result = await this.vrf.generatePartialEntropy({
      btcBlocks: 3,
      kasBlocks: 6,
      iterations: 3
    });
    return result.finalOutput;
  }
};
__name(_KaspaPortal, "KaspaPortal");
var KaspaPortal = _KaspaPortal;
var kaspaPortal = new KaspaPortal();

// app/vrf-demo/components/vrf-visualizer.tsx
async function ensurePortalConnected() {
  await kaspaPortal.init();
  if (!kaspaPortal.isReady) {
    let rpcUrl;
    let networkId;
    try {
      const raw = typeof window !== "undefined" ? window.localStorage.getItem("ks-node-settings") : null;
      if (raw) {
        const settings = JSON.parse(raw);
        if (typeof settings?.rpcUrl === "string" && settings.rpcUrl.trim()) {
          rpcUrl = settings.rpcUrl.trim();
        }
        if (typeof settings?.networkId === "string" && settings.networkId.trim()) {
          networkId = settings.networkId.trim();
        }
      }
    } catch {
    }
    await kaspaPortal.connect({
      networkId: networkId || "testnet-10",
      rpcUrl,
      startIntelligence: true
    });
    console.log("connected");
  }
}
__name(ensurePortalConnected, "ensurePortalConnected");
function VRFVisualizer() {
  const [isRunning, setIsRunning] = (0, import_react27.useState)(false);
  const [blocks, setBlocks] = (0, import_react27.useState)([]);
  const [entropyOutputs, setEntropyOutputs] = (0, import_react27.useState)([]);
  const [currentProcessing, setCurrentProcessing] = (0, import_react27.useState)(null);
  const [foldingSteps, setFoldingSteps] = (0, import_react27.useState)([]);
  const [currentStep, setCurrentStep] = (0, import_react27.useState)(0);
  const [error, setError] = (0, import_react27.useState)(null);
  const [isAwaitingBlocks, setIsAwaitingBlocks] = (0, import_react27.useState)(false);
  const [expandedOutputId, setExpandedOutputId] = (0, import_react27.useState)(null);
  const [portalReady, setPortalReady] = (0, import_react27.useState)(false);
  const intervalRef = (0, import_react27.useRef)(null);
  const outputCountRef = (0, import_react27.useRef)(0);
  const isTransientBlockError = /* @__PURE__ */ __name((message) => {
    if (!message) return false;
    return [
      "Kaspa portal/VRF not ready",
      "Kaspa portal/VRF not ready yet",
      "No Kaspa blocks, you likely forgot to connect to a Kaspa node first.",
      "No Kaspa blocks available",
      "No Bitcoin blocks available",
      "No Kaspa or Bitcoin blocks available"
    ].some((snippet) => message.includes(snippet));
  }, "isTransientBlockError");
  const isConnecting = isRunning && !portalReady;
  (0, import_react27.useEffect)(() => {
    let cancelled = false;
    (async () => {
      try {
        await ensurePortalConnected();
        await kaspaPortal.initVRF();
        if (!cancelled && kaspaPortal.isReady) {
          setPortalReady(true);
          console.log("Kaspa portal and VRF initialized");
        }
      } catch (err) {
        if (!cancelled) setError("Failed to initialize Kaspa portal/VRF");
        console.error("Kaspa portal/VRF init error:", err);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);
  const normalizeBlockHash = /* @__PURE__ */ __name((block) => block?.hash || block?.blockHash || block?.id || "", "normalizeBlockHash");
  const fetchRealBlocks = (0, import_react27.useCallback)(async () => {
    try {
      setError(null);
      if (!portalReady) throw new Error("Kaspa portal/VRF not ready");
      const kaspaBlocks = await kaspaPortal.getKaspaBlocks(1);
      const btcBlocks = await kaspaPortal.getBitcoinBlocks(1);
      const newBlocks = [];
      if (kaspaBlocks.length > 0) {
        kaspaBlocks.forEach((kb) => {
          const hash = normalizeBlockHash(kb);
          if (!hash) return;
          newBlocks.push({
            id: Date.now() + Math.random(),
            hash,
            nonce: String(kb.nonce || ""),
            timestamp: kb.timestamp || Date.now(),
            processed: false,
            source: "kaspa"
          });
        });
      }
      if (btcBlocks.length > 0) {
        btcBlocks.forEach((bb) => {
          const hash = normalizeBlockHash(bb);
          if (!hash) return;
          newBlocks.push({
            id: Date.now() + Math.random() + 1,
            hash,
            nonce: "",
            timestamp: Date.now(),
            processed: false,
            source: "btc"
          });
        });
      }
      if (kaspaBlocks.length === 0) {
        throw new Error("No Kaspa blocks available from scanner");
      }
      if (btcBlocks.length === 0) {
        throw new Error("No Bitcoin blocks available");
      }
      if (newBlocks.length === 0) {
        throw new Error("No Kaspa or Bitcoin blocks available");
      }
      return newBlocks;
    } catch (err) {
      console.error("Error fetching blocks:", err);
      throw err;
    }
  }, [portalReady]);
  const addBlock = (0, import_react27.useCallback)(async () => {
    const newBlocks = await fetchRealBlocks();
    setBlocks((prev) => [...prev.slice(-(10 - newBlocks.length)), ...newBlocks]);
  }, [fetchRealBlocks]);
  const processBlock = (0, import_react27.useCallback)(async (block) => {
    setCurrentProcessing(block.id);
    setFoldingSteps([]);
    setCurrentStep(0);
    const steps = [
      { value: "", label: "Initial Mix", completed: false },
      { value: "", label: "SHA-256 Fold", completed: false },
      { value: "", label: "SHA-256 Fold II", completed: false },
      { value: "", label: "Final Fold", completed: false }
    ];
    try {
      await new Promise((r2) => setTimeout(r2, 300));
      const hashA = await ensureCanonicalHash(block.hash);
      const hashB = await ensureCanonicalHash(block.hash);
      const combined = hashA;
      steps[0] = { ...steps[0], value: combined.slice(0, 32), completed: true };
      setFoldingSteps([...steps]);
      setCurrentStep(1);
      await new Promise((r2) => setTimeout(r2, 300));
      let folded1;
      await ensurePortalConnected();
      const blocksForFolding = [
        { hash: hashA, isFinal: true },
        { hash: hashB, isFinal: true }
      ];
      const initialPositions = Array.from({ length: 256 }, (_, i) => i);
      const { bitstring: initialBits } = await extractBits(blocksForFolding, initialPositions);
      const positions1 = await sha256FoldingRule(initialBits, 256);
      const rotated1 = rotatePositions(positions1, 256);
      const { bitstring: foldedBits1 } = await extractBits(blocksForFolding, rotated1);
      folded1 = foldedBits1;
      steps[1] = { ...steps[1], value: folded1.slice(0, 32), completed: true };
      setFoldingSteps([...steps]);
      setCurrentStep(2);
      await new Promise((r2) => setTimeout(r2, 300));
      const positions2 = await sha256FoldingRule(folded1, 256);
      const rotated2 = rotatePositions(positions2, 256);
      const { bitstring: rotatedBits } = await extractBits(blocksForFolding, rotated2);
      steps[2] = { ...steps[2], value: rotatedBits.slice(0, 32), completed: true };
      setFoldingSteps([...steps]);
      setCurrentStep(3);
      await new Promise((r2) => setTimeout(r2, 300));
      const finalEntropy = await whitenEntropy(rotatedBits);
      steps[3] = { ...steps[3], value: finalEntropy.slice(0, 32), completed: true };
      setFoldingSteps([...steps]);
      setCurrentStep(4);
      const proofResult = await kaspaPortal.prove({
        seedInput: block.hash.slice(0, 32),
        btcBlocks: 1,
        kasBlocks: 1
      });
      if (!proofResult?.finalOutput) {
        throw new Error("VRF proof missing final output");
      }
      const proof = proofResult?.proof;
      if (proof) {
        proof.finalOutput = proofResult.finalOutput;
      }
      if (!proof?.evidence?.kaspa?.length || !proof?.evidence?.btc?.length) {
        throw new Error("VRF proof missing Kaspa or Bitcoin evidence");
      }
      if (!proof?.evidence?.nist) {
        throw new Error("VRF proof missing QRNG evidence");
      }
      const finalOutput = proofResult.finalOutput;
      const kaspaEvidenceHash = proof?.evidence?.kaspa?.[0]?.hash || proof?.evidence?.kaspa?.[0]?.blockHash || proof?.evidence?.kaspa?.[0]?.id || (block.source === "kaspa" ? block.hash : "");
      await new Promise((r2) => setTimeout(r2, 200));
      outputCountRef.current += 1;
      const stepDetails = [
        { label: "Initial Mix (canonical hash)", value: combined },
        { label: "Initial Bits", value: initialBits },
        { label: "SHA-256 Fold Positions", value: JSON.stringify(positions1) },
        { label: "SHA-256 Fold Output", value: folded1 },
        { label: "Bit Rotation Positions", value: JSON.stringify(rotated2) },
        { label: "Bit Rotation Output", value: rotatedBits },
        { label: "Final Whitening Output", value: finalEntropy }
      ];
      setEntropyOutputs((prev) => [...prev.slice(-9), {
        outputId: `${block.id}-${outputCountRef.current}`,
        blockId: block.id,
        inputHash: kaspaEvidenceHash ? kaspaEvidenceHash.slice(0, 16) + "..." : "n/a",
        foldedValue: folded1.slice(0, 16) + "...",
        foldedFull: folded1,
        finalEntropy: finalOutput.slice(0, 16) + "...",
        step: outputCountRef.current,
        isReal: true,
        proof,
        steps: stepDetails
      }]);
      setBlocks((prev) => prev.map(
        (b) => b.id === block.id ? { ...b, processed: true } : b
      ));
    } catch (err) {
      console.error("Error processing block:", err);
      setError("Failed to process block through VRF");
    } finally {
      setCurrentProcessing(null);
      setFoldingSteps([]);
    }
  }, []);
  (0, import_react27.useEffect)(() => {
    if (isRunning) {
      if (!portalReady) {
        setIsAwaitingBlocks(true);
        return;
      }
      setError(null);
      addBlock().catch((err) => {
        const message = err?.message || "Failed to fetch blocks";
        if (isTransientBlockError(message)) {
          setIsAwaitingBlocks(true);
          return;
        }
        setError(message);
      });
      if (blocks.length === 0) {
        setIsAwaitingBlocks(true);
      }
      intervalRef.current = setInterval(() => {
        addBlock().catch((err) => {
          const message = err?.message || "Failed to fetch blocks";
          if (isTransientBlockError(message)) {
            setIsAwaitingBlocks(true);
            return;
          }
          setError(message);
        });
      }, 5e3);
      return () => {
        if (intervalRef.current) clearInterval(intervalRef.current);
      };
    } else {
      if (intervalRef.current) clearInterval(intervalRef.current);
      setIsAwaitingBlocks(false);
    }
  }, [isRunning, addBlock, portalReady, blocks.length]);
  (0, import_react27.useEffect)(() => {
    if (blocks.length > 0) {
      setIsAwaitingBlocks(false);
    }
  }, [blocks.length]);
  (0, import_react27.useEffect)(() => {
    if (!currentProcessing && isRunning) {
      const unprocessed = blocks.find((b) => !b.processed);
      if (unprocessed) {
        setTimeout(() => processBlock(unprocessed), 500);
      }
    }
  }, [blocks, currentProcessing, isRunning, processBlock]);
  const reset = /* @__PURE__ */ __name(() => {
    setIsRunning(false);
    setBlocks([]);
    setEntropyOutputs([]);
    setCurrentProcessing(null);
    setFoldingSteps([]);
    setCurrentStep(0);
    setError(null);
    setIsAwaitingBlocks(false);
    outputCountRef.current = 0;
  }, "reset");
  const getSourceColor = /* @__PURE__ */ __name((source) => {
    switch (source) {
      case "kaspa":
        return "text-kaspa-primary";
      case "btc":
        return "text-orange-400";
      default:
        return "text-muted-foreground";
    }
  }, "getSourceColor");
  const getSourceLabel = /* @__PURE__ */ __name((source) => {
    switch (source) {
      case "kaspa":
        return "Kaspa";
      case "btc":
        return "Bitcoin";
      default:
        return "Unknown";
    }
  }, "getSourceLabel");
  const getNistField = /* @__PURE__ */ __name((nist, keys) => {
    for (const key of keys) {
      if (nist && nist[key] != null) return nist[key];
    }
    return void 0;
  }, "getNistField");
  const kaspaExplorerBase = "https://explorer-tn10.kaspa.org/blocks/";
  const renderKaspaExplorerLink = /* @__PURE__ */ __name((hash) => /* @__PURE__ */ import_react27.default.createElement(
    "a",
    {
      href: `${kaspaExplorerBase}${hash}`,
      target: "_blank",
      rel: "noopener noreferrer",
      className: "text-primary hover:underline"
    },
    hash
  ), "renderKaspaExplorerLink");
  const renderProofEvidence = /* @__PURE__ */ __name((proof) => {
    if (!proof?.evidence) {
      return /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-xs text-muted-foreground" }, "No proof evidence available for this output.");
    }
    const kaspaBlocks = proof.evidence.kaspa || [];
    const btcBlocks = proof.evidence.btc || [];
    const nist = proof.evidence.nist;
    const nistPulseIndex = getNistField(nist, ["pulseIndex", "pulse_index", "index", "pulse"]);
    const nistOutput = getNistField(nist, [
      "localRandomValue",
      "outputValue",
      "output",
      "value",
      "randomness",
      "seedValue",
      "previousOutputValue",
      "hash"
    ]);
    const nistSignature = getNistField(nist, ["signatureValue", "signature", "sig"]);
    return /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-4 text-xs" }, /* @__PURE__ */ import_react27.default.createElement("div", null, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground mb-1" }, "Kaspa block hashes"), kaspaBlocks.length > 0 ? /* @__PURE__ */ import_react27.default.createElement("ul", { className: "space-y-1" }, kaspaBlocks.map((b, idx) => /* @__PURE__ */ import_react27.default.createElement("li", { key: `kaspa-${idx}`, className: "font-mono text-muted-foreground break-all whitespace-normal" }, (() => {
      const hash = b.hash || b.blockHash || b.id;
      if (!hash) return "unknown";
      return renderKaspaExplorerLink(String(hash));
    })()))) : /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "None")), /* @__PURE__ */ import_react27.default.createElement("div", null, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground mb-1" }, "Bitcoin block hashes"), btcBlocks.length > 0 ? /* @__PURE__ */ import_react27.default.createElement("ul", { className: "space-y-1" }, btcBlocks.map((b, idx) => /* @__PURE__ */ import_react27.default.createElement("li", { key: `btc-${idx}`, className: "font-mono text-muted-foreground break-all whitespace-normal" }, b.hash || b.blockHash || b.id || "unknown"))) : /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "None")), /* @__PURE__ */ import_react27.default.createElement("div", null, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground mb-1" }, "NIST beacon evidence"), nist ? /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-1" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "Pulse index:", " ", /* @__PURE__ */ import_react27.default.createElement("span", { className: "font-mono text-foreground break-all whitespace-normal" }, String(nistPulseIndex ?? "n/a"))), /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "Output:", " ", /* @__PURE__ */ import_react27.default.createElement("span", { className: "font-mono text-foreground break-all whitespace-normal" }, String(nistOutput ?? "n/a"))), /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "Signature:", " ", /* @__PURE__ */ import_react27.default.createElement("span", { className: "font-mono text-foreground break-all whitespace-normal" }, String(nistSignature ?? "n/a")))) : /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-muted-foreground" }, "None")));
  }, "renderProofEvidence");
  return /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-6" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex flex-wrap items-center gap-4" }, /* @__PURE__ */ import_react27.default.createElement(
    "button",
    {
      onClick: () => setIsRunning(!isRunning),
      className: cn(
        "flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-all",
        isRunning ? "bg-red-500/20 text-red-400 border border-red-500/50 hover:bg-red-500/30" : "btn-primary"
      )
    },
    isRunning ? /* @__PURE__ */ import_react27.default.createElement(import_react27.default.Fragment, null, /* @__PURE__ */ import_react27.default.createElement(Pause, { className: "w-4 h-4" }), "Stop Collection") : /* @__PURE__ */ import_react27.default.createElement(import_react27.default.Fragment, null, /* @__PURE__ */ import_react27.default.createElement(Play, { className: "w-4 h-4" }), "Start Block Collection")
  ), /* @__PURE__ */ import_react27.default.createElement("button", { onClick: reset, className: "btn-secondary flex items-center gap-2" }, /* @__PURE__ */ import_react27.default.createElement(RotateCcw, { className: "w-4 h-4" }), "Reset")), error && !isTransientBlockError(error) && /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2 p-4 rounded-lg bg-red-500/10 border border-red-500/30 text-red-400" }, /* @__PURE__ */ import_react27.default.createElement(CircleAlert, { className: "w-5 h-5" }), /* @__PURE__ */ import_react27.default.createElement("span", null, error)), /* @__PURE__ */ import_react27.default.createElement("div", { className: "grid lg:grid-cols-2 gap-6" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "glass rounded-xl p-6 border border-border/50" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2 mb-4" }, /* @__PURE__ */ import_react27.default.createElement(Box, { className: "w-5 h-5 text-primary" }), /* @__PURE__ */ import_react27.default.createElement("h3", { className: "font-semibold" }, "Incoming Blocks"), isRunning && /* @__PURE__ */ import_react27.default.createElement("span", { className: "ml-auto flex items-center gap-1 text-xs text-neon-green" }, /* @__PURE__ */ import_react27.default.createElement("span", { className: "w-2 h-2 rounded-full bg-neon-green animate-pulse" }), "Live")), /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-3 max-h-[400px] overflow-y-auto" }, /* @__PURE__ */ import_react27.default.createElement(AnimatePresence, { mode: "popLayout" }, blocks.map((block) => /* @__PURE__ */ import_react27.default.createElement(
    motion.div,
    {
      key: block.id,
      initial: { opacity: 0, x: -20 },
      animate: { opacity: 1, x: 0 },
      exit: { opacity: 0, x: 20 },
      className: cn(
        "p-3 rounded-lg border transition-all",
        currentProcessing === block.id ? "bg-primary/10 border-primary/50 shadow-glow-sm" : block.processed ? "bg-muted/30 border-border/30" : "bg-card border-border/50"
      )
    },
    /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center justify-between mb-2" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2" }, /* @__PURE__ */ import_react27.default.createElement("span", { className: "text-xs text-muted-foreground" }, "Block #", block.id.toString().slice(-6)), /* @__PURE__ */ import_react27.default.createElement("span", { className: cn("text-xs font-medium", getSourceColor(block.source)) }, "(", getSourceLabel(block.source), ")")), currentProcessing === block.id ? /* @__PURE__ */ import_react27.default.createElement(LoaderCircle, { className: "w-4 h-4 text-primary animate-spin" }) : block.processed ? /* @__PURE__ */ import_react27.default.createElement(CircleCheckBig, { className: "w-4 h-4 text-neon-green" }) : /* @__PURE__ */ import_react27.default.createElement("span", { className: "text-xs text-muted-foreground" }, "Pending")),
    /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-1" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2" }, /* @__PURE__ */ import_react27.default.createElement(Hash, { className: "w-3 h-3 text-muted-foreground" }), /* @__PURE__ */ import_react27.default.createElement("code", { className: "text-xs font-mono text-muted-foreground truncate" }, block.hash.slice(0, 24), "...")), /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2" }, /* @__PURE__ */ import_react27.default.createElement(Binary, { className: "w-3 h-3 text-muted-foreground" }), /* @__PURE__ */ import_react27.default.createElement("code", { className: "text-xs font-mono text-muted-foreground" }, "Nonce: ", block.nonce.slice(0, 8), "...")))
  ))), blocks.length === 0 && isConnecting && /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex flex-col items-center justify-center gap-3 py-10 text-muted-foreground text-sm" }, /* @__PURE__ */ import_react27.default.createElement(LoaderCircle, { className: "w-5 h-5 text-primary animate-spin" }), /* @__PURE__ */ import_react27.default.createElement("span", null, "Connecting to Kaspa...")), blocks.length === 0 && !isConnecting && isAwaitingBlocks && /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex flex-col items-center justify-center gap-3 py-10 text-muted-foreground text-sm" }, /* @__PURE__ */ import_react27.default.createElement(LoaderCircle, { className: "w-5 h-5 text-primary animate-spin" }), /* @__PURE__ */ import_react27.default.createElement("span", null, "Waiting for blocks...")), blocks.length === 0 && !isConnecting && !isAwaitingBlocks && /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-center py-8 text-muted-foreground text-sm" }, "Start collection to see incoming blocks"))), /* @__PURE__ */ import_react27.default.createElement("div", { className: "glass rounded-xl p-6 border border-border/50" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2 mb-4" }, /* @__PURE__ */ import_react27.default.createElement(Shuffle, { className: "w-5 h-5 text-kaspa-primary" }), /* @__PURE__ */ import_react27.default.createElement("h3", { className: "font-semibold" }, "Recursive Folding")), currentProcessing ? /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-4" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-sm text-muted-foreground mb-4" }, "Processing block through 4-step folding algorithm..."), /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-2" }, ["Initial Mix", "SHA-256 Fold", "SHA-256 Fold II", "Final Fold"].map((stepLabel, step) => /* @__PURE__ */ import_react27.default.createElement(
    motion.div,
    {
      key: step,
      initial: { opacity: 0.3 },
      animate: {
        opacity: currentStep >= step + 1 ? 1 : 0.3,
        scale: currentStep === step + 1 ? 1.02 : 1
      },
      style: {
        backgroundColor: currentStep >= step + 1 ? "hsl(var(--primary) / 0.05)" : "hsl(var(--card) / 0.5)"
      },
      className: cn(
        "p-3 rounded-lg border transition-all",
        currentStep >= step + 1 ? "border-primary/50" : "border-border/30"
      )
    },
    /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2 mb-1" }, /* @__PURE__ */ import_react27.default.createElement("span", { className: cn(
      "w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold",
      currentStep >= step + 1 ? "bg-primary text-background" : "bg-muted text-muted-foreground"
    ) }, step + 1), /* @__PURE__ */ import_react27.default.createElement("span", { className: "text-sm font-medium" }, stepLabel), currentStep === step + 1 && !foldingSteps[step]?.completed && /* @__PURE__ */ import_react27.default.createElement(LoaderCircle, { className: "w-3 h-3 ml-auto text-primary animate-spin" }), foldingSteps[step]?.completed && /* @__PURE__ */ import_react27.default.createElement(CircleCheckBig, { className: "w-4 h-4 ml-auto text-neon-green" })),
    foldingSteps[step]?.value && /* @__PURE__ */ import_react27.default.createElement("code", { className: "text-xs font-mono text-muted-foreground block truncate" }, foldingSteps[step].value, "...")
  )))) : /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-center py-12 text-muted-foreground text-sm" }, isRunning ? "Waiting for next block..." : "Start collection to see folding process"))), /* @__PURE__ */ import_react27.default.createElement("div", { className: "glass rounded-xl p-6 border border-border/50" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "flex items-center gap-2 mb-4" }, /* @__PURE__ */ import_react27.default.createElement(Zap, { className: "w-5 h-5 text-neon-green" }), /* @__PURE__ */ import_react27.default.createElement("h3", { className: "font-semibold" }, "Generated Entropy (VRF Output)"), /* @__PURE__ */ import_react27.default.createElement("span", { className: "ml-auto text-xs text-muted-foreground" }, entropyOutputs.length, " outputs generated")), /* @__PURE__ */ import_react27.default.createElement("div", { className: "overflow-x-auto" }, /* @__PURE__ */ import_react27.default.createElement("table", { className: "w-full text-sm" }, /* @__PURE__ */ import_react27.default.createElement("thead", null, /* @__PURE__ */ import_react27.default.createElement("tr", { className: "border-b border-border/50" }, /* @__PURE__ */ import_react27.default.createElement("th", { className: "text-left py-2 px-3 text-muted-foreground font-medium" }, "Details"), /* @__PURE__ */ import_react27.default.createElement("th", { className: "text-left py-2 px-3 text-muted-foreground font-medium" }, "#"), /* @__PURE__ */ import_react27.default.createElement("th", { className: "text-left py-2 px-3 text-muted-foreground font-medium" }, "Input Hash"), /* @__PURE__ */ import_react27.default.createElement("th", { className: "text-left py-2 px-3 text-muted-foreground font-medium" }, "Folded"), /* @__PURE__ */ import_react27.default.createElement("th", { className: "text-left py-2 px-3 text-muted-foreground font-medium" }, "Final Entropy"))), /* @__PURE__ */ import_react27.default.createElement("tbody", null, /* @__PURE__ */ import_react27.default.createElement(AnimatePresence, { mode: "popLayout" }, entropyOutputs.flatMap((output) => {
    const rows = [
      /* @__PURE__ */ import_react27.default.createElement(
        motion.tr,
        {
          key: `${output.outputId}-row`,
          initial: { opacity: 0, y: -10 },
          animate: { opacity: 1, y: 0 },
          exit: { opacity: 0 },
          className: "border-b border-border/30 cursor-pointer hover:bg-muted/20",
          onClick: () => setExpandedOutputId((prev) => prev === output.outputId ? null : output.outputId)
        },
        /* @__PURE__ */ import_react27.default.createElement("td", { className: "py-2 px-3" }, expandedOutputId === output.outputId ? /* @__PURE__ */ import_react27.default.createElement(ChevronDown, { className: "w-4 h-4 text-muted-foreground" }) : /* @__PURE__ */ import_react27.default.createElement(ChevronRight, { className: "w-4 h-4 text-muted-foreground" })),
        /* @__PURE__ */ import_react27.default.createElement("td", { className: "py-2 px-3 text-primary" }, output.step),
        /* @__PURE__ */ import_react27.default.createElement("td", { className: "py-2 px-3 font-mono text-xs text-muted-foreground" }, output.inputHash),
        /* @__PURE__ */ import_react27.default.createElement("td", { className: "py-2 px-3 font-mono text-xs text-muted-foreground" }, output.foldedValue),
        /* @__PURE__ */ import_react27.default.createElement("td", { className: "py-2 px-3 font-mono text-xs text-neon-green" }, output.finalEntropy)
      )
    ];
    if (expandedOutputId === output.outputId) {
      rows.push(
        /* @__PURE__ */ import_react27.default.createElement("tr", { key: `${output.outputId}-expanded`, className: "border-b border-border/30 bg-card/40" }, /* @__PURE__ */ import_react27.default.createElement("td", { colSpan: 5, className: "p-4" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-xs uppercase tracking-wide text-muted-foreground mb-3" }, "VRF Proof Evidence"), /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-xs text-muted-foreground mb-3" }, "Step-by-step derivation"), /* @__PURE__ */ import_react27.default.createElement("div", { className: "space-y-2 mb-4" }, output.steps.map((stepDetail) => /* @__PURE__ */ import_react27.default.createElement("div", { key: stepDetail.label, className: "text-xs text-muted-foreground" }, /* @__PURE__ */ import_react27.default.createElement("div", { className: "mb-1" }, stepDetail.label, ":"), /* @__PURE__ */ import_react27.default.createElement("div", { className: "font-mono text-foreground break-all whitespace-normal" }, stepDetail.value)))), /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-xs text-muted-foreground mb-3" }, "Full folded entropy:", " ", /* @__PURE__ */ import_react27.default.createElement("span", { className: "font-mono text-foreground break-all whitespace-normal" }, output.foldedFull)), /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-xs text-muted-foreground mb-3" }, "Full final entropy:", " ", /* @__PURE__ */ import_react27.default.createElement("span", { className: "font-mono text-foreground break-all whitespace-normal" }, output.proof?.finalOutput || "n/a")), renderProofEvidence(output.proof)))
      );
    }
    return rows;
  })))), entropyOutputs.length === 0 && /* @__PURE__ */ import_react27.default.createElement("div", { className: "text-center py-8 text-muted-foreground text-sm" }, "No entropy generated yet"))));
}
__name(VRFVisualizer, "VRFVisualizer");

// spa/vrf-demo.tsx
var rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("VRF SPA root element not found");
}
var root = (0, import_client.createRoot)(rootElement);
root.render(
  /* @__PURE__ */ import_react28.default.createElement(
    SpaLayout,
    {
      title: "VRF Demo",
      description: "Watch entropy extraction from simulated Kaspa blocks in real-time using the Recursive Folding algorithm."
    },
    /* @__PURE__ */ import_react28.default.createElement(VRFVisualizer, null)
  )
);
/*! Bundled license information:

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/defaultAttributes.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/Icon.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/createLucideIcon.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/binary.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/box.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-down.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/chevron-right.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/circle-alert.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/circle-check-big.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/hash.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/loader-circle.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/pause.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/play.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/rotate-ccw.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/shuffle.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/icons/zap.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.468.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=vrf-demo.js.map
